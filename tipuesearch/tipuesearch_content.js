var tipuesearch = {"pages":[{"title":" PSFUN ","text":"PSFUN Lo scopo della Matematica è di determinare il valore numerico delle incognite\n   che si presentano nei problemi pratici. Newton, Euler, Lagrange, Cauchy, Gauss,\n   e tutti i grandi matematici sviluppano le loro mirabili teorie fino al calcolo\n   delle cifre decimali necessarie. -- Giuseppe Peano Non esistono problemi dai quali si può prescindere. Non c'è niente di più\n   penoso di coloro i quali suddividono il pensiero dell'uomo in un pensiero da\n   cui non si può prescindere e in uno da cui si può prescindere. Fra costoro\n   si celano i nostri futuri carnefici. -- Una partita a scacchi con Albert Einstein, Friedrich Dürrenmatt Developer Info Fabio Durastante Junior Researcher","tags":"home","loc":"index.html"},{"title":"quadraturetest.F90 – PSFUN","text":"This file depends on sourcefile~~quadraturetest.f90~~EfferentGraph sourcefile~quadraturetest.f90 quadraturetest.F90 sourcefile~psfun_quadrature_mod.f90 psfun_quadrature_mod.f90 sourcefile~quadraturetest.f90->sourcefile~psfun_quadrature_mod.f90 sourcefile~psfun_utils_mod.f90 psfun_utils_mod.f90 sourcefile~quadraturetest.f90->sourcefile~psfun_utils_mod.f90 sourcefile~psfun_d_quadrature_mod.f90 psfun_d_quadrature_mod.F90 sourcefile~psfun_quadrature_mod.f90->sourcefile~psfun_d_quadrature_mod.f90 sourcefile~psfun_base_quadrature_mod.f90 psfun_base_quadrature_mod.f90 sourcefile~psfun_quadrature_mod.f90->sourcefile~psfun_base_quadrature_mod.f90 sourcefile~psfun_z_quadrature_mod.f90 psfun_z_quadrature_mod.F90 sourcefile~psfun_quadrature_mod.f90->sourcefile~psfun_z_quadrature_mod.f90 sourcefile~psfun_d_quadrature_mod.f90->sourcefile~psfun_utils_mod.f90 sourcefile~psfun_d_quadrature_mod.f90->sourcefile~psfun_base_quadrature_mod.f90 sourcefile~psfun_base_quadrature_mod.f90->sourcefile~psfun_utils_mod.f90 sourcefile~psfun_z_quadrature_mod.f90->sourcefile~psfun_utils_mod.f90 sourcefile~psfun_z_quadrature_mod.f90->sourcefile~psfun_base_quadrature_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs quadraturetest Source Code quadraturetest.F90 Source Code ! BSD 3-Clause License ! ! Copyright (c) 2020, Fabio Durastante ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this !    list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. program quadraturetest !! Basic test for the quadrature routines from [[psfun_quadrature_mod]] use psb_base_mod use psfun_utils_mod use psfun_quadrature_mod type ( psb_ctxt_type ) :: ctxt type ( psfun_z_quadrature ) :: quad procedure ( zquadfun ), pointer :: zfun procedure ( zquadrule ), pointer :: quadformula integer ( psb_ipk_ ) :: N , info real ( psb_dpk_ ) :: rparams ( 2 ) character ( len = 20 ) :: name ! Variable for debug complex ( psb_dpk_ ), allocatable , dimension (:) :: xi ! Poles of the formula complex ( psb_dpk_ ), allocatable , dimension (:) :: c ! Scaling of the formula real ( psb_dpk_ ) :: eta ! Global Scaling real ( psb_dpk_ ) :: sign ! Sign for A integer ( psb_ipk_ ) :: i info = psb_success_ name = 'quadraturetest' call psb_init ( ctxt ) call psb_info ( ctxt , iam , np ) if ( iam < 0 ) then call psb_exit ( ctxt ) ! This should not happen, but just in case stop endif if ( psb_get_errstatus () /= 0 ) goto 9999 N = 10 rparams ( 1 ) = 0.01_psb_dpk_ rparams ( 2 ) = 4.0_psb_dpk_ zfun => fun quadformula => hhtmethod1 call quad % computepoles ( quadformula = quadformula ,& & zfun = zfun , N = N , info = info , rparams = rparams ) call quad % plot ( zfun , info ) call psb_exit ( ctxt ) stop 9999 call psb_error ( ctxt ) stop contains function fun ( z ) result ( res ) !! Function to integrate use psb_base_mod implicit none complex ( psb_dpk_ ), intent ( in ) :: z complex ( psb_dpk_ ) :: res res = sqrt ( 1.0 + z ) end function end program","tags":"","loc":"sourcefile/quadraturetest.f90.html"},{"title":"utiltest.f90 – PSFUN","text":"This file depends on sourcefile~~utiltest.f90~~EfferentGraph sourcefile~utiltest.f90 utiltest.f90 sourcefile~psfun_utils_mod.f90 psfun_utils_mod.f90 sourcefile~utiltest.f90->sourcefile~psfun_utils_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs utiltest Source Code utiltest.f90 Source Code ! BSD 3-Clause License ! ! Copyright (c) 2020, Fabio Durastante ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this !    list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. program utiltest !! Test of the utilities distributed with the PSFUN library in [[psfun_utils_mod]] use psb_base_mod use psfun_utils_mod implicit none ! blacs parameters type ( psb_ctxt_type ) :: ctxt integer ( psb_ipk_ ) :: iam , np ! flags integer ( psb_ipk_ ) :: info ! Variables real ( psb_dpk_ ) :: K ( 2 ), L , u , sn , cn , dn , result real ( psb_dpk_ ), parameter :: coeffs ( 7 ) = ( / 13 2.0 , 4 2.0 , 1 4.0 , 5.0 , 2.0 , 1.0 , 0.0 / ) complex ( psb_dpk_ ) :: cu , csn , ccn , cdn info = psb_success_ call psb_init ( ctxt ) call psb_info ( ctxt , iam , np ) if ( iam < 0 ) then call psb_exit ( ctxt ) ! This should not happen, but just in case stop endif if ( psb_get_errstatus () /= 0 ) goto 9999 if ( ( iam == 0 ). and .( np > 1 ) ) then write ( psb_err_unit , * ) \"This is a serial example, number of processes is \" , np goto 9999 else if ( ( iam == 0 ). and .( np == 1 )) then write ( psb_out_unit , * ) \"Welcome to the utilstest program of PSFUN\" end if ! Test of Horner rule for polynomial evaluation write ( psb_out_unit , * ) write ( psb_out_unit , '(\"Polynomial Evaluation\")' ) result = horner ( coeffs , 1.0_psb_dpk_ ) write ( psb_out_unit , '(\"p(1) = \",f17.0,\" (should be 196)\")' ) result ! Test of Elliptic Jacobi Integrals and Functions write ( psb_out_unit , * ) write ( psb_out_unit , '(\"Elliptic Integrals and Jacobi Functions\")' ) L = 0.5_psb_dpk_ K = ellipkkp ( L ) write ( psb_out_unit , '(\"L = \",f3.1,\" K = \",f17.15,\" Kp = \",f17.15)' ) L , K ( 1 ), K ( 2 ) write ( psb_out_unit , '(\"L = 0.5 K = 1.588191701877384 Kp = 2.978718299395645 (Control Values)\")' ) write ( psb_out_unit , '(\"  Jacobi Elliptic Functions\")' ) u = 1.0_psb_dpk_ L = 0.5_psb_dpk_ call ellipj ( u , L , sn , cn , dn ) write ( psb_out_unit , '(\"sn = \",f17.15,\" cn = \",f17.15,\" dn = \",f17.15)' ) sn , cn , dn write ( psb_out_unit , '(\"sn = 0.838274911024583 cn = 0.545247809300255 dn = 0.984699634947678 (Control Values)\")' ) write ( psb_out_unit , '(\"  Jacobi Elliptic Functions (Complex)\")' ) cu = cmplx ( 0.0 , 0.5_psb_dpk_ ) L = 1.0_psb_dpk_ call ellipj ( cu , L , csn , ccn , cdn ) write ( psb_out_unit , '(\"sn = (\",f3.1,\",\",f17.15,\") cn = (\",f17.15,\",\",f3.1,\") dn = (\",f17.15,\",\",f3.1,\")\")' ) csn , ccn , cdn write ( psb_out_unit , '(\"sn = (0.0,0.521141424070547) cn = (1.127647278133671,0.0) dn = (1.000253555731494,0.0) (Control Values)\")' ) call psb_exit ( ctxt ) stop 9999 call psb_error ( ctxt ) stop end program utiltest","tags":"","loc":"sourcefile/utiltest.f90.html"},{"title":"shiftedtest.f90 – PSFUN","text":"This file depends on sourcefile~~shiftedtest.f90~~EfferentGraph sourcefile~shiftedtest.f90 shiftedtest.f90 sourcefile~getp.f90 getp.f90 sourcefile~shiftedtest.f90->sourcefile~getp.f90 sourcefile~psfun_krylov_mod.f90 psfun_krylov_mod.f90 sourcefile~shiftedtest.f90->sourcefile~psfun_krylov_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs shiftedtest Source Code shiftedtest.f90 Source Code ! BSD 3-Clause License ! ! Copyright (c) 2020, Fabio Durastante ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this !    list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. program shiftedtest !! Test program for the shifted Krylov methods from [[psfun_krylov_mod]] use psb_base_mod use psb_prec_mod use psb_krylov_mod use psb_util_mod ! Module for psfun extension of Krylov solvers use psfun_krylov_mod ! Module for data input use getp implicit none ! input parameters character ( len = 40 ) :: kmethd , ptype , mtrx_file , rhs_file real ( psb_dpk_ ) :: eta , zeta ! sparse matrices type ( psb_dspmat_type ) :: a type ( psb_ldspmat_type ) :: aux_a ! preconditioner data type ( psb_dprec_type ) :: prec ! dense matrices real ( psb_dpk_ ), allocatable , target :: aux_b (:,:), d (:) real ( psb_dpk_ ), allocatable , save :: x_col_glob (:), r_col_glob (:) real ( psb_dpk_ ), pointer :: b_col_glob (:) type ( psb_d_vect_type ) :: b_col , x_col , r_col ! communications data structure type ( psb_desc_type ) :: desc_a type ( psb_ctxt_type ) :: ctxt integer ( psb_ipk_ ) :: iam , np integer ( psb_lpk_ ) :: lnp ! solver paramters integer ( psb_ipk_ ) :: iter , itmax , ierr , itrace , ircode ,& & methd , istopc , irst integer ( psb_epk_ ) :: amatsize , precsize , descsize real ( psb_dpk_ ) :: err , eps , cond character ( len = 5 ) :: afmt character ( len = 20 ) :: name , part character ( len = 2 ) :: filefmt integer ( psb_ipk_ ), parameter :: iunit = 12 integer ( psb_ipk_ ) :: iparm ( 20 ) ! other variables integer ( psb_ipk_ ) :: i , info , j , m_problem , err_act integer ( psb_ipk_ ) :: internal , m , ii , nnzero real ( psb_dpk_ ) :: t1 , t2 , tprec real ( psb_dpk_ ) :: r_amax , b_amax , scale , resmx , resmxp integer ( psb_ipk_ ) :: nrhs , nrow , n_row , dim , ne , nv integer ( psb_ipk_ ), allocatable :: ivg (:) integer ( psb_ipk_ ), allocatable :: ipv (:) character ( len = 40 ) :: fname , fnout call psb_init ( ctxt ) call psb_info ( ctxt , iam , np ) if ( iam < 0 ) then ! This should not happen, but just in case call psb_exit ( ctxt ) stop endif name = 'shiftedtest' if ( psb_errstatus_fatal ()) goto 9999 info = psb_success_ call psb_set_errverbosity ( itwo ) ! ! Hello world ! if ( iam == psb_root_ ) then write ( psb_out_unit , '(\"Welcome to the \",a,\" program of PSFUN\")' ) name end if ! !  get parameters ! call get_parms ( ctxt , mtrx_file , rhs_file , eta , zeta , filefmt , kmethd , ptype ,& & part , afmt , istopc , itmax , itrace , irst , eps ) call psb_barrier ( ctxt ) t1 = psb_wtime () ! read the input matrix to be processed and (possibly) the rhs nrhs = 1 if ( iam == psb_root_ ) then select case ( psb_toupper ( filefmt )) case ( 'MM' ) ! For Matrix Market we have an input file for the matrix ! and an (optional) second file for the RHS. call mm_mat_read ( aux_a , info , iunit = iunit , filename = mtrx_file ) if ( info == psb_success_ ) then if ( rhs_file /= 'NONE' ) then call mm_array_read ( aux_b , info , iunit = iunit , filename = rhs_file ) end if end if case ( 'HB' ) ! For Harwell-Boeing we have a single file which may or may not ! contain an RHS. call hb_read ( aux_a , info , iunit = iunit , b = aux_b , filename = mtrx_file ) case default info = - 1 write ( psb_err_unit , * ) 'Wrong choice for fileformat ' , filefmt end select if ( info /= psb_success_ ) then write ( psb_err_unit , * ) 'Error while reading input matrix ' call psb_abort ( ctxt ) end if m_problem = aux_a % get_nrows () call psb_bcast ( ctxt , m_problem ) ! At this point aux_b may still be unallocated if ( size ( aux_b , dim = 1 ) == m_problem ) then ! if any rhs were present, broadcast the first one write ( psb_err_unit , '(\"Ok, got an rhs \")' ) b_col_glob => aux_b (:, 1 ) else write ( psb_out_unit , '(\"Generating an rhs...\")' ) write ( psb_out_unit , '(\" \")' ) call psb_realloc ( m_problem , 1 , aux_b , ircode ) if ( ircode /= 0 ) then call psb_errpush ( psb_err_alloc_dealloc_ , name ) goto 9999 endif b_col_glob => aux_b (:, 1 ) do i = 1 , m_problem b_col_glob ( i ) = done enddo endif else call psb_bcast ( ctxt , m_problem ) end if ! switch over different partition types select case ( psb_toupper ( part )) case ( 'BLOCK' ) if ( iam == psb_root_ ) write ( psb_out_unit , '(\"Partition type: block\")' ) call psb_matdist ( aux_a , a , ctxt , desc_a , info , fmt = afmt , parts = part_block ) case ( 'GRAPH' ) if ( iam == psb_root_ ) then write ( psb_out_unit , '(\"Partition type: graph vector\")' ) write ( psb_out_unit , '(\" \")' ) !      write(psb_err_unit,'(\"Build type: graph\")') call aux_a % cscnv ( info , type = 'csr' ) lnp = np call build_mtpart ( aux_a , lnp ) endif call psb_barrier ( ctxt ) call distr_mtpart ( psb_root_ , ctxt ) call getv_mtpart ( ivg ) call psb_matdist ( aux_a , a , ctxt , desc_a , info , fmt = afmt , vg = ivg ) case default if ( iam == psb_root_ ) write ( psb_out_unit , '(\"Partition type: block\")' ) call psb_matdist ( aux_a , a , ctxt , desc_a , info , fmt = afmt , parts = part_block ) end select call psb_scatter ( b_col_glob , b_col , desc_a , info , root = psb_root_ ) call psb_geall ( x_col , desc_a , info ) call x_col % zero () call psb_geasb ( x_col , desc_a , info ) call psb_geall ( r_col , desc_a , info ) call r_col % zero () call psb_geasb ( r_col , desc_a , info ) t2 = psb_wtime () - t1 call psb_amx ( ctxt , t2 ) if ( iam == psb_root_ ) then write ( psb_out_unit , '(\" \")' ) write ( psb_out_unit , '(\"Time to read and partition matrix : \",es12.5)' ) t2 write ( psb_out_unit , '(\" \")' ) end if ! call prec % init ( ctxt , ptype , info ) ! building the preconditioner t1 = psb_wtime () call prec % build ( a , desc_a , info ) tprec = psb_wtime () - t1 if ( info /= psb_success_ ) then call psb_errpush ( psb_err_from_subroutine_ , name , a_err = 'psb_precbld' ) goto 9999 end if call psb_amx ( ctxt , tprec ) if ( iam == psb_root_ ) then write ( psb_out_unit , '(\"Preconditioner time: \",es12.5)' ) tprec write ( psb_out_unit , '(\" \")' ) end if cond = dzero iparm = 0 call psb_barrier ( ctxt ) t1 = psb_wtime () call psb_krylov ( kmethd , a , prec , b_col , eta , zeta , x_col , eps , desc_a , info ,& & itmax = itmax , iter = iter , err = err , itrace = itrace ,& & istop = istopc , irst = irst , cond = cond ) call psb_barrier ( ctxt ) t2 = psb_wtime () - t1 call psb_amx ( ctxt , t2 ) call psb_geaxpby ( done , b_col , dzero , r_col , desc_a , info ) call psb_spmm ( - done , a , x_col , done , r_col , desc_a , info ) resmx = psb_genrm2 ( r_col , desc_a , info ) resmxp = psb_geamax ( r_col , desc_a , info ) amatsize = a % sizeof () descsize = desc_a % sizeof () precsize = prec % sizeof () call psb_sum ( ctxt , amatsize ) call psb_sum ( ctxt , descsize ) call psb_sum ( ctxt , precsize ) if ( iam == psb_root_ ) then call prec % descr ( info ) write ( psb_out_unit , '(\"Matrix: \",a)' ) mtrx_file write ( psb_out_unit , '(\"η     : \",es12.5)' ) eta write ( psb_out_unit , '(\"ζ     : \",es12.5)' ) zeta write ( psb_out_unit , '(\"Computed solution on \",i8,\" processors\")' ) np write ( psb_out_unit , '(\"Iterations to convergence: \",i6)' ) iter write ( psb_out_unit , '(\"Error estimate on exit   : \",es12.5)' ) err write ( psb_out_unit , '(\"Time to buil prec.       : \",es12.5)' ) tprec write ( psb_out_unit , '(\"Time to solve system     : \",es12.5)' ) t2 write ( psb_out_unit , '(\"Time per iteration       : \",es12.5)' ) t2 / ( iter ) write ( psb_out_unit , '(\"Total time               : \",es12.5)' ) t2 + tprec write ( psb_out_unit , '(\"Residual norm 2          : \",es12.5)' ) resmx write ( psb_out_unit , '(\"Residual norm inf        : \",es12.5)' ) resmxp write ( psb_out_unit , '(\"Condition number         : \",es12.5)' ) cond write ( psb_out_unit , '(\"Total memory occupation for A:      \",i12)' ) amatsize write ( psb_out_unit , '(\"Total memory occupation for PREC:   \",i12)' ) precsize write ( psb_out_unit , '(\"Total memory occupation for DESC_A: \",i12)' ) descsize write ( psb_out_unit , '(\"Storage format for A              : \",a)' )& & a % get_fmt () write ( psb_out_unit , '(\"Storage format for DESC_A         : \",a)' )& & desc_a % get_fmt () end if call psb_gather ( x_col_glob , x_col , desc_a , info , root = psb_root_ ) if ( info == psb_success_ ) & & call psb_gather ( r_col_glob , r_col , desc_a , info , root = psb_root_ ) if ( info /= psb_success_ ) goto 9999 if ( iam == psb_root_ ) then ! The test writes the solution on file if and only if the code is running ! on one process call mm_dvect_write ( x_col , 'solution' , info , filename = 'x_' // trim ( mtrx_file )); end if 998 format ( i8 , 4 ( 2 x , g20 . 14 )) 993 format ( i6 , 4 ( 1 x , e12 . 6 )) call psb_gefree ( b_col , desc_a , info ) call psb_gefree ( x_col , desc_a , info ) call psb_spfree ( a , desc_a , info ) call prec % free ( info ) call psb_cdfree ( desc_a , info ) call psb_exit ( ctxt ) stop 9999 call psb_error ( ctxt ) stop end program shiftedtest","tags":"","loc":"sourcefile/shiftedtest.f90.html"},{"title":"getp.f90 – PSFUN","text":"Files dependent on this one sourcefile~~getp.f90~~AfferentGraph sourcefile~getp.f90 getp.f90 sourcefile~shiftedtest.f90 shiftedtest.f90 sourcefile~shiftedtest.f90->sourcefile~getp.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules getp Source Code getp.f90 Source Code ! BSD 3-Clause License ! ! Copyright (c) 2020, Fabio Durastante ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this !    list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! This file is based on the getp file from: ! !                Parallel Sparse BLAS  version 3.5 !      (C) Copyright 2006-2018 !        Salvatore Filippone !        Alfredo Buttari ! !    Redistribution and use in source and binary forms, with or without !    modification, are permitted provided that the following conditions !    are met: !      1. Redistributions of source code must retain the above copyright !         notice, this list of conditions and the following disclaimer. !      2. Redistributions in binary form must reproduce the above copyright !         notice, this list of conditions, and the following disclaimer in the !         documentation and/or other materials provided with the distribution. !      3. The name of the PSBLAS group or the names of its contributors may !         not be used to endorse or promote products derived from this !         software without specific written permission. ! !    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS !    ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED !    TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR !    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE PSBLAS GROUP OR ITS CONTRIBUTORS !    BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR !    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF !    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS !    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN !    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) !    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE !    POSSIBILITY OF SUCH DAMAGE. ! ! Module getp !! This moodule contaings the subroutine to read parameters needed to run the !! shiftedkrylov program from standard input interface get_parms !! Get iteration parameters from the command line module procedure get_dparms end interface contains subroutine get_dparms ( ctxt , mtrx_file , rhs_file , eta , zeta , filefmt , kmethd , ptype , part ,& & afmt , istopc , itmax , itrace , irst , eps ) !! Get iteration parameters from the command line use psb_base_mod type ( psb_ctxt_type ) :: ctxt !! Parallel context character ( len = 2 ) :: filefmt !! Format of the file character ( len = 40 ) :: kmethd , mtrx_file , rhs_file , ptype character ( len = 20 ) :: part integer ( psb_ipk_ ) :: iret , istopc , itmax , itrace , irst character ( len = 40 ) :: charbuf real ( psb_dpk_ ) :: eta , zeta , eps character :: afmt * 5 integer ( psb_ipk_ ) :: np , iam integer ( psb_ipk_ ) :: inparms ( 40 ), ip , inp_unit character ( len = 1024 ) :: filename call psb_info ( ctxt , iam , np ) if ( iam == 0 ) then if ( command_argument_count () > 0 ) then call get_command_argument ( 1 , filename ) inp_unit = 30 open ( inp_unit , file = filename , action = 'read' , iostat = info ) if ( info /= 0 ) then write ( psb_err_unit , * ) 'Could not open file ' , filename , ' for input' call psb_abort ( ctxt ) stop else write ( psb_err_unit , * ) 'Opened file ' , trim ( filename ), ' for input' end if else inp_unit = psb_inp_unit end if ! Read Input Parameters read ( inp_unit , * ) ip if ( ip >= 9 ) then read ( inp_unit , * ) mtrx_file read ( inp_unit , * ) rhs_file read ( inp_unit , * ) eta read ( inp_unit , * ) zeta read ( inp_unit , * ) filefmt read ( inp_unit , * ) kmethd read ( inp_unit , * ) ptype read ( inp_unit , * ) afmt read ( inp_unit , * ) part call psb_bcast ( ctxt , mtrx_file ) call psb_bcast ( ctxt , rhs_file ) call psb_bcast ( ctxt , eta ) call psb_bcast ( ctxt , zeta ) call psb_bcast ( ctxt , filefmt ) call psb_bcast ( ctxt , kmethd ) call psb_bcast ( ctxt , ptype ) call psb_bcast ( ctxt , afmt ) call psb_bcast ( ctxt , part ) if ( ip >= 10 ) then read ( inp_unit , * ) istopc else istopc = 1 endif if ( ip >= 11 ) then read ( inp_unit , * ) itmax else itmax = 500 endif if ( ip >= 12 ) then read ( inp_unit , * ) itrace else itrace =- 1 endif if ( ip >= 13 ) then read ( inp_unit , * ) irst else irst = 1 endif if ( ip >= 14 ) then read ( inp_unit , * ) eps else eps = 1.d-6 endif inparms ( 1 ) = istopc inparms ( 2 ) = itmax inparms ( 3 ) = itrace inparms ( 4 ) = irst call psb_bcast ( ctxt , inparms ( 1 : 4 )) call psb_bcast ( ctxt , eps ) write ( psb_out_unit , '(\"Solving matrix       : \",a)' ) mtrx_file write ( psb_out_unit , '(\"Number of processors : \",i3)' ) np write ( psb_out_unit , '(\"Data distribution    : \",a)' ) part write ( psb_out_unit , '(\"Iterative method     : \",a)' ) kmethd write ( psb_out_unit , '(\"Preconditioner       : \",a)' ) ptype write ( psb_out_unit , '(\"Restart parameter    : \",i2)' ) irst write ( psb_out_unit , '(\"Storage format       : \",a)' ) afmt ( 1 : 3 ) write ( psb_out_unit , '(\" \")' ) else write ( psb_err_unit , * ) 'Wrong format for input file' call psb_abort ( ctxt ) stop 1 end if if ( inp_unit /= psb_inp_unit ) then close ( inp_unit ) end if else ! Receive Parameters call psb_bcast ( ctxt , mtrx_file ) call psb_bcast ( ctxt , rhs_file ) call psb_bcast ( ctxt , eta ) call psb_bcast ( ctxt , zeta ) call psb_bcast ( ctxt , filefmt ) call psb_bcast ( ctxt , kmethd ) call psb_bcast ( ctxt , ptype ) call psb_bcast ( ctxt , afmt ) call psb_bcast ( ctxt , part ) call psb_bcast ( ctxt , inparms ( 1 : 4 )) istopc = inparms ( 1 ) itmax = inparms ( 2 ) itrace = inparms ( 3 ) irst = inparms ( 4 ) call psb_bcast ( ctxt , eps ) end if end subroutine get_dparms end module getp","tags":"","loc":"sourcefile/getp.f90.html"},{"title":"arnolditest.F90 – PSFUN","text":"This file depends on sourcefile~~arnolditest.f90~~EfferentGraph sourcefile~arnolditest.f90 arnolditest.F90 sourcefile~psfun_d_serial_mod.f90 psfun_d_serial_mod.F90 sourcefile~arnolditest.f90->sourcefile~psfun_d_serial_mod.f90 sourcefile~psfun_d_krylov_mod.f90 psfun_d_krylov_mod.F90 sourcefile~arnolditest.f90->sourcefile~psfun_d_krylov_mod.f90 sourcefile~psfun_d_krylov_mod.f90->sourcefile~psfun_d_serial_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs arnolditest Source Code arnolditest.F90 Source Code ! BSD 3-Clause License ! ! Copyright (c) 2020, Fabio Durastante ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this !    list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. program arnolditest !! Test for the parallel computation of matrix function by means of the !! [[psfun_d_arnoldi]] function. !! It applies the classical Arnoldi orthogonalization !! algorithm on a distributed matrix. use psb_base_mod use psb_util_mod use psfun_d_serial_mod use psfun_d_krylov_mod implicit none ! File input character ( len = 20 ) :: mname , fname , filefmt , rhs_file , part , afmt , variant real ( psb_dpk_ ) :: scaling ! communications data structure type ( psb_desc_type ) :: desc_a ! sparse matrices type ( psb_dspmat_type ) :: a type ( psb_ldspmat_type ) :: aux_a ! dense matrix real ( psb_dpk_ ), allocatable , target :: aux_x (:,:) real ( psb_dpk_ ), pointer :: x_col_glob (:) type ( psb_d_vect_type ) :: x_col , y_col ! Matrix function method type ( psfun_d_serial ) :: fun type ( psfun_d_krylov ) :: kmethd real ( psb_dpk_ ) :: eps , err integer ( psb_ipk_ ) :: itmax , itrace , istop , iter ! blacs parameters type ( psb_ctxt_type ) :: ctxt integer ( psb_ipk_ ) :: iam , np integer ( psb_lpk_ ) :: lnp ! working variables integer ( psb_ipk_ ) :: m_problem , i integer ( psb_ipk_ ), allocatable :: ivg (:), perm (:) integer ( psb_ipk_ ), allocatable :: ipv (:) ! auxiliary parameters integer ( psb_ipk_ ) :: info , ircode integer ( psb_ipk_ ), parameter :: iunit = 12 character ( len = 20 ) :: name real ( psb_dpk_ ) :: t1 , t2 integer ( psb_epk_ ) :: amatsize , descsize , system_size real ( psb_dpk_ ), allocatable :: res (:) ! real(psb_dpk_), allocatable  :: vy(:) info = psb_success_ name = 'arnolditest' call psb_init ( ctxt ) call psb_info ( ctxt , iam , np ) if ( iam < 0 ) then call psb_exit ( ctxt ) ! This should not happen, but just in case stop endif if ( psb_get_errstatus () /= 0 ) goto 9999 ! ! Hello world ! if ( iam == psb_root_ ) then write ( psb_out_unit , '(\"Welcome to the \",a,\" program of PSFUN\")' ) name end if ! ! Read input information from file ! call get_parms ( ctxt , mname , rhs_file , filefmt , part , afmt , fname ,& & variant , scaling , eps , itmax , itrace , istop ) if ( iam == psb_root_ ) then write ( psb_out_unit , * ) '' write ( psb_out_unit , '(\"Solving matrix        : \",a)' ) mname write ( psb_out_unit , '(\"RHS vector            : \",a)' ) rhs_file write ( psb_out_unit , '(\"File format           : \",a)' ) filefmt write ( psb_out_unit , '(\"Partitioning strategy : \",a)' ) part write ( psb_out_unit , '(\"Storage strategy      : \",a)' ) afmt write ( psb_out_unit , '(\"Function to compute   : \",a)' ) fname write ( psb_out_unit , '(\"Algorithmic variant   : \",a)' ) variant write ( psb_out_unit , '(\"Scaling               : \",f8.2)' ) scaling end if call psb_barrier ( ctxt ) if ( iam == psb_root_ ) then select case ( psb_toupper ( filefmt )) case ( 'MM' ) ! For Matrix Market we have an input file for the matrix ! and an (optional) second file for the RHS. call mm_mat_read ( aux_a , info , iunit = iunit , filename = mname ) if ( info == psb_success_ ) then if ( rhs_file /= 'NONE' ) then call mm_array_read ( aux_x , info , iunit = iunit , filename = rhs_file ) end if end if case ( 'HB' ) ! For Harwell-Boeing we have a single file which may or may not ! contain an RHS. call hb_read ( aux_a , info , iunit = iunit , b = aux_x , filename = mname ) case default info = - 1 write ( psb_err_unit , * ) 'Wrong choice for fileformat ' , filefmt end select if ( info /= psb_success_ ) then write ( psb_err_unit , * ) 'Error while reading input matrix ' call psb_abort ( ctxt ) end if m_problem = aux_a % get_nrows () call psb_bcast ( ctxt , m_problem ) ! At this point aux_x may still be unallocated if ( size ( aux_x , dim = 1 ) == m_problem ) then ! if any rhs were present, broadcast the first one write ( psb_err_unit , '(\"Ok, got an rhs \")' ) x_col_glob => aux_x (:, 1 ) call psb_gelp ( 'N' , perm ( 1 : m_problem ),& & x_col_glob ( 1 : m_problem ), info ) else write ( psb_out_unit , '(\"Generating an rhs...\")' ) write ( psb_out_unit , '(\" \")' ) call psb_realloc ( m_problem , 1 , aux_x , ircode ) if ( ircode /= 0 ) then call psb_errpush ( psb_err_alloc_dealloc_ , name ) goto 9999 endif x_col_glob => aux_x (:, 1 ) do i = 1 , m_problem x_col_glob ( i ) = done enddo endif else call psb_bcast ( ctxt , m_problem ) end if ! switch over different partition types select case ( psb_toupper ( part )) case ( 'BLOCK' ) if ( iam == psb_root_ ) write ( psb_out_unit , '(\"Partition type: block\")' ) call psb_matdist ( aux_a , a , ctxt , desc_a , info , fmt = afmt , parts = part_block ) case ( 'GRAPH' ) if ( iam == psb_root_ ) then write ( psb_out_unit , '(\"Partition type: graph vector\")' ) write ( psb_out_unit , '(\" \")' ) !      write(psb_err_unit,'(\"Build type: graph\")') call aux_a % cscnv ( info , type = 'csr' ) lnp = np call build_mtpart ( aux_a , lnp ) endif call psb_barrier ( ctxt ) call distr_mtpart ( psb_root_ , ctxt ) call getv_mtpart ( ivg ) call psb_matdist ( aux_a , a , ctxt , desc_a , info , fmt = afmt , vg = ivg ) case default if ( iam == psb_root_ ) write ( psb_out_unit , '(\"Partition type: block\")' ) call psb_matdist ( aux_a , a , ctxt , desc_a , info , fmt = afmt , parts = part_block ) end select call psb_scatter ( x_col_glob , x_col , desc_a , info , root = psb_root_ ) call psb_geall ( y_col , desc_a , info ) call y_col % zero () call psb_geasb ( y_col , desc_a , info ) t2 = psb_wtime () - t1 call psb_amx ( ctxt , t2 ) if ( iam == psb_root_ ) then write ( psb_out_unit , '(\" \")' ) write ( psb_out_unit , '(\"Time to read and partition matrix : \",es12.5)' ) t2 write ( psb_out_unit , '(\" \")' ) end if call psb_barrier ( ctxt ) ! Set the options for the matrix function call fun % set ( \"FNAME\" , fname , info ) call fun % set ( \"VARIANT\" , variant , info ) call fun % set ( \"SCALING\" , scaling , info ) ! Set the options for the Krylov method call kmethd % set ( \"KNAME\" , \"ARNOLDI\" , info ) ! Doing the matrix function computation eps = 1e-6 itmax = 100 itrace = 1 istop = 1 t1 = psb_wtime () call kmethd % apply ( fun , a , desc_a , y_col , x_col , eps , info , itmax , itrace , istop , iter , err , res ) t2 = psb_wtime () - t1 amatsize = a % sizeof () descsize = desc_a % sizeof () system_size = desc_a % get_global_rows () call psb_sum ( ctxt , amatsize ) call psb_sum ( ctxt , descsize ) call psb_barrier ( ctxt ) if ( iam == psb_root_ ) then write ( psb_out_unit , '(\" \")' ) write ( psb_out_unit , '(\"Number of processes           : \",i12)' ) np write ( psb_out_unit , '(\"Matrix size                   : \",i12)' ) system_size write ( psb_out_unit , '(\"Time to solve system          : \",es12.5)' ) t2 write ( psb_out_unit , '(\"Time per iteration            : \",es12.5)' ) t2 / iter write ( psb_out_unit , '(\"Number of iterations          : \",i12)' ) iter write ( psb_out_unit , '(\"Convergence indicator on exit : \",es12.5)' ) err write ( psb_out_unit , '(\"Info  on exit                 : \",i12)' ) info write ( psb_out_unit , '(\"Total memory occupation for      A: \",i12)' ) amatsize write ( psb_out_unit , '(\"Total memory occupation for DESC_A: \",i12)' ) descsize write ( psb_out_unit , '(\"Storage format for               A: \",a)' ) a % get_fmt () write ( psb_out_unit , '(\"Storage format for          DESC_A: \",a)' ) desc_a % get_fmt () end if #if defined (WITHGNUPLOTFORTRAN) if ( iam == psb_root_ ) & & call kmethd % plot ( fun , iter , res , info ) #endif ! Free the memory call psb_gefree ( x_col , desc_a , info ) call psb_gefree ( y_col , desc_a , info ) call psb_spfree ( a , desc_a , info ) call psb_cdfree ( desc_a , info ) call psb_exit ( ctxt ) stop 9999 call psb_error ( ctxt ) stop contains subroutine get_parms ( ctxt , mname , rhs_file , filefmt , part , afmt , fname , variant , scaling , eps , itmax , itrace , istop ) !! This subroutine reads the parameters needed to run the arnolditest !! program from standard input type ( psb_ctxt_type ), intent ( in ) :: ctxt character ( len =* ), intent ( out ) :: mname , rhs_file , fname , variant , filefmt , part , afmt real ( psb_dpk_ ), intent ( out ) :: scaling , eps integer ( psb_ipk_ ), intent ( out ) :: itmax , itrace , istop integer ( psb_ipk_ ) :: ip , inp_unit integer ( psb_ipk_ ) :: np , iam character ( len = 1024 ) :: filename call psb_info ( ctxt , iam , np ) if ( iam == psb_root_ ) then if ( command_argument_count () > 0 ) then call get_command_argument ( 1 , filename ) inp_unit = 30 open ( inp_unit , file = filename , action = 'read' , iostat = info ) if ( info /= 0 ) then write ( psb_err_unit , * ) 'Could not open file ' , filename , ' for input' call psb_abort ( ctxt ) stop else write ( psb_err_unit , * ) 'Opened file ' , trim ( filename ), ' for input' end if else inp_unit = psb_inp_unit end if read ( inp_unit , * ) ip if ( ip == 8 ) then read ( inp_unit , * ) mname read ( inp_unit , * ) rhs_file read ( inp_unit , * ) filefmt read ( inp_unit , * ) part read ( inp_unit , * ) afmt read ( inp_unit , * ) fname read ( inp_unit , * ) variant read ( inp_unit , * ) scaling eps = 1e-6 itmax = 100 itrace = 1 istop = 1 else if ( ip == 12 ) then read ( inp_unit , * ) mname read ( inp_unit , * ) rhs_file read ( inp_unit , * ) filefmt read ( inp_unit , * ) part read ( inp_unit , * ) afmt read ( inp_unit , * ) fname read ( inp_unit , * ) variant read ( inp_unit , * ) scaling read ( inp_unit , * ) eps read ( inp_unit , * ) itmax read ( inp_unit , * ) itrace read ( inp_unit , * ) istop else ! wrong number of parameters on input: all hopes are lost call pr_usage ( izero ) call psb_abort ( ctxt ) stop 1 end if if ( inp_unit /= psb_inp_unit ) then close ( inp_unit ) end if end if ! Broadcast values to all processes call psb_bcast ( ctxt , mname ) call psb_bcast ( ctxt , rhs_file ) call psb_bcast ( ctxt , filefmt ) call psb_bcast ( ctxt , part ) call psb_bcast ( ctxt , afmt ) call psb_bcast ( ctxt , fname ) call psb_bcast ( ctxt , variant ) call psb_bcast ( ctxt , scaling ) call psb_bcast ( ctxt , eps ) call psb_bcast ( ctxt , itmax ) call psb_bcast ( ctxt , itrace ) call psb_bcast ( ctxt , istop ) return end subroutine get_parms subroutine pr_usage ( iout ) !! Prints out information on incorrected program usage integer ( psb_ipk_ ) :: iout write ( iout , * ) 'incorrect parameter(s) found' write ( iout , * ) ' usage:  serialtest mname filefmt fname variant & & scaling dump' write ( iout , * ) ' where:' write ( iout , * ) '     mname:    Filename of the matrix' write ( iout , * ) '     filefmt:  Format of the matrix (MM,HB)' write ( iout , * ) '     part:     Partitioning strategy (GRAPH,BLOCK)' write ( iout , * ) '     afmt:     Storage format of the matrix (CSR,COO)' write ( iout , * ) '     fname :   Matrix function name' write ( iout , * ) '     variant : Variant of the algorithm for the fname function' write ( iout , * ) '     scaling : Scalar scaling parameter ' end subroutine pr_usage end program arnolditest","tags":"","loc":"sourcefile/arnolditest.f90.html"},{"title":"lanczostest.F90 – PSFUN","text":"This file depends on sourcefile~~lanczostest.f90~~EfferentGraph sourcefile~lanczostest.f90 lanczostest.F90 sourcefile~psfun_d_serial_mod.f90 psfun_d_serial_mod.F90 sourcefile~lanczostest.f90->sourcefile~psfun_d_serial_mod.f90 sourcefile~psfun_d_krylov_mod.f90 psfun_d_krylov_mod.F90 sourcefile~lanczostest.f90->sourcefile~psfun_d_krylov_mod.f90 sourcefile~psfun_d_krylov_mod.f90->sourcefile~psfun_d_serial_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs lanczostest Source Code lanczostest.F90 Source Code ! BSD 3-Clause License ! ! Copyright (c) 2020, Fabio Durastante ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this !    list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. program lanczostest !! Test for the parallel computation of matrix function by means of the !! [[psfun_d_lanczos]] function. !! It applies the classical Lanczos orthogonalization !! algorithm on a distributed matrix. use psb_base_mod use psfun_d_serial_mod use psfun_d_krylov_mod use psb_util_mod implicit none ! File input character ( len = 20 ) :: mname , fname , filefmt , rhs_file , part , afmt , variant real ( psb_dpk_ ) :: scaling ! communications data structure type ( psb_desc_type ) :: desc_a ! sparse matrices type ( psb_dspmat_type ) :: a type ( psb_ldspmat_type ) :: aux_a ! dense matrix real ( psb_dpk_ ), allocatable , target :: aux_x (:,:) real ( psb_dpk_ ), pointer :: x_col_glob (:) type ( psb_d_vect_type ) :: x_col , y_col ! Matrix function method type ( psfun_d_serial ) :: fun type ( psfun_d_krylov ) :: kmethd real ( psb_dpk_ ) :: eps , err integer ( psb_ipk_ ) :: itmax , itrace , istop , iter ! blacs parameters type ( psb_ctxt_type ) :: ctxt integer ( psb_ipk_ ) :: iam , np integer ( psb_lpk_ ) :: lnp ! working variables integer ( psb_ipk_ ) :: m_problem , i integer ( psb_ipk_ ), allocatable :: ivg (:), perm (:) integer ( psb_ipk_ ), allocatable :: ipv (:) ! auxiliary parameters integer ( psb_ipk_ ) :: info , ircode integer ( psb_ipk_ ), parameter :: iunit = 12 character ( len = 20 ) :: name real ( psb_dpk_ ) :: t1 , t2 integer ( psb_epk_ ) :: amatsize , descsize , system_size real ( psb_dpk_ ), allocatable :: res (:) ! real(psb_dpk_), allocatable  :: vy(:) info = psb_success_ name = 'lanczostest' call psb_init ( ctxt ) call psb_info ( ctxt , iam , np ) if ( iam < 0 ) then call psb_exit ( ctxt ) ! This should not happen, but just in case stop endif if ( psb_get_errstatus () /= 0 ) goto 9999 ! ! Hello world ! if ( ( iam == psb_root_ ) ) then write ( psb_out_unit , * ) \"Welcome to the lanczostest program of PSFUN\" end if ! ! Read input information from file ! call get_parms ( ctxt , mname , rhs_file , filefmt , part , afmt , fname , variant , scaling , eps , itmax , itrace , istop ) if ( iam == psb_root_ ) then write ( psb_out_unit , * ) '' write ( psb_out_unit , '(\"Solving matrix        : \",a)' ) mname write ( psb_out_unit , '(\"RHS vector            : \",a)' ) rhs_file write ( psb_out_unit , '(\"File format           : \",a)' ) filefmt write ( psb_out_unit , '(\"Partitioning strategy : \",a)' ) part write ( psb_out_unit , '(\"Storage strategy      : \",a)' ) afmt write ( psb_out_unit , '(\"Function to compute   : \",a)' ) fname write ( psb_out_unit , '(\"Algorithmic variant   : \",a)' ) variant write ( psb_out_unit , '(\"Scaling               : \",f8.2)' ) scaling end if if ( iam == psb_root_ ) then select case ( psb_toupper ( filefmt )) case ( 'MM' ) ! For Matrix Market we have an input file for the matrix ! and an (optional) second file for the RHS. call mm_mat_read ( aux_a , info , iunit = iunit , filename = mname ) if ( info == psb_success_ ) then if ( rhs_file /= 'NONE' ) then call mm_array_read ( aux_x , info , iunit = iunit , filename = rhs_file ) end if end if case ( 'HB' ) ! For Harwell-Boeing we have a single file which may or may not ! contain an RHS. call hb_read ( aux_a , info , iunit = iunit , b = aux_x , filename = mname ) case default info = - 1 write ( psb_err_unit , * ) 'Wrong choice for fileformat ' , filefmt end select if ( info /= psb_success_ ) then write ( psb_err_unit , * ) 'Error while reading input matrix ' call psb_abort ( ctxt ) end if m_problem = aux_a % get_nrows () call psb_bcast ( ctxt , m_problem ) ! At this point aux_x may still be unallocated if ( size ( aux_x , dim = 1 ) == m_problem ) then ! if any rhs were present, broadcast the first one write ( psb_err_unit , '(\"Ok, got an rhs \")' ) x_col_glob => aux_x (:, 1 ) call psb_gelp ( 'N' , perm ( 1 : m_problem ),& & x_col_glob ( 1 : m_problem ), info ) else write ( psb_out_unit , '(\"Generating an rhs...\")' ) write ( psb_out_unit , '(\" \")' ) call psb_realloc ( m_problem , 1 , aux_x , ircode ) if ( ircode /= 0 ) then call psb_errpush ( psb_err_alloc_dealloc_ , name ) goto 9999 endif x_col_glob => aux_x (:, 1 ) do i = 1 , m_problem x_col_glob ( i ) = done enddo endif else call psb_bcast ( ctxt , m_problem ) end if ! switch over different partition types select case ( psb_toupper ( part )) case ( 'BLOCK' ) if ( iam == psb_root_ ) write ( psb_out_unit , '(\"Partition type: block\")' ) call psb_matdist ( aux_a , a , ctxt , desc_a , info , fmt = afmt , parts = part_block ) case ( 'GRAPH' ) if ( iam == psb_root_ ) then write ( psb_out_unit , '(\"Partition type: graph vector\")' ) write ( psb_out_unit , '(\" \")' ) !      write(psb_err_unit,'(\"Build type: graph\")') call aux_a % cscnv ( info , type = 'csr' ) lnp = np call build_mtpart ( aux_a , lnp ) endif call psb_barrier ( ctxt ) call distr_mtpart ( psb_root_ , ctxt ) call getv_mtpart ( ivg ) call psb_matdist ( aux_a , a , ctxt , desc_a , info , fmt = afmt , vg = ivg ) case default if ( iam == psb_root_ ) write ( psb_out_unit , '(\"Partition type: block\")' ) call psb_matdist ( aux_a , a , ctxt , desc_a , info , fmt = afmt , parts = part_block ) end select call psb_scatter ( x_col_glob , x_col , desc_a , info , root = psb_root_ ) call psb_geall ( y_col , desc_a , info ) call y_col % zero () call psb_geasb ( y_col , desc_a , info ) t2 = psb_wtime () - t1 call psb_amx ( ctxt , t2 ) if ( iam == psb_root_ ) then write ( psb_out_unit , '(\" \")' ) write ( psb_out_unit , '(\"Time to read and partition matrix : \",es12.5)' ) t2 write ( psb_out_unit , '(\" \")' ) end if ! Set the options for the matrix function call fun % set ( \"FNAME\" , fname , info ) call fun % set ( \"VARIANT\" , variant , info ) call fun % set ( \"SCALING\" , scaling , info ) ! Set the options for the Krylov method call kmethd % set ( \"KNAME\" , \"LANCZOS\" , info ) ! Doing the matrix function computation eps = 1e-6 itmax = 100 itrace = 1 istop = 1 t1 = psb_wtime () call kmethd % apply ( fun , a , desc_a , y_col , x_col , eps , info , itmax , itrace , istop , iter , err , res ) t2 = psb_wtime () - t1 amatsize = a % sizeof () descsize = desc_a % sizeof () system_size = desc_a % get_global_rows () call psb_sum ( ctxt , amatsize ) call psb_sum ( ctxt , descsize ) if ( iam == psb_root_ ) then write ( psb_out_unit , '(\" \")' ) write ( psb_out_unit , '(\"Number of processes           : \",i12)' ) np write ( psb_out_unit , '(\"Matrix size                   : \",i12)' ) system_size write ( psb_out_unit , '(\"Time to solve system          : \",es12.5)' ) t2 write ( psb_out_unit , '(\"Time per iteration            : \",es12.5)' ) t2 / iter write ( psb_out_unit , '(\"Number of iterations          : \",i12)' ) iter write ( psb_out_unit , '(\"Convergence indicator on exit : \",es12.5)' ) err write ( psb_out_unit , '(\"Info  on exit                 : \",i12)' ) info write ( psb_out_unit , '(\"Total memory occupation for      A: \",i12)' ) amatsize write ( psb_out_unit , '(\"Total memory occupation for DESC_A: \",i12)' ) descsize write ( psb_out_unit , '(\"Storage format for               A: \",a)' ) a % get_fmt () write ( psb_out_unit , '(\"Storage format for          DESC_A: \",a)' ) desc_a % get_fmt () end if #if defined (WITHGNUPLOTFORTRAN) if ( iam == psb_root_ ) & & call kmethd % plot ( fun , iter , res , info ) #endif ! Free the memory call psb_gefree ( x_col , desc_a , info ) call psb_gefree ( y_col , desc_a , info ) call psb_spfree ( a , desc_a , info ) call psb_cdfree ( desc_a , info ) call psb_exit ( ctxt ) stop 9999 call psb_error ( ctxt ) stop contains subroutine get_parms ( ctxt , mname , rhs_file , filefmt , part , afmt , fname , variant , scaling , eps , itmax , itrace , istop ) !! This subroutine reads the parameters needed to run the lanczostest !! program from standard input type ( psb_ctxt_type ), intent ( in ) :: ctxt character ( len =* ), intent ( out ) :: mname , rhs_file , fname , variant , filefmt , part , afmt real ( psb_dpk_ ), intent ( out ) :: scaling , eps integer ( psb_ipk_ ), intent ( out ) :: itmax , itrace , istop integer ( psb_ipk_ ) :: ip , inp_unit integer ( psb_ipk_ ) :: np , iam character ( len = 1024 ) :: filename call psb_info ( ctxt , iam , np ) if ( iam == psb_root_ ) then if ( command_argument_count () > 0 ) then call get_command_argument ( 1 , filename ) inp_unit = 30 open ( inp_unit , file = filename , action = 'read' , iostat = info ) if ( info /= 0 ) then write ( psb_err_unit , * ) 'Could not open file ' , filename , ' for input' call psb_abort ( ctxt ) stop else write ( psb_err_unit , * ) 'Opened file ' , trim ( filename ), ' for input' end if else inp_unit = psb_inp_unit end if read ( inp_unit , * ) ip if ( ip == 8 ) then read ( inp_unit , * ) mname read ( inp_unit , * ) rhs_file read ( inp_unit , * ) filefmt read ( inp_unit , * ) part read ( inp_unit , * ) afmt read ( inp_unit , * ) fname read ( inp_unit , * ) variant read ( inp_unit , * ) scaling eps = 1e-6 itmax = 100 itrace = 1 istop = 1 else if ( ip == 12 ) then read ( inp_unit , * ) mname read ( inp_unit , * ) rhs_file read ( inp_unit , * ) filefmt read ( inp_unit , * ) part read ( inp_unit , * ) afmt read ( inp_unit , * ) fname read ( inp_unit , * ) variant read ( inp_unit , * ) scaling read ( inp_unit , * ) eps read ( inp_unit , * ) itmax read ( inp_unit , * ) itrace read ( inp_unit , * ) istop else ! wrong number of parameters on input: all hopes are lost call pr_usage ( izero ) call psb_abort ( ctxt ) stop 1 end if if ( inp_unit /= psb_inp_unit ) then close ( inp_unit ) end if end if ! Broadcast values to all processes call psb_bcast ( ctxt , mname ) call psb_bcast ( ctxt , rhs_file ) call psb_bcast ( ctxt , filefmt ) call psb_bcast ( ctxt , part ) call psb_bcast ( ctxt , afmt ) call psb_bcast ( ctxt , fname ) call psb_bcast ( ctxt , variant ) call psb_bcast ( ctxt , scaling ) call psb_bcast ( ctxt , eps ) call psb_bcast ( ctxt , itmax ) call psb_bcast ( ctxt , itrace ) call psb_bcast ( ctxt , istop ) return end subroutine get_parms subroutine pr_usage ( iout ) !! Prints out information on incorrected program usage integer ( psb_ipk_ ) :: iout write ( iout , * ) 'incorrect parameter(s) found' write ( iout , * ) ' usage:  serialtest mname filefmt fname variant & & scaling dump' write ( iout , * ) ' where:' write ( iout , * ) '     mname:    Filename of the matrix' write ( iout , * ) '     filefmt:  Format of the matrix (MM,HB)' write ( iout , * ) '     part:     Partitioning strategy (GRAPH,BLOCK)' write ( iout , * ) '     afmt:     Storage format of the matrix (CSR,COO)' write ( iout , * ) '     fname :   Matrix function name' write ( iout , * ) '     variant : Variant of the algorithm for the fname function' write ( iout , * ) '     scaling : Scalar scaling parameter ' end subroutine pr_usage end program lanczostest","tags":"","loc":"sourcefile/lanczostest.f90.html"},{"title":"serialtest.f90 – PSFUN","text":"This file depends on sourcefile~~serialtest.f90~~EfferentGraph sourcefile~serialtest.f90 serialtest.f90 sourcefile~psfun_d_serial_mod.f90 psfun_d_serial_mod.F90 sourcefile~serialtest.f90->sourcefile~psfun_d_serial_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs serialtest Source Code serialtest.f90 Source Code ! BSD 3-Clause License ! ! Copyright (c) 2020, Fabio Durastante ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this !    list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. program serialtest !! Test program for the serial part of the library. !! This test program loads a !! matrix from file together with some options to test the serial computation !! of the matrix functions. Substantially, it test the interfacing with the !! library doing the serial part. use psb_base_mod use psfun_d_serial_mod use psb_util_mod , only : mm_mat_read , mm_array_write implicit none ! File input character ( len = 20 ) :: mname , fname , variant real ( psb_dpk_ ) :: scaling logical :: dump ! blacs parameters type ( psb_ctxt_type ) :: ctxt integer ( psb_ipk_ ) :: iam , np ! Matrices and vectors type ( psb_dspmat_type ) :: a ! Needed for reading from sparse matrix real ( psb_dpk_ ), allocatable :: x (:), y (:) integer ( psb_ipk_ ) :: n , nnz ! Matrix function method type ( psfun_d_serial ) :: fun ! auxiliary parameters integer ( psb_ipk_ ) :: info integer ( psb_ipk_ ), parameter :: iunit = 12 real ( psb_dpk_ ) :: t1 , t2 info = psb_success_ call psb_init ( ctxt ) call psb_info ( ctxt , iam , np ) if ( iam < 0 ) then call psb_exit ( ctxt ) ! This should not happen, but just in case stop endif if ( psb_get_errstatus () /= 0 ) goto 9999 if ( ( iam == 0 ). and .( np > 1 ) ) then write ( psb_err_unit , * ) \"This is a serial example, number of processes is \" , np goto 9999 else if ( ( iam == 0 ). and .( np == 1 )) then write ( psb_out_unit , * ) \"Welcome to the serialtest program of PSFUN\" end if ! Read input information from file call get_parms ( ctxt , mname , fname , variant , scaling , dump ) write ( psb_out_unit , * ) '' write ( psb_out_unit , '(\"Solving matrix       : \",a)' ) mname write ( psb_out_unit , '(\"Function to compute  : \",a)' ) fname write ( psb_out_unit , '(\"Algorithmic variant  : \",a)' ) variant write ( psb_out_unit , '(\"Scaling              : \",f8.2)' ) scaling ! Read matrix from file call mm_mat_read ( a , info , iunit = iunit , filename = mname ) n = a % get_nrows () nnz = a % get_nzeros () write ( psb_out_unit , '(\"Matrix of size matrix \",i6,\"x\",i6,\" nnz =\",i6)' ) n , n , nnz ! Set the options call fun % set ( \"FNAME\" , fname , info ) call fun % set ( \"VARIANT\" , variant , info ) call fun % set ( \"SCALING\" , scaling , info ) ! Allocate vectors for size allocate ( x ( n ), stat = info ) if ( info /= 0 ) write ( psb_err_unit , * ) \"x(n): Allocation request denied\" allocate ( y ( n ), stat = info ) if ( info /= 0 ) write ( psb_err_unit , * ) \"y(n): Allocation request denied\" ! Compute the matrix function on the all one vector x ( 1 : n ) = 1_psb_dpk_ t1 = psb_wtime () call fun % apply ( a , y , x , info ) t2 = psb_wtime () write ( psb_out_unit , '(\"Elapsed time: \",es12.5)' ) t2 - t1 ! Check if we have to write to file if ( dump ) then call mm_array_write ( y , \"serialtest out vector\" , info , iunit = iunit , filename = \"result.mtx\" ) end if ! Clean the memory and close if ( allocated ( x )) deallocate ( x , stat = info ) if ( info /= 0 ) write ( psb_err_unit , * ) \"x(n): Deallocation request denied\" if ( allocated ( y )) deallocate ( y , stat = info ) if ( info /= 0 ) write ( psb_err_unit , * ) \"y(n): Deallocation request denied\" call psb_exit ( ctxt ) stop 9999 call psb_error ( ctxt ) stop contains subroutine get_parms ( ctxt , mname , fname , variant , scaling , dump ) !! This subroutine reads the parameters needed to run the serialtest !! program from standard input type ( psb_ctxt_type ), intent ( in ) :: ctxt character ( len =* ), intent ( out ) :: mname , fname , variant real ( psb_dpk_ ), intent ( out ) :: scaling logical , intent ( out ) :: dump character ( len = 100 ) :: dumpchar integer ( psb_ipk_ ) :: ip , inp_unit character ( len = 1024 ) :: filename if ( command_argument_count () > 0 ) then call get_command_argument ( 1 , filename ) inp_unit = 30 open ( inp_unit , file = filename , action = 'read' , iostat = info ) if ( info /= 0 ) then write ( psb_err_unit , * ) 'Could not open file ' , filename , ' for input' call psb_abort ( ctxt ) stop else write ( psb_err_unit , * ) 'Opened file ' , trim ( filename ), ' for input' end if else inp_unit = psb_inp_unit end if read ( inp_unit , * ) ip if ( ip == 5 ) then read ( inp_unit , * ) mname read ( inp_unit , * ) fname read ( inp_unit , * ) variant read ( inp_unit , * ) scaling read ( inp_unit , * ) dumpchar select case ( psb_toupper ( dumpchar )) case ( \"T\" , \"TRUE\" ) dump = . true . case default dump = . false . end select else ! wrong number of parameters on input: all hopes are lost call pr_usage ( izero ) call psb_abort ( ctxt ) stop 1 end if if ( inp_unit /= psb_inp_unit ) then close ( inp_unit ) end if return end subroutine get_parms subroutine pr_usage ( iout ) !! Prints out information on incorrected program usage integer ( psb_ipk_ ) :: iout write ( iout , * ) 'incorrect parameter(s) found' write ( iout , * ) ' usage:  serialtest mname fname variant & & scaling dump' write ( iout , * ) ' where:' write ( iout , * ) '     mname:    MatrixMarket file name' write ( iout , * ) '     fname :   Matrix function name' write ( iout , * ) '     variant : Variant of the algorithm for the fname function' write ( iout , * ) '     scaling : Scalar scaling parameter  ' write ( iout , * ) '     dump :    Save result on file T/F   ' end subroutine pr_usage end program serialtest","tags":"","loc":"sourcefile/serialtest.f90.html"},{"title":"psblastest.f90 – PSFUN","text":"Contents Programs psblastest Source Code psblastest.f90 Source Code ! BSD 3-Clause License ! ! Copyright (c) 2020, Fabio Durastante ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this !    list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. program psblastest !! This is a simple test for the base functionalities of the PSBLAS library. !! It can be used to see if everything links and is in order. use psb_base_mod implicit none type ( psb_ctxt_type ) :: ctxt integer ( psb_ipk_ ) :: iam , np , ip , jp , idummy call psb_init ( ctxt ) call psb_info ( ctxt , iam , np ) !   have all processes check in if (( iam >= psb_root_ ). and .( iam < np )) then if ( iam == psb_root_ ) then do ip = 1 , np - 1 call psb_rcv ( ctxt , idummy , ip ) enddo write ( * , * ) 'Hello, world: all ' , np , & & ' processes checked in!' else ip = psb_root_ call psb_snd ( ctxt , idummy , ip ) endif end if call psb_exit ( ctxt ) end program","tags":"","loc":"sourcefile/psblastest.f90.html"},{"title":"psfun_z_quadrature_mod.F90 – PSFUN","text":"This file depends on sourcefile~~psfun_z_quadrature_mod.f90~~EfferentGraph sourcefile~psfun_z_quadrature_mod.f90 psfun_z_quadrature_mod.F90 sourcefile~psfun_base_quadrature_mod.f90 psfun_base_quadrature_mod.f90 sourcefile~psfun_z_quadrature_mod.f90->sourcefile~psfun_base_quadrature_mod.f90 sourcefile~psfun_utils_mod.f90 psfun_utils_mod.f90 sourcefile~psfun_z_quadrature_mod.f90->sourcefile~psfun_utils_mod.f90 sourcefile~psfun_base_quadrature_mod.f90->sourcefile~psfun_utils_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~psfun_z_quadrature_mod.f90~~AfferentGraph sourcefile~psfun_z_quadrature_mod.f90 psfun_z_quadrature_mod.F90 sourcefile~psfun_quadrature_mod.f90 psfun_quadrature_mod.f90 sourcefile~psfun_quadrature_mod.f90->sourcefile~psfun_z_quadrature_mod.f90 sourcefile~psfun_z_quadrules_mod.f90 psfun_z_quadrules_mod.f90 sourcefile~psfun_z_quadrules_mod.f90->sourcefile~psfun_z_quadrature_mod.f90 sourcefile~quadraturetest.f90 quadraturetest.F90 sourcefile~quadraturetest.f90->sourcefile~psfun_quadrature_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules psfun_z_quadrature_mod Source Code psfun_z_quadrature_mod.F90 Source Code ! BSD 3-Clause License ! ! Copyright (c) 2020, Fabio Durastante ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this !    list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. module psfun_z_quadrature_mod !! This module computes the matrix-function vector product by means of the !! approximation of f(A)\\mathbf{x} based on quadrature formula, i.e., !! having computed the poles and the scalings of the formula solves N linear !! systems to approximate the product. use psfun_base_quadrature_mod use psb_base_mod use psfun_utils_mod use ogpf implicit none type , extends ( psfun_quadrature ) :: psfun_z_quadrature complex ( psb_dpk_ ), allocatable , dimension (:) :: xi !! Poles of the formula complex ( psb_dpk_ ), allocatable , dimension (:) :: c !! Scaling of the formula real ( psb_dpk_ ) :: eta !! Global Scaling real ( psb_dpk_ ) :: sign !! Sign for A type ( psb_dspmat_type ), pointer :: a !! Matrix on which we work type ( psb_dprec_type ), pointer :: prec !! Preconditioner for the solution of the associate linear systems contains procedure , pass ( quad ) :: computepoles => psfun_z_computepoles procedure , pass ( quad ) :: setmatrix => psfun_z_setmatrix procedure , pass ( quad ) :: setpreconditioner => psfun_z_setpreconditioner generic , public :: set => setmatrix , setpreconditioner procedure , pass ( quad ) :: plot => psfun_z_quadratureplot end type psfun_z_quadrature ! ************************************************************************** ! ! Abstract interfaces ! These are abstract interfaces that can be used to implement any possible ! quadrature rule on the user side. Then the computepoles routine takes ! it as input together with the number of wanted poles to populate the ! the variable of type psfun_quadrature. abstract interface subroutine zquadrule ( zfun , xi , c , eta , sign , N , info , cparams , rparams ) !! To integrate a function that take as inputs complex number and gives as output !! complex numbers use psb_base_mod implicit none complex ( psb_dpk_ ), allocatable , dimension (:), intent ( out ) :: xi !! Poles of the formula complex ( psb_dpk_ ), allocatable , dimension (:), intent ( out ) :: c !! Scaling of the formula real ( psb_dpk_ ), intent ( out ) :: eta !! Global Scaling real ( psb_dpk_ ), intent ( out ) :: sign !! Sign for A procedure ( zquadfun ), pointer , intent ( in ) :: zfun !! Function to integrate integer ( psb_ipk_ ), intent ( in ) :: N !! Number of Poles integer ( psb_ipk_ ), intent ( out ) :: info !! Flag on the results complex ( psb_dpk_ ), dimension (:), optional , intent ( in ) :: cparams !! Optional complex parameters real ( psb_dpk_ ), dimension (:), optional , intent ( in ) :: rparams !! Optional real parameters end subroutine end interface ! ************************************************************************** ! ! These are abstract interfaces for the function to which the quadrature rule ! should be applied abstract interface function zquadfun ( z ) result ( res ) use psb_base_mod implicit none complex ( psb_dpk_ ), intent ( in ) :: z complex ( psb_dpk_ ) :: res end function end interface ! ************************************************************************** ! ! Module procedures implementing different quadrature rules, all the rules ! are contained in the relative submodule interface hhtmethod1 !! Method 1 of Hale, Nicholas; Higham, Nicholas J.; Trefethen, Lloyd N. !! Computing \\mathbf{A}&#94;\\alpha,\\ \\log(\\mathbf{A}), and related matrix functions !! by contour integrals. SIAM J. Numer. Anal. 46 (2008), no. 5, 2505--2523. module subroutine hhtmethod1 ( zfun , xi , c , eta , sign , N , info , cparams , rparams ) procedure ( zquadfun ), pointer , intent ( in ) :: zfun !! Function to integrate complex ( psb_dpk_ ), allocatable , dimension (:), intent ( out ) :: xi !! Poles of the formula complex ( psb_dpk_ ), allocatable , dimension (:), intent ( out ) :: c !! Scaling of the formula real ( psb_dpk_ ), intent ( out ) :: eta !! Global Scaling real ( psb_dpk_ ), intent ( out ) :: sign !! Sign for A integer ( psb_ipk_ ), intent ( in ) :: N !! Number of Poles integer ( psb_ipk_ ), intent ( out ) :: info !! Flag on the results complex ( psb_dpk_ ), dimension (:), optional , intent ( in ) :: cparams !! Optional complex parameters real ( psb_dpk_ ), dimension (:), optional , intent ( in ) :: rparams !! Optional real parameters end subroutine end interface contains subroutine psfun_z_computepoles ( quad , quadformula , zfun , N , info , cparams , rparams ) !! Compute the poles for a given combination of quadrature rule and !! quadrature formula use psb_base_mod implicit none class ( psfun_z_quadrature ), intent ( inout ) :: quad !! Quadrature type procedure ( zquadrule ), pointer , intent ( in ) :: quadformula !! Quadrature formula procedure ( zquadfun ), pointer , intent ( in ) :: zfun !! Function to integrate integer ( psb_ipk_ ), intent ( in ) :: N !! Number of poles integer ( psb_ipk_ ), intent ( out ) :: info !! Flag on the results complex ( psb_dpk_ ), dimension (:), optional , intent ( in ) :: cparams !! Optional complex parameters real ( psb_dpk_ ), dimension (:), optional , intent ( in ) :: rparams !! Optional real parameters info = 0 if ( present ( cparams ) ) then call quadformula ( zfun , quad % xi , quad % c , quad % eta , quad % sign , N , info , cparams = cparams ) else if ( present ( rparams ) ) then call quadformula ( zfun , quad % xi , quad % c , quad % eta , quad % sign , N , info , rparams = rparams ) else if ( ( present ( cparams )). and .( present ( rparams )) ) then call quadformula ( zfun , quad % xi , quad % c , quad % eta , quad % sign , N , info , cparams , rparams ) else call quadformula ( zfun , quad % xi , quad % c , quad % eta , quad % sign , N , info ) end if return end subroutine psfun_z_computepoles subroutine psfun_z_setmatrix ( quad , a ) !! Set the matrix A for f(A)x use psb_base_mod implicit none class ( psfun_z_quadrature ), intent ( inout ) :: quad !! Quadrature type type ( psb_dspmat_type ), target :: a !! Matrix on which we work quad % a => a end subroutine psfun_z_setmatrix subroutine psfun_z_setpreconditioner ( quad , prec ) !! Set the preconditioner to use for the given quadrature formula use psb_base_mod implicit none class ( psfun_z_quadrature ), intent ( inout ) :: quad !! Quadrature type type ( psb_dprec_type ), target :: prec !! Preconditioner for the solution of the associate linear systems quad % prec => prec end subroutine psfun_z_setpreconditioner subroutine psfun_z_quadratureplot ( quad , zfun , info , filename ) !! Plots on the complex plane the quadrature poles, and plots the weights of !! the formula use psb_base_mod use ogpf implicit none class ( psfun_z_quadrature ), intent ( in ) :: quad !! Quadrature rule procedure ( zquadfun ), pointer , intent ( in ) :: zfun !! Function to integrate integer ( psb_ipk_ ), intent ( out ) :: info character ( len =* ), optional , intent ( in ) :: filename ! local variables type ( gpf ) :: gp character ( len = 100 ) :: pf integer ( psb_ipk_ ) :: i , n if ( present ( filename ) ) then pf = trim ( filename ) else pf = \"quadrule\" end if #if defined(WITHGNUPLOTFORTRAN) n = size ( quad % xi ) call gp % setterminal ( \"set terminal pdf; set output '\" // trim ( pf ) // \".pdf'\" ) call gp % multiplot ( 1 , 2 ) call gp % title ( \"Nodes\" ) call gp % xlabel ( 'Real' ) call gp % ylabel ( 'Imag' ) call gp % plot ( real ( quad % xi ), aimag ( quad % xi ), 'with points lt 6' ) call gp % title ( \"Weights\" ) call gp % xlabel ( 'Real' ) call gp % ylabel ( 'Imag' ) call gp % plot ( real ( quad % c ), aimag ( quad % c ), 'with points lt 6' ) call gp % options ( \"unset multiplot\" ) info = psb_success_ #else info = psb_err_from_subroutine_ #endif end subroutine psfun_z_quadratureplot end module psfun_z_quadrature_mod","tags":"","loc":"sourcefile/psfun_z_quadrature_mod.f90.html"},{"title":"psfun_z_quadrules_mod.f90 – PSFUN","text":"This file depends on sourcefile~~psfun_z_quadrules_mod.f90~~EfferentGraph sourcefile~psfun_z_quadrules_mod.f90 psfun_z_quadrules_mod.f90 sourcefile~psfun_z_quadrature_mod.f90 psfun_z_quadrature_mod.F90 sourcefile~psfun_z_quadrules_mod.f90->sourcefile~psfun_z_quadrature_mod.f90 sourcefile~psfun_utils_mod.f90 psfun_utils_mod.f90 sourcefile~psfun_z_quadrules_mod.f90->sourcefile~psfun_utils_mod.f90 sourcefile~psfun_z_quadrature_mod.f90->sourcefile~psfun_utils_mod.f90 sourcefile~psfun_base_quadrature_mod.f90 psfun_base_quadrature_mod.f90 sourcefile~psfun_z_quadrature_mod.f90->sourcefile~psfun_base_quadrature_mod.f90 sourcefile~psfun_base_quadrature_mod.f90->sourcefile~psfun_utils_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules psfun_z_quadrules_mod Source Code psfun_z_quadrules_mod.f90 Source Code ! BSD 3-Clause License ! ! Copyright (c) 2020, Fabio Durastante ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this !    list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. submodule ( psfun_z_quadrature_mod ) psfun_z_quadrules_mod !! This submodule contains the impliementation of the legacy quadrature rules !! distributed with the library. ! Constants used internally real ( psb_dpk_ ), parameter :: DPI = 4.0_psb_dpk_ * ATAN ( 1.0_psb_dpk_ ) !! Double precision :math:`\\pi` for internal usage complex , parameter :: iunit = cmplx ( 0.0_psb_dpk_ , 1.0_psb_dpk_ ) !! Immaginary unit contains module subroutine hhtmethod1 ( zfun , xi , c , eta , sign , N , info , cparams , rparams ) !! Method 1 of Hale, Nicholas; Higham, Nicholas J.; Trefethen, Lloyd N. !! Computing \\mathbf{A}&#94;\\alpha,\\ \\log(\\mathbf{A}), and related matrix functions !! by contour integrals. SIAM J. Numer. Anal. 46 (2008), no. 5, 2505--2523. use psb_base_mod use psfun_utils_mod , only : ellipkkp , ellipj implicit none procedure ( zquadfun ), pointer , intent ( in ) :: zfun !! Function to integrate complex ( psb_dpk_ ), allocatable , dimension (:), intent ( out ) :: xi !! Poles of the formula complex ( psb_dpk_ ), allocatable , dimension (:), intent ( out ) :: c !! Scaling of the formula real ( psb_dpk_ ), intent ( out ) :: eta !! Global Scaling real ( psb_dpk_ ), intent ( out ) :: sign !! Sign for A integer ( psb_ipk_ ), intent ( in ) :: N !! Number of Poles integer ( psb_ipk_ ), intent ( out ) :: info !! Flag on the results complex ( psb_dpk_ ), dimension (:), optional , intent ( in ) :: cparams !! Optional complex parameters real ( psb_dpk_ ), dimension (:), optional , intent ( in ) :: rparams !! Optional real parameters ! local variables real ( psb_dpk_ ) :: mineig , maxeig , cond , L , K , Kp , Kvec ( 2 ) complex ( psb_dpk_ ) :: u , cn , dn complex ( psb_dpk_ ) :: t integer ( psb_ipk_ ) :: j info = 0 mineig = min ( rparams ( 1 ), rparams ( 2 )) ! Estimate of the minimum eigenvalue maxeig = max ( rparams ( 1 ), rparams ( 2 )) ! Estimate of the maximum eigenvalue allocate ( xi ( N ), stat = info ) allocate ( c ( N ), stat = info ) cond = ( sqrt ( maxeig / mineig ) - 1 ) / ( sqrt ( maxeig / mineig ) + 1 ) L = - log ( cond ) / DPI Kvec = ellipkkp ( L ) K = Kvec ( 1 ) Kp = Kvec ( 2 ) do j = 1 , N , 1 t = . 5_psb_dpk_ * iunit * Kp - K + ( 2.0_psb_dpk_ * ( j - 1_psb_ipk_ ) + 1_psb_dpk_ ) * K / N call ellipj ( t , L , u , cn , dn ) xi ( j ) = sqrt ( mineig * maxeig ) * (( 1.0_psb_dpk_ / cond + u ) / ( 1.0_psb_dpk_ / cond - u )) c ( j ) = ( zfun ( xi ( j )) / xi ( j )) * ( cn * dn ) / (( 1.0_psb_dpk_ / cond - u ) ** 2 ) end do eta = - ( 4.0_psb_dpk_ * K * sqrt ( mineig * maxeig )) / ( cond * DPI * N ) sign = - 1.0_psb_dpk_ end subroutine hhtmethod1 end submodule","tags":"","loc":"sourcefile/psfun_z_quadrules_mod.f90.html"},{"title":"psfun_base_quadrature_mod.f90 – PSFUN","text":"This file depends on sourcefile~~psfun_base_quadrature_mod.f90~~EfferentGraph sourcefile~psfun_base_quadrature_mod.f90 psfun_base_quadrature_mod.f90 sourcefile~psfun_utils_mod.f90 psfun_utils_mod.f90 sourcefile~psfun_base_quadrature_mod.f90->sourcefile~psfun_utils_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~psfun_base_quadrature_mod.f90~~AfferentGraph sourcefile~psfun_base_quadrature_mod.f90 psfun_base_quadrature_mod.f90 sourcefile~psfun_d_quadrature_mod.f90 psfun_d_quadrature_mod.F90 sourcefile~psfun_d_quadrature_mod.f90->sourcefile~psfun_base_quadrature_mod.f90 sourcefile~psfun_quadrature_mod.f90 psfun_quadrature_mod.f90 sourcefile~psfun_quadrature_mod.f90->sourcefile~psfun_base_quadrature_mod.f90 sourcefile~psfun_quadrature_mod.f90->sourcefile~psfun_d_quadrature_mod.f90 sourcefile~psfun_z_quadrature_mod.f90 psfun_z_quadrature_mod.F90 sourcefile~psfun_quadrature_mod.f90->sourcefile~psfun_z_quadrature_mod.f90 sourcefile~psfun_z_quadrature_mod.f90->sourcefile~psfun_base_quadrature_mod.f90 sourcefile~psfun_z_quadrules_mod.f90 psfun_z_quadrules_mod.f90 sourcefile~psfun_z_quadrules_mod.f90->sourcefile~psfun_z_quadrature_mod.f90 sourcefile~quadraturetest.f90 quadraturetest.F90 sourcefile~quadraturetest.f90->sourcefile~psfun_quadrature_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules psfun_base_quadrature_mod Source Code psfun_base_quadrature_mod.f90 Source Code ! BSD 3-Clause License ! ! Copyright (c) 2020, Fabio Durastante ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this !    list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. module psfun_base_quadrature_mod !! Module containing the implementation of the base method for the computation !! of f(A)v by means of distributed quadrature formulas. use psb_base_mod use psb_prec_mod use psb_krylov_mod use psfun_utils_mod implicit none type , public :: psfun_quadrature type ( psb_desc_type ) :: desc_a !! Descriptor for parallel environment contains end type psfun_quadrature contains end module psfun_base_quadrature_mod","tags":"","loc":"sourcefile/psfun_base_quadrature_mod.f90.html"},{"title":"psfun_quadrature_mod.f90 – PSFUN","text":"This file depends on sourcefile~~psfun_quadrature_mod.f90~~EfferentGraph sourcefile~psfun_quadrature_mod.f90 psfun_quadrature_mod.f90 sourcefile~psfun_d_quadrature_mod.f90 psfun_d_quadrature_mod.F90 sourcefile~psfun_quadrature_mod.f90->sourcefile~psfun_d_quadrature_mod.f90 sourcefile~psfun_base_quadrature_mod.f90 psfun_base_quadrature_mod.f90 sourcefile~psfun_quadrature_mod.f90->sourcefile~psfun_base_quadrature_mod.f90 sourcefile~psfun_z_quadrature_mod.f90 psfun_z_quadrature_mod.F90 sourcefile~psfun_quadrature_mod.f90->sourcefile~psfun_z_quadrature_mod.f90 sourcefile~psfun_d_quadrature_mod.f90->sourcefile~psfun_base_quadrature_mod.f90 sourcefile~psfun_utils_mod.f90 psfun_utils_mod.f90 sourcefile~psfun_d_quadrature_mod.f90->sourcefile~psfun_utils_mod.f90 sourcefile~psfun_base_quadrature_mod.f90->sourcefile~psfun_utils_mod.f90 sourcefile~psfun_z_quadrature_mod.f90->sourcefile~psfun_base_quadrature_mod.f90 sourcefile~psfun_z_quadrature_mod.f90->sourcefile~psfun_utils_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~psfun_quadrature_mod.f90~~AfferentGraph sourcefile~psfun_quadrature_mod.f90 psfun_quadrature_mod.f90 sourcefile~quadraturetest.f90 quadraturetest.F90 sourcefile~quadraturetest.f90->sourcefile~psfun_quadrature_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules psfun_quadrature_mod Source Code psfun_quadrature_mod.f90 Source Code ! BSD 3-Clause License ! ! Copyright (c) 2020, Fabio Durastante ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this !    list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. module psfun_quadrature_mod !! This module computes the matrix-function vector product by means of the !! approximation of f(A)\\mathbf{x} based on quadrature formula, i.e., !! having computed the poles and the scalings of the formula solves N linear !! systems to approximate the product. use psfun_base_quadrature_mod use psfun_d_quadrature_mod use psfun_z_quadrature_mod end module psfun_quadrature_mod","tags":"","loc":"sourcefile/psfun_quadrature_mod.f90.html"},{"title":"psfun_d_quadrature_mod.F90 – PSFUN","text":"This file depends on sourcefile~~psfun_d_quadrature_mod.f90~~EfferentGraph sourcefile~psfun_d_quadrature_mod.f90 psfun_d_quadrature_mod.F90 sourcefile~psfun_base_quadrature_mod.f90 psfun_base_quadrature_mod.f90 sourcefile~psfun_d_quadrature_mod.f90->sourcefile~psfun_base_quadrature_mod.f90 sourcefile~psfun_utils_mod.f90 psfun_utils_mod.f90 sourcefile~psfun_d_quadrature_mod.f90->sourcefile~psfun_utils_mod.f90 sourcefile~psfun_base_quadrature_mod.f90->sourcefile~psfun_utils_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~psfun_d_quadrature_mod.f90~~AfferentGraph sourcefile~psfun_d_quadrature_mod.f90 psfun_d_quadrature_mod.F90 sourcefile~psfun_quadrature_mod.f90 psfun_quadrature_mod.f90 sourcefile~psfun_quadrature_mod.f90->sourcefile~psfun_d_quadrature_mod.f90 sourcefile~quadraturetest.f90 quadraturetest.F90 sourcefile~quadraturetest.f90->sourcefile~psfun_quadrature_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules psfun_d_quadrature_mod Source Code psfun_d_quadrature_mod.F90 Source Code ! BSD 3-Clause License ! ! Copyright (c) 2020, Fabio Durastante ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this !    list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. module psfun_d_quadrature_mod !! This module computes the matrix-function vector product by means of the !! approximation of f(A)\\mathbf{x} based on quadrature formula, i.e., !! having computed the poles and the scalings of the formula solves N linear !! systems to approximate the product. use psfun_base_quadrature_mod use psb_base_mod use psfun_utils_mod use ogpf implicit none type , extends ( psfun_quadrature ) :: psfun_d_quadrature real ( psb_dpk_ ), allocatable , dimension (:) :: xi !! Poles of the formula real ( psb_dpk_ ), allocatable , dimension (:) :: c !! Scaling of the formula real ( psb_dpk_ ) :: eta !! Global Scaling real ( psb_dpk_ ) :: sign !! Sign for A type ( psb_dspmat_type ), pointer :: a !! Matrix on which we work type ( psb_dprec_type ) :: prec !! Preconditioner for the solution of the associated linear systems contains procedure , pass ( quad ) :: plot => psfun_d_quadratureplot end type psfun_d_quadrature abstract interface subroutine dquadrule ( dfun , xi , c , eta , sign , N , info , cparams , rparams ) !! To integrate a function that take as inputs real numbers and gives as !! output complex numbers use psb_base_mod implicit none complex ( psb_dpk_ ), allocatable , dimension (:), intent ( out ) :: xi !! Poles of the formula complex ( psb_dpk_ ), allocatable , dimension (:), intent ( out ) :: c !! Scaling of the formula complex ( psb_dpk_ ), intent ( out ) :: eta !! Global Scaling complex ( psb_dpk_ ), intent ( out ) :: sign !! Sign for A procedure ( dquadfun ), pointer , intent ( in ) :: dfun !! Function to integrate integer ( psb_ipk_ ), intent ( in ) :: N !! Number of Poles integer ( psb_ipk_ ), intent ( out ) :: info !! Flag on the results complex ( psb_dpk_ ), dimension (:), optional , intent ( in ) :: cparams !! Optional complex parameters real ( psb_dpk_ ), dimension (:), optional , intent ( in ) :: rparams !! Optional real parameters end subroutine end interface abstract interface function dquadfun ( z ) result ( res ) use psb_base_mod implicit none real ( psb_dpk_ ), intent ( in ) :: z complex ( psb_dpk_ ) :: res end function end interface contains subroutine psfun_d_quadratureplot ( quad , dfun , filename , info ) !! Plots on the complex plane the quadrature poles, and plots the weights of !! the formula use psb_base_mod use ogpf implicit none class ( psfun_d_quadrature ), intent ( in ) :: quad !! Quadrature rule procedure ( dquadfun ), pointer , intent ( in ) :: dfun !! Function to integrate integer ( psb_ipk_ ), intent ( out ) :: info !! Result of the plot character ( len =* ), optional , intent ( in ) :: filename !! Filename for the figure ! local variables type ( gpf ) :: gp character ( len = 100 ) :: pf real ( psb_dpk_ ), allocatable :: zeros (:) integer ( psb_ipk_ ) :: i , n if ( present ( filename ) ) then pf = trim ( filename ) else pf = \"quadrule\" end if #if defined(WITHGNUPLOTFORTRAN) n = size ( quad % xi ) allocate ( zeros ( n ), stat = info ) zeros (:) = 0.0_psb_dpk_ call gp % setterminal ( \"set terminal pdf; set output '\" // trim ( pf ) // \".pdf'\" ) call gp % multiplot ( 1 , 2 ) call gp % options ( \"set terminal pdf;& &set output '\" // trim ( pf ) // \".pdf'\" ) call gp % title ( \"Nodes\" ) call gp % xlabel ( 'Real' ) call gp % ylabel ( 'Imag' ) call gp % plot ( quad % xi , zeros , 'with lp 5' ) call gp % title ( \"Weights\" ) call gp % xlabel ( 'Nodes' ) call gp % ylabel ( 'Weight' ) call gp % plot ( quad % xi , quad % c , 'with lp 5' ) call gp % options ( \"unset multiplot\" ) info = psb_success_ if ( allocated ( zeros )) deallocate ( zeros , stat = info ) #else info = psb_err_from_subroutine_ #endif end subroutine psfun_d_quadratureplot end module psfun_d_quadrature_mod","tags":"","loc":"sourcefile/psfun_d_quadrature_mod.f90.html"},{"title":"psfun_krylov_mod.f90 – PSFUN","text":"Files dependent on this one sourcefile~~psfun_krylov_mod.f90~~AfferentGraph sourcefile~psfun_krylov_mod.f90 psfun_krylov_mod.f90 sourcefile~psfun_d_sai.f90 psfun_d_sai.f90 sourcefile~psfun_d_sai.f90->sourcefile~psfun_krylov_mod.f90 sourcefile~shiftedtest.f90 shiftedtest.f90 sourcefile~shiftedtest.f90->sourcefile~psfun_krylov_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules psfun_krylov_mod Source Code psfun_krylov_mod.f90 Source Code ! BSD 3-Clause License ! ! Copyright (c) 2020, Fabio Durastante ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this !    list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. module psfun_krylov_mod !! This module implements the Krylov methods for the solution of shifted linear !! systems: (η A + ζ I)x = b. It is built as an extension of the Krylov module !! for PSBLAS (`psb_krylov_mod`) use psb_base_mod use psb_prec_mod use amg_prec_mod interface psb_krylov !! We add the methods for the shifted system to the same interfaces in PSBLAS !! it is a lazy way to avoid modifying all the Krylov methods in PSBLAS to !! allow for the solution of shifted linear systems module procedure psfun_dkrylov_vect end interface psb_krylov contains subroutine psfun_dkrylov_vect ( method , a , prec , b , eta , zeta , x , eps , desc_a , info ,& & itmax , iter , err , itrace , irst , istop , cond ) !! Apply Krylov method to  (\\eta A + \\zeta I)x = b on distributed vectors use psb_base_mod , only : psb_ipk_ , psb_desc_type , psb_dspmat_type , & & psb_dpk_ , psb_d_vect_type use psb_prec_mod , only : psb_dprec_type character ( len =* ) :: method Type ( psb_dspmat_type ), Intent ( in ) :: a Type ( psb_desc_type ), Intent ( in ) :: desc_a class ( psb_dprec_type ), intent ( inout ) :: prec type ( psb_d_vect_type ), Intent ( inout ) :: b real ( psb_dpk_ ), intent ( in ) :: eta real ( psb_dpk_ ), intent ( in ) :: zeta type ( psb_d_vect_type ), Intent ( inout ) :: x Real ( psb_dpk_ ), Intent ( in ) :: eps integer ( psb_ipk_ ), intent ( out ) :: info integer ( psb_ipk_ ), Optional , Intent ( in ) :: itmax , itrace , irst , istop integer ( psb_ipk_ ), Optional , Intent ( out ) :: iter Real ( psb_dpk_ ), Optional , Intent ( out ) :: err , cond abstract interface subroutine psfun_dkryl_cond_vect ( a , prec , b , eta , zeta , x , eps , desc_a , info ,& & itmax , iter , err , itrace , istop , cond ) import :: psb_ipk_ , psb_dpk_ , psb_desc_type , & & psb_dspmat_type , psb_dprec_type , psb_d_vect_type Type ( psb_dspmat_type ), Intent ( in ) :: a Type ( psb_desc_type ), Intent ( in ) :: desc_a class ( psb_dprec_type ), intent ( inout ) :: prec type ( psb_d_vect_type ), Intent ( inout ) :: b real ( psb_dpk_ ), intent ( in ) :: eta real ( psb_dpk_ ), intent ( in ) :: zeta type ( psb_d_vect_type ), Intent ( inout ) :: x Real ( psb_dpk_ ), Intent ( in ) :: eps integer ( psb_ipk_ ), intent ( out ) :: info integer ( psb_ipk_ ), Optional , Intent ( in ) :: itmax , itrace , istop integer ( psb_ipk_ ), Optional , Intent ( out ) :: iter Real ( psb_dpk_ ), Optional , Intent ( out ) :: err , cond end subroutine psfun_dkryl_cond_vect end interface procedure ( psfun_dkryl_cond_vect ) :: psfun_dcg_vect logical :: do_alloc_wrk type ( psb_ctxt_type ) :: ctxt integer ( psb_ipk_ ) :: me , np , err_act , itrace_ character ( len = 20 ) :: name info = psb_success_ name = 'psfun_krylov' call psb_erractionsave ( err_act ) ctxt = desc_a % get_context () call psb_info ( ctxt , me , np ) ! Default return for COND if ( present ( cond )) cond = dzero if ( present ( itrace )) then itrace_ = itrace else itrace_ = - 1 end if do_alloc_wrk = . not . prec % is_allocated_wrk () if ( do_alloc_wrk ) call prec % allocate_wrk ( info , vmold = x % v , desc = desc_a ) select case ( psb_toupper ( method )) case ( 'CG' ) call psfun_dcg_vect ( a , prec , b , eta , zeta , x , eps , desc_a , info ,& & itmax , iter , err , itrace = itrace_ , istop = istop , cond = cond ) case default if ( me == 0 ) write ( psb_err_unit , * ) trim ( name ),& & ': Warning: Unknown method  ' , method ,& & ', defaulting to CG' call psfun_dcg_vect ( a , prec , b , eta , zeta , x , eps , desc_a , info ,& & itmax , iter , err , itrace = itrace_ , istop = istop ) end select if (( info == psb_success_ ). and . do_alloc_wrk ) call prec % free_wrk ( info ) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_ call psb_errpush ( info , name , a_err = trim ( method )) goto 9999 end if call psb_erractionrestore ( err_act ) return 9999 call psb_error_handler ( ctxt , err_act ) return end subroutine psfun_dkrylov_vect end module psfun_krylov_mod","tags":"","loc":"sourcefile/psfun_krylov_mod.f90.html"},{"title":"psfun_d_krylov_mod.F90 – PSFUN","text":"This file depends on sourcefile~~psfun_d_krylov_mod.f90~~EfferentGraph sourcefile~psfun_d_krylov_mod.f90 psfun_d_krylov_mod.F90 sourcefile~psfun_d_serial_mod.f90 psfun_d_serial_mod.F90 sourcefile~psfun_d_krylov_mod.f90->sourcefile~psfun_d_serial_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~psfun_d_krylov_mod.f90~~AfferentGraph sourcefile~psfun_d_krylov_mod.f90 psfun_d_krylov_mod.F90 sourcefile~psfun_d_arnoldi.f90 psfun_d_arnoldi.f90 sourcefile~psfun_d_arnoldi.f90->sourcefile~psfun_d_krylov_mod.f90 sourcefile~lanczostest.f90 lanczostest.F90 sourcefile~lanczostest.f90->sourcefile~psfun_d_krylov_mod.f90 sourcefile~arnolditest.f90 arnolditest.F90 sourcefile~arnolditest.f90->sourcefile~psfun_d_krylov_mod.f90 sourcefile~psfun_d_sai.f90 psfun_d_sai.f90 sourcefile~psfun_d_sai.f90->sourcefile~psfun_d_krylov_mod.f90 sourcefile~psfun_d_lanczos.f90 psfun_d_lanczos.f90 sourcefile~psfun_d_lanczos.f90->sourcefile~psfun_d_krylov_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules psfun_d_krylov_mod Source Code psfun_d_krylov_mod.F90 Source Code ! BSD 3-Clause License ! ! Copyright (c) 2020, Fabio Durastante ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this !    list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. module psfun_d_krylov_mod !! The [[psfun_d_krylov_mod]] contains the generic call to a Krylov subspace !! method for the computation of y = f(A) x, for A large and !! sparse. use psb_base_mod use psb_krylov_mod use amg_prec_mod use psfun_d_serial_mod use ogpf implicit none type , public :: psfun_d_krylov character ( len = 20 ) :: kname = 'ARNOLDI' !! Name of the Krylov method character ( len = 20 ) :: kmethd = 'CG' !! Method for the solution of the linear system type ( amg_dprec_type ) :: prec !! Preconditioner for the inner solution method real ( psb_dpk_ ) :: tau = dzero !! Shift for shift-and-invert methods integer ( psb_ipk_ ) :: itmax = 200 !! Maximum number of iterations (inner method) integer ( psb_ipk_ ) :: itrace = 0 !! Trace for the solution (inner method) integer ( psb_ipk_ ) :: istopc = 1 !! Stopping criterion (inner method) integer ( psb_ipk_ ) :: irst = 10 !! Size for subspace restarting (inner method) contains ! Set the options procedure , pass ( meth ) :: setstring => psfun_d_setstring procedure , pass ( meth ) :: setinteger => psfun_d_setinteger generic , public :: set => setstring , setinteger procedure , pass ( meth ) :: apply => psfun_d_parallel_apply procedure , pass ( meth ) :: plot => psfun_d_plot_info procedure , pass ( meth ) :: precinit => psfun_d_prec_init procedure , pass ( meth ) :: precbuild => psfun_d_prec_build end type private :: psfun_d_setstring , psfun_d_setinteger !! The various Krylov methods are contained in associated submodules, the !! idea is to have different methods, associated to the same !! orthogonalization method in the same submodule interface !! Simple polynomial method based on the Arnoldi orthogonalization procedure, !! the method builds a basis V_k for the Krylov subspace module subroutine psfun_d_arnoldi ( fun , a , desc_a , y , x , eps , info , itmax , itrace , istop , iter , err , res ) !! Simple polynomial method based on the Arnoldi orthogonalization procedure, !! the method builds a basis V_k for the Krylov subspace ! !! \\begin{equation*} !! \\mathcal{K}_k(A,x) = \\{x,Ax,\\ldots,A&#94;{k-1}x\\}, !! \\end{equation*} ! !! and approximates y = f(\\alpha A)x \\approx \\beta_1 V_k f(H_k) e_1,for !! \\beta_1 = \\|x\\|_2, e_1 the first vector of the canonical !! base of \\mathbb{R}&#94;k, and H_k the Hessemberg matrix given !! by H_k = V_k&#94;T A V_k. type ( psfun_d_serial ), intent ( inout ) :: fun !! Function object type ( psb_dspmat_type ), intent ( in ) :: a !! Distribute sparse matrix type ( psb_desc_type ), intent ( in ) :: desc_a !! Descriptor for the sparse matrix type ( psb_d_vect_type ), intent ( inout ) :: y !! Output vector type ( psb_d_vect_type ), intent ( inout ) :: x !! Input vector real ( psb_dpk_ ), intent ( in ) :: eps !! Requested tolerance integer ( psb_ipk_ ), intent ( out ) :: info !! Output flag integer ( psb_ipk_ ), optional , intent ( in ) :: itmax !! Maximum number of iteration integer ( psb_ipk_ ), optional , intent ( in ) :: itrace !! Trace for logoutput integer ( psb_ipk_ ), optional , intent ( in ) :: istop !! Stop criterion integer ( psb_ipk_ ), optional , intent ( out ) :: iter !! Number of iteration real ( psb_dpk_ ), optional , intent ( out ) :: err !! Last estimate error real ( psb_dpk_ ), optional , allocatable , intent ( out ) :: res (:) !! Vector of the residuals end subroutine end interface interface !! Simple polynomial method based on the Lanczos orthogonalization procedure, !! the method builds a basis V_k for the Krylov subspace module subroutine psfun_d_lanczos ( fun , a , desc_a , y , x , eps , info , itmax , itrace , istop , iter , err , res ) !! Simple polynomial method based on the Lanczos orthogonalization procedure, !! the method builds a basis V_k for the Krylov subspace !! !! \\begin{equation*} !! \\mathcal{K}_k(A,x) = \\{x,Ax,\\ldots,A&#94;{k-1}x\\}, !! \\end{equation*} !! !! and approximates y = f(\\alpha A)x \\approx \\beta_1 V_k f(T_k) e_1,for !! \\beta_1 = \\|x\\|_2, e_1 the first vector of the canonical !! base of \\mathbb{R}&#94;k, and T_k the Symmetric tridiagonal !! matrix given by T_k = V_k&#94;T A V_k. type ( psfun_d_serial ), intent ( inout ) :: fun !! Function object type ( psb_dspmat_type ), intent ( in ) :: a !! Distribute sparse matrix type ( psb_desc_type ), intent ( in ) :: desc_a !! Descriptor for the sparse matrix type ( psb_d_vect_type ), intent ( inout ) :: y !! Output vector type ( psb_d_vect_type ), intent ( inout ) :: x !! Input vector real ( psb_dpk_ ), intent ( in ) :: eps !! Requested tolerance integer ( psb_ipk_ ), intent ( out ) :: info !! Output flag integer ( psb_ipk_ ), optional , intent ( in ) :: itmax !! Maximum number of iteration integer ( psb_ipk_ ), optional , intent ( in ) :: itrace !! Trace for logoutput integer ( psb_ipk_ ), optional , intent ( in ) :: istop !! Stop criterion integer ( psb_ipk_ ), optional , intent ( out ) :: iter !! Number of iteration real ( psb_dpk_ ), optional , intent ( out ) :: err !! Last estimate error real ( psb_dpk_ ), optional , allocatable , intent ( out ) :: res (:) !! Vector of the residuals end subroutine psfun_d_lanczos end interface interface !! This interface contains the Shift-and-Invert method based on Arnoldi !! orthogonalization. module subroutine psfun_d_saiarnoldi ( fun , a , kryl , prec , tau , desc_a , & & initmax , initrace , inistop , y , x , eps , info , itmax , itrace , istop , iter , err , res ) !! Shift-and-invert method based on the Arnoldi orthogonalization procedure !! the method builds a basis  V_k  for the shifted Krylov subspace !! !! \\begin{equation*} !! \\mathcal{K}_( (A + \\tau I)&#94;{-1},x ) = \\{ x,(A + \\tau I)&#94;{-1}x,\\ldots,(A + \\tau I)&#94;{k-1}x\\}, !! \\end{equation*} !! !! and approximate  y = f(\\alpha A)x \\approx \\beta_1 f((H_k&#94;{-1} - \\tau I)&#94;{-1}) e_1,for !! \\beta_1 = \\|x\\|_2, e_1 the first vector of the canonical !! base of \\mathbb{R}&#94;k, and H_k the Hessemberg matrix given !! by the projection of A into the subspace \\mathcal{K}_( (A + \\tau I)&#94;{-1},x ). !! !! To  march the algorithm one needs to solve at each step a shifted linear !! system for which we employ the routines from [[psfun_krylov_mod]] and the !! preconditioners from AMG4PSBLAS. use psb_base_mod use psfun_d_serial_mod use psfun_krylov_mod use psb_d_krylov_conv_mod , only : log_header , log_conv , log_end implicit none type ( psfun_d_serial ), intent ( inout ) :: fun !! Function object type ( psb_dspmat_type ), intent ( in ) :: a !! Distribute sparse matrix character ( len =* ), intent ( in ) :: kryl !! Krylov method for the solution of inner systems type ( amg_dprec_type ), intent ( inout ) :: prec !! Preconditioner for the inner method real ( psb_dpk_ ), intent ( in ) :: tau !! Shift parameter of the method type ( psb_desc_type ), intent ( in ) :: desc_a !! Descriptor for the sparse matrix type ( psb_d_vect_type ), intent ( inout ) :: y !! Output vector type ( psb_d_vect_type ), intent ( inout ) :: x !! Input vector integer ( psb_ipk_ ), intent ( in ) :: initmax !! Maximum number of iteration (inner method) integer ( psb_ipk_ ), intent ( in ) :: initrace !! Trace for logoutput (inner method) integer ( psb_ipk_ ), intent ( in ) :: inistop !! Stop criterion (inner method) real ( psb_dpk_ ), intent ( in ) :: eps !! Requested tolerance integer ( psb_ipk_ ), intent ( out ) :: info !! Output flag integer ( psb_ipk_ ), optional , intent ( in ) :: itmax !! Maximum number of iteration integer ( psb_ipk_ ), optional , intent ( in ) :: itrace !! Trace for logoutput integer ( psb_ipk_ ), optional , intent ( in ) :: istop !! Stop criterion integer ( psb_ipk_ ), optional , intent ( out ) :: iter !! Number of iteration real ( psb_dpk_ ), optional , intent ( out ) :: err !! Last estimate error real ( psb_dpk_ ), optional , allocatable , intent ( out ) :: res (:) !! Vector of the residuals end subroutine end interface contains subroutine psfun_d_setstring ( meth , what , val , info ) !! Set function for setting options defined by a string use psb_base_mod implicit none class ( psfun_d_krylov ), intent ( inout ) :: meth ! Krylov method object character ( len =* ), intent ( in ) :: what ! String of option to set character ( len =* ), intent ( in ) :: val ! Value of the string integer ( psb_ipk_ ), intent ( out ) :: info ! Output flag info = psb_success_ select case ( psb_toupper ( what )) case ( \"KNAME\" ) meth % kname = val case default info = psb_err_invalid_args_combination_ end select end subroutine psfun_d_setstring subroutine psfun_d_setinteger ( meth , what , val , info ) !! Set function for setting options defined by an integer use psb_base_mod implicit none class ( psfun_d_krylov ), intent ( inout ) :: meth !! Krylov method object character ( len =* ), intent ( in ) :: what !! String of option to set integer ( psb_ipk_ ), intent ( in ) :: val !! Value of the integer integer ( psb_ipk_ ), intent ( out ) :: info !! Output flag info = psb_success_ select case ( psb_toupper ( what )) case ( \"ITMAX\" ) meth % itmax = val case ( \"ITRACE\" ) meth % itrace = val case ( \"ISTOPC\" ) meth % istopc = val case ( \"IRST\" ) meth % irst = val case default info = psb_err_invalid_args_combination_ end select end subroutine psfun_d_setinteger subroutine psfun_d_parallel_apply ( meth , fun , a , desc_a , y , x , eps , info , itmax , itrace , istop , iter , err , res ) !! This is the generic function for applying every implemented Krylov !! method. The general iteration parameters (like the number of iteration, !! the stop criterion to be used, and the verbosity of the trace) can be !! passed directly to this routine. All the constitutive parameters of !! the actual method, and the information relative to the function are !! instead contained in the meth and fun objects. The Descriptor object !! `desc_a' contains the properties of the parallel environment. use psb_base_mod use psb_prec_mod use amg_prec_mod use psfun_d_serial_mod implicit none class ( psfun_d_krylov ), intent ( inout ) :: meth !! Krylov method object type ( psfun_d_serial ), intent ( inout ) :: fun !! Function object type ( psb_dspmat_type ), intent ( in ) :: a !! Distribute sparse matrix type ( psb_desc_type ), intent ( in ) :: desc_a !! Descriptor for the sparse matrix type ( psb_d_vect_type ), intent ( inout ) :: y !! Output vector type ( psb_d_vect_type ), intent ( inout ) :: x !! Input vector real ( psb_dpk_ ), intent ( in ) :: eps !! Requested tolerance integer ( psb_ipk_ ), intent ( out ) :: info !! Output flag integer ( psb_ipk_ ), optional , intent ( in ) :: itmax !! Maximum number of iteration integer ( psb_ipk_ ), optional , intent ( in ) :: itrace !! Trace for logoutput integer ( psb_ipk_ ), optional , intent ( in ) :: istop !! Stop criterion integer ( psb_ipk_ ), optional , intent ( out ) :: iter !! Number of iteration real ( psb_dpk_ ), optional , intent ( out ) :: err !! Last estimate error real ( psb_dpk_ ), optional , allocatable , intent ( out ) :: res (:) !! Vector of the residuals select case ( psb_toupper ( meth % kname )) case ( \"ARNOLDI\" ) call psfun_d_arnoldi ( fun , a , desc_a , y , x , eps , info , itmax , itrace , istop , & & iter , err , res ) case ( \"LANCZOS\" ) call psfun_d_lanczos ( fun , a , desc_a , y , x , eps , info , itmax , itrace , istop , & & iter , err , res ) CASE ( \"SAIARNOLDI\" ) call psfun_d_saiarnoldi ( fun , a , meth % kmethd , meth % prec , meth % tau , desc_a , & & meth % itmax , meth % itrace , meth % istopc , y , x , eps , info , itmax , itrace , istop ,& & iter , err , res ) case default info = psb_err_invalid_args_combination_ end select end subroutine psfun_d_parallel_apply subroutine psfun_d_plot_info ( meth , fun , iter , res , info ) !! This function plots the convergence history of the Krylov method use psb_base_mod use ogpf implicit none class ( psfun_d_krylov ), intent ( inout ) :: meth !! Krylov method type ( psfun_d_serial ), intent ( inout ) :: fun !! Function object integer ( psb_ipk_ ), intent ( in ) :: iter !! Number of iteration real ( psb_dpk_ ), intent ( in ), dimension (:) :: res !! Residual vector integer ( psb_ipk_ ), intent ( out ) :: info !! Result of the Gnuplot call type ( gpf ) :: gp character ( len = 100 ) :: pf real ( psb_dpk_ ), allocatable :: xarray (:) integer ( psb_ipk_ ) :: n , indplot real ( psb_dpk_ ) :: plot n = size ( res ) if ( n <= iter + 1 ) then indplot = n plot = n else indplot = iter + 1 plot = iter + 1 end if #if defined(WITHGNUPLOTFORTRAN) allocate ( xarray ( indplot ), stat = info ) xarray = linspace ( 1.0_psb_dpk_ , plot , indplot ) pf = trim ( meth % kname ) // trim ( \"-\" ) // trim ( fun % fname ) & & // trim ( \"-\" ) // trim ( fun % variant ) // trim ( \"-Residual\" ) call gp % options ( \"set terminal pdf;& &set output '\" // trim ( pf ) // \".pdf'\" ) call gp % title ( \"Residual history \" // trim ( meth % kname ) // trim ( \"-\" ) & & // trim ( fun % fname ) // trim ( \"-\" ) // trim ( fun % variant )) call gp % xlabel ( 'Iteration' ) call gp % ylabel ( 'Relative Residual' ) call gp % options ( 'set style data linespoints;& &set logscale y;& &set format y \"10&#94;{%L}\";' ) !Call Plot to draw a vector against a vector of data call gp % plot ( xarray ( 1 : indplot ), res ( 1 : indplot ), 'with lp lt 7' ) info = psb_success_ if ( allocated ( xarray )) deallocate ( xarray , stat = info ) #else info = psb_err_from_subroutine_ #endif end subroutine psfun_d_plot_info subroutine psfun_d_prec_init ( meth , ctxt , ptype , info ) !! This function performs the init of the preconditioner for the inner !! solve in the rational Krylov method use psb_base_mod use amg_prec_mod implicit none class ( psfun_d_krylov ), intent ( inout ) :: meth !! Krylov method type ( psb_ctxt_type ), intent ( in ) :: ctxt !! Parallel context character ( len = 20 ), intent ( in ) :: ptype !! PSBLAS/AMG4PSBLAS preconditioner integer ( psb_ipk_ ) :: info !! Result of the init call ! Local Variables integer ( psb_ipk_ ) :: err_act character ( len = 20 ) :: name name = 'd_prec_init' call psb_erractionsave ( err_act ) info = psb_success_ call meth % prec % init ( ctxt , ptype , info ) if ( info /= psb_success_ ) then call psb_errpush ( info , name ) goto 9999 end if call psb_erractionrestore ( err_act ) return 9999 call psb_error_handler ( err_act ) return end subroutine psfun_d_prec_init subroutine psfun_d_prec_build ( meth , a , desc_a , info ) !! This function builds the AMG4PSBLAS preconditioner for the inner solve !! in a Rational Krylov method use psb_base_mod use amg_prec_mod implicit none class ( psfun_d_krylov ), intent ( inout ) :: meth !! Krylov method type ( psb_dspmat_type ), intent ( inout ) :: a !! Sparse matrix type ( psb_desc_type ), intent ( inout ) :: desc_a !! Descriptor for the sparse matrix integer ( psb_ipk_ ) :: info !! Result of the init call ! Local Variables integer ( psb_ipk_ ) :: err_act character ( len = 20 ) :: name name = 'd_prec_build' call psb_erractionsave ( err_act ) ! Build The Hierarchy call meth % prec % hierarchy_build ( a , desc_a , info ) if ( info /= psb_success_ ) then call psb_errpush ( info , name ) goto 9999 end if ! Build The Smoothers call meth % prec % smoothers_build ( a , desc_a , info ) if ( info /= psb_success_ ) then call psb_errpush ( info , name ) goto 9999 end if call psb_erractionrestore ( err_act ) return 9999 call psb_error_handler ( err_act ) return end subroutine psfun_d_prec_build end module psfun_d_krylov_mod","tags":"","loc":"sourcefile/psfun_d_krylov_mod.f90.html"},{"title":"psfun_dcg.F90 – PSFUN","text":"Contents Subroutines psfun_dcg_vect Source Code psfun_dcg.F90 Source Code ! BSD 3-Clause License ! ! Copyright (c) 2020, Fabio Durastante ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this !    list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! This code is based on the psb_dcg.F90 code from PSBLAS ! !                Parallel Sparse BLAS  version 3.5 !      (C) Copyright 2006-2018 !        Salvatore Filippone !        Alfredo Buttari ! !    Redistribution and use in source and binary forms, with or without !    modification, are permitted provided that the following conditions !    are met: !      1. Redistributions of source code must retain the above copyright !         notice, this list of conditions and the following disclaimer. !      2. Redistributions in binary form must reproduce the above copyright !         notice, this list of conditions, and the following disclaimer in the !         documentation and/or other materials provided with the distribution. !      3. The name of the PSBLAS group or the names of its contributors may !         not be used to endorse or promote products derived from this !         software without specific written permission. ! !    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS !    ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED !    TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR !    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE PSBLAS GROUP OR ITS CONTRIBUTORS !    BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR !    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF !    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS !    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN !    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) !    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE !    POSSIBILITY OF SUCH DAMAGE. ! ! ! File:  psb_dcg.f90 !   CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC !   C                                                                      C !   C  References:                                                         C !   C          [1] Duff, I., Marrone, M., Radicati, G., and Vittoli, C.    C !   C              Level 3 basic linear algebra subprograms for sparse     C !   C              matrices: a user level interface                        C !   C              ACM Trans. Math. Softw., 23(3), 379-401, 1997.          C !   C                                                                      C !   C                                                                      C !   C         [2]  S. Filippone, M. Colajanni                              C !   C              PSBLAS: A library for parallel linear algebra           C !   C              computation on sparse matrices                          C !   C              ACM Trans. on Math. Softw., 26(4), 527-550, Dec. 2000.  C !   C                                                                      C !   C         [3] M. Arioli, I. Duff, M. Ruiz                              C !   C             Stopping criteria for iterative solvers                  C !   C             SIAM J. Matrix Anal. Appl., Vol. 13, pp. 138-144, 1992   C !   C                                                                      C !   C                                                                      C !   C         [4] R. Barrett et al                                         C !   C             Templates for the solution of linear systems             C !   C             SIAM, 1993 !   C                                                                      C !   C                                                                      C !   CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC ! File:  psb_dcg.f90 ! ! Subroutine: psb_dcg !    This subroutine implements the Conjugate Gradient method. ! ! ! Arguments: ! !    a      -  type(psb_dspmat_type)      Input: sparse matrix containing A. !    prec   -  class(psb_dprec_type)       Input: preconditioner !    b(:)   -  real                    Input: vector containing the !                                         right hand side B !    x(:)   -  real                    Input/Output: vector containing the !                                         initial guess and final solution X. !    eps    -  real                       Input: Stopping tolerance; the iteration is !                                         stopped when the error estimate |err| <= eps !    desc_a -  type(psb_desc_type).       Input: The communication descriptor. !    info   -  integer.                   Output: Return code ! !    itmax  -  integer(optional)          Input: maximum number of iterations to be !                                         performed. !    iter   -  integer(optional)          Output: how many iterations have been !                                         performed. !                                         performed. !    err    -  real   (optional)          Output: error estimate on exit. If the !                                         denominator of the estimate is exactly !                                         0, it is changed into 1. !    itrace -  integer(optional)          Input: print an informational message !                                         with the error estimate every itrace !                                         iterations !    istop  -  integer(optional)          Input: stopping criterion, or how !                                         to estimate the error. !                                         1: err =  |r|/(|a||x|+|b|);  here the iteration is !                                            stopped when  |r| <= eps * (|a||x|+|b|) !                                         2: err =  |r|/|b|; here the iteration is !                                            stopped when  |r| <= eps * |b| !                                         where r is the (preconditioned, recursive !                                         estimate of) residual. ! ! subroutine psfun_dcg_vect ( a , prec , b , eta , zeta , x , eps , desc_a , info ,& & itmax , iter , err , itrace , istop , cond ) !! Preconditioned Conjugate Gradient for shifted system (\\eta A + \\zeta I)x = b  use psb_base_mod use psb_prec_mod use psb_d_krylov_conv_mod use psb_krylov_mod implicit none type ( psb_dspmat_type ), intent ( in ) :: a !! Distributed sparse matrix Type ( psb_desc_type ), Intent ( in ) :: desc_a !! Descriptor class ( psb_dprec_type ), intent ( inout ) :: prec !! Preconditioner type ( psb_d_vect_type ), Intent ( inout ) :: b !! Right-hand side real ( psb_dpk_ ), intent ( in ) :: eta !! \\eta of (\\eta A + \\zeta I)x = b  real ( psb_dpk_ ), intent ( in ) :: zeta !! \\zeta of (\\eta A + \\zeta I)x = b  type ( psb_d_vect_type ), Intent ( inout ) :: x !! Solution on exit, initial guess on entry Real ( psb_dpk_ ), Intent ( in ) :: eps !! Tolerance for the solution integer ( psb_ipk_ ), intent ( out ) :: info !! Flag integer ( psb_ipk_ ), Optional , Intent ( in ) :: itmax , itrace , istop !! Auxiliary parameters integer ( psb_ipk_ ), Optional , Intent ( out ) :: iter !! Final number of iteration Real ( psb_dpk_ ), Optional , Intent ( out ) :: err , cond !! Auxiliary parameters ! =   Local data real ( psb_dpk_ ), allocatable , target :: aux (:), td (:), tu (:), eig (:), ewrk (:) integer ( psb_mpk_ ), allocatable :: ibl (:), ispl (:), iwrk (:) type ( psb_d_vect_type ), allocatable , target :: wwrk (:) type ( psb_d_vect_type ), pointer :: q , p , r , z , w real ( psb_dpk_ ) :: alpha , beta , rho , rho_old , sigma , alpha_old , beta_old integer ( psb_ipk_ ) :: itmax_ , istop_ , naux , it , itx , itrace_ ,& & n_col , n_row , err_act , ieg , nspl , istebz integer ( psb_lpk_ ) :: mglob integer ( psb_ipk_ ) :: debug_level , debug_unit type ( psb_ctxt_type ) :: ctxt integer ( psb_ipk_ ) :: np , me real ( psb_dpk_ ) :: derr type ( psb_itconv_type ) :: stopdat logical :: do_cond character ( len = 20 ) :: name character ( len =* ), parameter :: methdname = 'CG' info = psb_success_ name = 'psb_dcg' call psb_erractionsave ( err_act ) debug_unit = psb_get_debug_unit () debug_level = psb_get_debug_level () ctxt = desc_a % get_context () call psb_info ( ctxt , me , np ) if (. not . allocated ( b % v )) then info = psb_err_invalid_vect_state_ call psb_errpush ( info , name ) goto 9999 endif if (. not . allocated ( x % v )) then info = psb_err_invalid_vect_state_ call psb_errpush ( info , name ) goto 9999 endif mglob = desc_a % get_global_rows () n_row = desc_a % get_local_rows () n_col = desc_a % get_local_cols () if ( present ( istop )) then istop_ = istop else istop_ = 2 endif call psb_chkvect ( mglob , lone , x % get_nrows (), lone , lone , desc_a , info ) if ( info == psb_success_ )& & call psb_chkvect ( mglob , lone , b % get_nrows (), lone , lone , desc_a , info ) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_ call psb_errpush ( info , name , a_err = 'psb_chkvect on X/B' ) goto 9999 end if naux = 4 * n_col allocate ( aux ( naux ), stat = info ) if ( info == psb_success_ ) call psb_geall ( wwrk , desc_a , info , n = 5_psb_ipk_ ) if ( info == psb_success_ ) call psb_geasb ( wwrk , desc_a , info , mold = x % v , scratch = . true .) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if p => wwrk ( 1 ) q => wwrk ( 2 ) r => wwrk ( 3 ) z => wwrk ( 4 ) w => wwrk ( 5 ) if ( present ( itmax )) then itmax_ = itmax else itmax_ = 1000 endif if ( present ( itrace )) then itrace_ = itrace else itrace_ = 0 end if do_cond = present ( cond ) if ( do_cond ) then istebz = 0 allocate ( td ( itmax_ ), tu ( itmax_ ), eig ( itmax_ ),& & ibl ( itmax_ ), ispl ( itmax_ ), iwrk ( 3 * itmax_ ), ewrk ( 4 * itmax_ ),& & stat = info ) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if end if itx = 0 alpha = dzero restart : do ! = ! =    r0 = b-Ax0 ! = if ( itx >= itmax_ ) exit restart it = 0 call psb_geaxpby ( done , b , dzero , r , desc_a , info ) ! r <- b [ x0 = 0] ! r <- r - (η A + ζ I) x : We do it in two step : r <- r - ηA, r <- r - ζ x if ( info == psb_success_ ) call psb_spmm ( - eta , a , x , done , r , desc_a , info , work = aux ) if ( info == psb_success_ ) call psb_geaxpby ( - zeta , x , done , r , desc_a , info ) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if rho = dzero call psb_init_conv ( methdname , istop_ , itrace_ , itmax_ , a , x , b , eps , desc_a , stopdat , info ) if ( info /= psb_success_ ) Then call psb_errpush ( psb_err_from_subroutine_non_ , name ) goto 9999 End If iteration : do it = it + 1 itx = itx + 1 call prec % apply ( r , z , desc_a , info , work = aux ) rho_old = rho rho = psb_gedot ( r , z , desc_a , info ) if ( it == 1 ) then call psb_geaxpby ( done , z , dzero , p , desc_a , info ) else if ( rho_old == dzero ) then if ( debug_level >= psb_debug_ext_ )& & write ( debug_unit , * ) me , ' ' , trim ( name ),& & ': CG Iteration breakdown rho' exit iteration endif beta = rho / rho_old call psb_geaxpby ( done , z , beta , p , desc_a , info ) end if ! We have here another product with a, thus we need to change it into a ! product with (η A + ζ I): q <- Ap => q <- η A p, q <- q + ζ p call psb_spmm ( eta , a , p , dzero , q , desc_a , info , work = aux ) call psb_geaxpby ( zeta , p , done , q , desc_a , info ) sigma = psb_gedot ( p , q , desc_a , info ) if ( sigma == dzero ) then if ( debug_level >= psb_debug_ext_ )& & write ( debug_unit , * ) me , ' ' , trim ( name ),& & ': CG Iteration breakdown sigma' exit iteration endif alpha_old = alpha alpha = rho / sigma if ( do_cond ) then istebz = istebz + 1 if ( istebz == 1 ) then td ( istebz ) = done / alpha else td ( istebz ) = done / alpha + beta / alpha_old tu ( istebz - 1 ) = sqrt ( beta ) / alpha_old end if end if call psb_geaxpby ( alpha , p , done , x , desc_a , info ) call psb_geaxpby ( - alpha , q , done , r , desc_a , info ) if ( psb_check_conv ( methdname , itx , x , r , desc_a , stopdat , info )) exit restart if ( info /= psb_success_ ) Then call psb_errpush ( psb_err_from_subroutine_non_ , name ) goto 9999 End If end do iteration end do restart if ( do_cond ) then if ( me == psb_root_ ) then #if defined(HAVE_LAPACK) call dstebz ( 'A' , 'E' , istebz , dzero , dzero , 0 , 0 , - done , td , tu ,& & ieg , nspl , eig , ibl , ispl , ewrk , iwrk , info ) if ( info < 0 ) then call psb_errpush ( psb_err_from_subroutine_ai_ , name ,& & a_err = 'dstebz' , i_err = ( / info / )) info = psb_err_from_subroutine_ai_ goto 9999 end if cond = eig ( ieg ) / eig ( 1 ) #else cond = dzero #endif info = psb_success_ end if call psb_bcast ( ctxt , cond ) end if call psb_end_conv ( methdname , itx , desc_a , stopdat , info , derr , iter ) if ( present ( err )) err = derr if ( info == psb_success_ ) call psb_gefree ( wwrk , desc_a , info ) if ( info == psb_success_ ) deallocate ( aux , stat = info ) if ( info /= psb_success_ ) then call psb_errpush ( info , name ) goto 9999 end if call psb_erractionrestore ( err_act ) return 9999 call psb_error_handler ( err_act ) return end subroutine psfun_dcg_vect","tags":"","loc":"sourcefile/psfun_dcg.f90.html"},{"title":"psfun_d_lanczos.f90 – PSFUN","text":"This file depends on sourcefile~~psfun_d_lanczos.f90~~EfferentGraph sourcefile~psfun_d_lanczos.f90 psfun_d_lanczos.f90 sourcefile~psfun_d_serial_mod.f90 psfun_d_serial_mod.F90 sourcefile~psfun_d_lanczos.f90->sourcefile~psfun_d_serial_mod.f90 sourcefile~psfun_d_krylov_mod.f90 psfun_d_krylov_mod.F90 sourcefile~psfun_d_lanczos.f90->sourcefile~psfun_d_krylov_mod.f90 sourcefile~psfun_d_krylov_mod.f90->sourcefile~psfun_d_serial_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules psfun_d_lanczos_mod Source Code psfun_d_lanczos.f90 Source Code ! BSD 3-Clause License ! ! Copyright (c) 2020, Fabio Durastante ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this !    list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. submodule ( psfun_d_krylov_mod ) psfun_d_lanczos_mod !! This modules implements the variant of the Lanczos method for the !! computation of f(A)b. contains module subroutine psfun_d_lanczos ( fun , a , desc_a , y , x , eps , info , itmax , itrace , istop , iter , err , res ) !! Simple polynomial method based on the Lanczos orthogonalization procedure, !! the method builds a basis V_k for the Krylov subspace !! !! \\begin{equation*} !! \\mathcal{K}_k(A,x) = \\{x,Ax,\\ldots,A&#94;{k-1}x\\}, !! \\end{equation*} !! !! and approximates y = f(\\alpha A)x \\approx \\beta_1 V_k f(T_k) e_1,for !! \\beta_1 = \\|x\\|_2, e_1 the first vector of the canonical !! base of \\mathbb{R}&#94;k, and T_k the Symmetric tridiagonal !! matrix given by T_k = V_k&#94;T A V_k. use psb_base_mod use psfun_d_serial_mod use psb_d_krylov_conv_mod , only : log_header , log_conv , log_end implicit none type ( psfun_d_serial ), intent ( inout ) :: fun !! Function object type ( psb_dspmat_type ), intent ( in ) :: a !! Distribute sparse matrix type ( psb_desc_type ), intent ( in ) :: desc_a !! Descriptor for the sparse matrix type ( psb_d_vect_type ), intent ( inout ) :: y !! Output vector type ( psb_d_vect_type ), intent ( inout ) :: x !! Input vector real ( psb_dpk_ ), intent ( in ) :: eps !! Requested tolerance integer ( psb_ipk_ ), intent ( out ) :: info !! Output flag integer ( psb_ipk_ ), optional , intent ( in ) :: itmax !! Maximum number of iteration integer ( psb_ipk_ ), optional , intent ( in ) :: itrace !! Trace for logoutput integer ( psb_ipk_ ), optional , intent ( in ) :: istop !! Stop criterion integer ( psb_ipk_ ), optional , intent ( out ) :: iter !! Number of iteration real ( psb_dpk_ ), optional , intent ( out ) :: err !! Last estimate error real ( psb_dpk_ ), optional , allocatable , intent ( out ) :: res (:) !! Vector of the residuals !Local Variables integer ( psb_ipk_ ) :: litmax , itrace_ , istop_ integer ( psb_lpk_ ) :: mglob integer ( psb_ipk_ ) :: n_row , n_col , nl , naux , itx , i , k real ( psb_dpk_ ) :: scaling !Variables of possible large size: real ( psb_dpk_ ), allocatable :: aux (:) real ( psb_dpk_ ), allocatable :: t (:,:), rs (:), e (:), yk (:) type ( psb_d_vect_type ), allocatable :: v (:) type ( psb_d_vect_type ) :: w , xt ! Error log real ( psb_dpk_ ) :: deps , errden , errnum , derr integer ( psb_ipk_ ) :: err_act type ( psb_ctxt_type ) :: ctxt integer ( psb_ipk_ ) :: iam , np character ( len = 20 ) :: name character ( len = 60 ) :: methdname ! Information on the distributed environment info = psb_success_ name = 'LANCZOS' methdname = trim ( name ) // trim ( \"+\" ) // trim ( fun % fname ) // trim ( \"+\" ) // trim ( fun % variant ) call psb_erractionsave ( err_act ) ctxt = desc_a % get_context () call psb_info ( ctxt , iam , np ) mglob = desc_a % get_global_rows () n_row = desc_a % get_local_rows () n_col = desc_a % get_local_cols () ! Select the stop-criterion if ( present ( istop )) then istop_ = istop else istop_ = 1 endif if (( istop_ < 1 ). or .( istop_ > 2 ) ) then info = psb_err_invalid_istop_ err = info call psb_errpush ( info , name , i_err = ( / istop_ / )) goto 9999 endif ! Maximum number of iterations if ( present ( itmax )) then litmax = itmax else litmax = 200 endif nl = litmax naux = 4 * n_col ! What do i print? if ( present ( itrace )) then itrace_ = itrace else itrace_ = 0 end if ! Chek sanity of the inputs both on the local and the global if (. not . allocated ( x % v )) then info = psb_err_invalid_vect_state_ call psb_errpush ( info , name ) goto 9999 endif if (. not . allocated ( y % v )) then info = psb_err_invalid_vect_state_ call psb_errpush ( info , name ) goto 9999 endif call psb_chkvect ( mglob , lone , x % get_nrows (), lone , lone , desc_a , info ) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_ call psb_errpush ( info , name , a_err = 'psb_chkvect on X' ) goto 9999 end if call psb_chkvect ( mglob , lone , y % get_nrows (), lone , lone , desc_a , info ) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_ call psb_errpush ( info , name , a_err = 'psb_chkvect on Y' ) goto 9999 end if ! Allocate memory for the Krylov basis and the auxiliary quantities allocate ( aux ( naux ), t ( nl + 1 , nl + 1 ), rs ( nl + 1 ), stat = info ) if ( info == psb_success_ ) call psb_geall ( v , desc_a , info , n = nl + 1 ) if ( info == psb_success_ ) call psb_geall ( w , desc_a , info ) if ( info == psb_success_ ) call psb_geall ( xt , desc_a , info ) if ( info == psb_success_ ) call psb_geasb ( v , desc_a , info , mold = x % v ) if ( info == psb_success_ ) call psb_geasb ( w , desc_a , info , mold = x % v ) if ( info == psb_success_ ) call psb_geasb ( xt , desc_a , info , mold = x % v ) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if ! We use the scaling in the computation of the Krylov subspace scaling = fun % scaling call fun % set ( \"SCALING\" , done , info ) ! LogVariables errnum = dzero errden = done deps = eps ! Start the iteration if (( itrace_ > 0 ). and .( iam == 0 )) call log_header ( methdname ) ! Abbreviated initial iteration step call psb_geaxpby ( done , x , dzero , v ( 1 ), desc_a , info ) ! v(1) <--- x if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if rs ( 1 ) = psb_genrm2 ( v ( 1 ), desc_a , info ) ! rs(1) = ||v(1)||_2 rs ( 2 :) = dzero if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if call v ( 1 )% scal ( done / rs ( 1 )) !v(1) = v(1)/||v(1)||_2 call psb_spmm ( done , a , v ( 1 ), dzero , w , desc_a , info ) ! w = A v(1) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if t ( 1 , 1 ) = psb_gedot ( w , v ( 1 ), desc_a , info ) ! t(1,1) = w'*v(1) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if ! Inizialize residual vector ! write(*,'(\"t(1,1) =\",f8.2)')t(1,1) call psb_geaxpby ( - t ( 1 , 1 ), v ( 1 ), done , w , desc_a , info ) ! w = w - t(1,1)*v(1) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if itx = 0 lanczoscycle : do i = 2 , nl , 1 itx = itx + 1 t ( i - 1 , i ) = psb_genrm2 ( w , desc_a , info ) ! t(i-1,i) = ||w|| (upper diagonal) t ( i , i - 1 ) = t ( i - 1 , i ) ! write(*,'(\"t(\",i2,i2,\") =\",f8.2)')i,i-1,t(i,i-1) ! write(*,'(\"t(\",i2,i2,\") =\",f8.2)')i-1,i,t(i-1,i) if ( abs ( t ( i - 1 , i )) < 1e-16_psb_dpk_ ) then ! We have reached the limit on the expansion of the Krylov space ! exit and assemble solution: early termination ! write(psb_out_unit,'(\"Early Termination\")') exit lanczoscycle end if call psb_geaxpby ( 1 / t ( i - 1 , i ), w , dzero , v ( i ), desc_a , info ) ! v(i) = w/t(i-1,i) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if call psb_spmm ( done , a , v ( i ), dzero , w , desc_a , info ) ! w = A v(i) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if t ( i , i ) = psb_gedot ( w , v ( i ), desc_a , info ) ! write(*,'(\"t(\",i2,i2\") =\",f8.2)')i,i,t(1,1) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if call psb_geaxpby ( - t ( i , i ), v ( i ), done , w , desc_a , info ) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if call psb_geaxpby ( - t ( i - 1 , i ), v ( i - 1 ), done , w , desc_a , info ) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if ! A posteriori error estimate: ! This is the default a posteriori-error estimate, it costs the computation ! of the matrix function at each iteration to use the computed values if ( istop_ == 1 ) then ! ! build y and then compute the residual as ! rs(j) = \\| x \\|_2 t_{i,i-1} | e_{i-1}&#94;T f(t_{i-1}) e_1 | ! allocate ( e ( i - 1 ), stat = info ) if ( info /= 0 ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if e (:) = dzero allocate ( yk ( i - 1 ), stat = info ) if ( info /= 0 ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if e ( 1 ) = done call fun % apply ( t ( 1 : i - 1 , 1 : i - 1 ), yk , e , info ) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if errnum = rs ( 1 ) * t ( i , i - 1 ) * abs ( yk ( i - 1 ) ); errden = norm2 ( yk ) rs ( i ) = errnum / errden ! log of the error estimate if ( itrace_ > 0 ) & & call log_conv ( methdname , iam , itx , itrace_ , errnum , errden , deps ) if ( allocated ( e )) deallocate ( e , stat = info ) if ( info /= 0 ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if ! Check convergence if ( rs ( i ) < deps ) then exit lanczoscycle else if ( allocated ( yk )) deallocate ( yk , stat = info ) if ( info /= 0 ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if end if end if end do lanczoscycle ! ! Assemble the final solution ! if (. not . allocated ( yk )) then ! First we look if we have arrived here having not used an a posteriori ! error estimate, and thus not having computed the solution in the Krylov ! subspace. allocate ( e ( itx - 1 ), stat = info ) if ( info /= 0 ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if e (:) = dzero allocate ( yk ( itx - 1 ), stat = info ) if ( info /= 0 ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if e ( 1 ) = done call fun % apply ( t ( 1 : itx - 1 , 1 : itx - 1 ), yk , e , info ) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if if ( allocated ( e )) deallocate ( e , stat = info ) if ( info /= 0 ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if end if ! Final Log call log_end ( methdname , iam , itx , itrace_ , errnum , errden , deps , err = derr , iter = iter ) if ( present ( err )) err = derr if ( present ( res )) then allocate ( res ( itx + 1 ), stat = info ) res ( 1 : itx ) = rs ( 1 : itx ) res ( itx + 1 ) = derr end if call psb_geaxpby ( yk ( 1 ), v ( 1 ), dzero , y , desc_a , info ) do i = 2 , itx - 1 , 1 call psb_geaxpby ( yk ( i ), v ( i ), done , y , desc_a , info ) end do call y % scal ( rs ( 1 )) ! Set back the scaling call fun % set ( \"SCALING\" , scaling , info ) ! Free the memory if ( info == psb_success_ ) call psb_gefree ( v , desc_a , info ) if ( info == psb_success_ ) call psb_gefree ( w , desc_a , info ) if ( info == psb_success_ ) call psb_gefree ( xt , desc_a , info ) if ( info == psb_success_ ) deallocate ( aux , t , rs , stat = info ) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if ! Close and return call psb_erractionrestore ( err_act ) return 9999 call psb_error_handler ( err_act ) return end subroutine psfun_d_lanczos end submodule","tags":"","loc":"sourcefile/psfun_d_lanczos.f90.html"},{"title":"psfun_d_arnoldi.f90 – PSFUN","text":"This file depends on sourcefile~~psfun_d_arnoldi.f90~~EfferentGraph sourcefile~psfun_d_arnoldi.f90 psfun_d_arnoldi.f90 sourcefile~psfun_d_serial_mod.f90 psfun_d_serial_mod.F90 sourcefile~psfun_d_arnoldi.f90->sourcefile~psfun_d_serial_mod.f90 sourcefile~psfun_d_krylov_mod.f90 psfun_d_krylov_mod.F90 sourcefile~psfun_d_arnoldi.f90->sourcefile~psfun_d_krylov_mod.f90 sourcefile~psfun_d_krylov_mod.f90->sourcefile~psfun_d_serial_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules psfun_d_arnoldi_mod Source Code psfun_d_arnoldi.f90 Source Code ! BSD 3-Clause License ! ! Copyright (c) 2020, Fabio Durastante ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this !    list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. submodule ( psfun_d_krylov_mod ) psfun_d_arnoldi_mod !! This modules implements the variant of the Arnoldi method for the !! computation of f(A)b. contains module subroutine psfun_d_arnoldi ( fun , a , desc_a , y , x , eps , info , itmax , itrace , istop , iter , err , res ) !! Simple polynomial method based on the Arnoldi orthogonalization procedure, !! the method builds a basis V_k for the Krylov subspace ! !! \\begin{equation*} !! \\mathcal{K}_k(A,x) = \\{x,Ax,\\ldots,A&#94;{k-1}x\\}, !! \\end{equation*} ! !! and approximates y = f(\\alpha A)x \\approx \\beta_1 V_k f(H_k) e_1,for !! \\beta_1 = \\|x\\|_2, e_1 the first vector of the canonical !! base of \\mathbb{R}&#94;k, and H_k the Hessemberg matrix given !! by H_k = V_k&#94;T A V_k. use psb_base_mod use psfun_d_serial_mod use psb_d_krylov_conv_mod , only : log_header , log_conv , log_end implicit none type ( psfun_d_serial ), intent ( inout ) :: fun ! Function object type ( psb_dspmat_type ), intent ( in ) :: a ! Distribute sparse matrix type ( psb_desc_type ), intent ( in ) :: desc_a ! Descriptor for the sparse matrix type ( psb_d_vect_type ), intent ( inout ) :: y ! Output vector type ( psb_d_vect_type ), intent ( inout ) :: x ! Input vector real ( psb_dpk_ ), intent ( in ) :: eps ! Requested tolerance integer ( psb_ipk_ ), intent ( out ) :: info ! Output flag integer ( psb_ipk_ ), optional , intent ( in ) :: itmax ! Maximum number of iteration integer ( psb_ipk_ ), optional , intent ( in ) :: itrace ! Trace for logoutput integer ( psb_ipk_ ), optional , intent ( in ) :: istop ! Stop criterion integer ( psb_ipk_ ), optional , intent ( out ) :: iter ! Number of iteration real ( psb_dpk_ ), optional , intent ( out ) :: err ! Last estimate error real ( psb_dpk_ ), optional , allocatable , intent ( out ) :: res (:) ! Vector of the residuals !Local Variables integer ( psb_ipk_ ) :: litmax , itrace_ , istop_ integer ( psb_lpk_ ) :: mglob integer ( psb_ipk_ ) :: n_row , n_col , nl , naux , itx , i , k real ( psb_dpk_ ) :: scaling !Variables of possible large size: real ( psb_dpk_ ), allocatable :: aux (:) real ( psb_dpk_ ), allocatable :: h (:,:), rs (:), e (:), yk (:) type ( psb_d_vect_type ), allocatable :: v (:) type ( psb_d_vect_type ) :: w , xt ! Error log real ( psb_dpk_ ) :: deps , errden , errnum , derr integer ( psb_ipk_ ) :: err_act type ( psb_ctxt_type ) :: ctxt integer ( psb_ipk_ ) :: iam , np character ( len = 20 ) :: name character ( len = 60 ) :: methdname ! debug ! real(psb_dpk_), allocatable    :: va(:) ! Information on the distributed environment info = psb_success_ name = 'ARNOLDI' methdname = trim ( name ) // trim ( \"+\" ) // trim ( fun % fname ) // trim ( \"+\" ) // trim ( fun % variant ) call psb_erractionsave ( err_act ) ctxt = desc_a % get_context () call psb_info ( ctxt , iam , np ) mglob = desc_a % get_global_rows () n_row = desc_a % get_local_rows () n_col = desc_a % get_local_cols () ! Select the stop-criterion if ( present ( istop )) then istop_ = istop else istop_ = 1 endif if (( istop_ < 1 ). or .( istop_ > 2 ) ) then info = psb_err_invalid_istop_ err = info call psb_errpush ( info , name , i_err = ( / istop_ / )) goto 9999 endif ! Maximum number of iterations if ( present ( itmax )) then litmax = itmax else litmax = 200 endif nl = litmax naux = 4 * n_col ! What do i print? if ( present ( itrace )) then itrace_ = itrace else itrace_ = 0 end if ! Chek sanity of the inputs both on the local and the global if (. not . allocated ( x % v )) then info = psb_err_invalid_vect_state_ call psb_errpush ( info , name ) goto 9999 endif if (. not . allocated ( y % v )) then info = psb_err_invalid_vect_state_ call psb_errpush ( info , name ) goto 9999 endif call psb_chkvect ( mglob , lone , x % get_nrows (), lone , lone , desc_a , info ) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_ call psb_errpush ( info , name , a_err = 'psb_chkvect on X' ) goto 9999 end if call psb_chkvect ( mglob , lone , y % get_nrows (), lone , lone , desc_a , info ) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_ call psb_errpush ( info , name , a_err = 'psb_chkvect on Y' ) goto 9999 end if ! Allocate memory for the Krylov basis and the auxiliary quantities allocate ( aux ( naux ), h ( nl + 1 , nl + 1 ), rs ( nl + 1 ), stat = info ) if ( info == psb_success_ ) call psb_geall ( v , desc_a , info , n = nl + 1 ) if ( info == psb_success_ ) call psb_geall ( w , desc_a , info ) if ( info == psb_success_ ) call psb_geall ( xt , desc_a , info ) if ( info == psb_success_ ) call psb_geasb ( v , desc_a , info , mold = x % v ) if ( info == psb_success_ ) call psb_geasb ( w , desc_a , info , mold = x % v ) if ( info == psb_success_ ) call psb_geasb ( xt , desc_a , info , mold = x % v ) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if ! We use the scaling in the computation of the Krylov subspace scaling = fun % scaling call fun % set ( \"SCALING\" , done , info ) ! LogVariables errnum = dzero errden = done deps = eps ! Start the iteration if (( itrace_ > 0 ). and .( iam == 0 )) call log_header ( methdname ) call psb_geaxpby ( done , x , dzero , v ( 1 ), desc_a , info ) ! v(1) = x if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if rs ( 1 ) = psb_genrm2 ( v ( 1 ), desc_a , info ) ! rs(1) = ||v(1)||_2 rs ( 2 :) = dzero if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if call v ( 1 )% scal ( done / rs ( 1 )) !v(1) = v(1)/||v(1)||_2 itx = 0 arnoldicycle : do i = 2 , nl , 1 itx = itx + 1 ! write(*,'(\"Iteration \",i2)')i call psb_spmm ( scaling , a , v ( i - 1 ), dzero , w , desc_a , info , work = aux ) ! w = A v(i) ! va = w%get_vect() ! write(*,'(\"w(1) =\",f8.2)')va(1) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if do k = 1 , i - 1 , 1 h ( k , i - 1 ) = psb_gedot ( v ( k ), w , desc_a , info ) !h_{k,i-1}=w&#94;T*v(k) ! write(*,'(\"h(\",i2,\",\"i2\") =\",f8.2)')k,i-1,h(k,i-1) call psb_geaxpby ( - h ( k , i - 1 ), v ( k ), done , w , desc_a , info ) !w = w - h_{k,i-1}v(k) end do h ( i , i - 1 ) = psb_genrm2 ( w , desc_a , info ) !h_{i,i-1} = ||w||_2 ! write(*,'(\"h(\",i2,\",\"i2\") =\",f8.2)')i,i-1,h(i,i-1) call psb_geaxpby ( done / h ( i , i - 1 ), w , dzero , v ( i ), desc_a , info ) !v(i) = w/h_{i,i-1} ! A posteriori error estimate: ! This is the default a posteriori-error estimate, it costs the computation ! of the matrix function at each iteration to use the computed values if ( istop_ == 1 ) then ! ! build y and then compute the residual as ! rs(j) = \\| x \\|_2 h_{i,i-1} | e_{i-1}&#94;T f(H_{i-1}) e_1 | ! allocate ( e ( i - 1 ), stat = info ) if ( info /= 0 ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if e (:) = dzero allocate ( yk ( i - 1 ), stat = info ) if ( info /= 0 ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if e ( 1 ) = done call fun % apply ( h ( 1 : i - 1 , 1 : i - 1 ), yk , e , info ) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if errnum = rs ( 1 ) * h ( i , i - 1 ) * abs ( yk ( i - 1 ) ); errden = norm2 ( yk ) rs ( i ) = errnum / errden ! log of the error estimate if ( itrace_ > 0 ) & & call log_conv ( methdname , iam , itx , itrace_ , errnum , errden , deps ) if ( allocated ( e )) deallocate ( e , stat = info ) if ( info /= 0 ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if ! Check convergence if ( rs ( i ) < deps ) then exit arnoldicycle else if ( allocated ( yk )) deallocate ( yk , stat = info ) if ( info /= 0 ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if end if end if end do arnoldicycle ! ! Assemble the final solution ! if (. not . allocated ( yk )) then ! First we look if we have arrived here having not used an a posteriori ! error estimate, and thus not having computed the solution in the Krylov ! subspace. allocate ( e ( itx - 1 ), stat = info ) if ( info /= 0 ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if e (:) = dzero allocate ( yk ( itx - 1 ), stat = info ) if ( info /= 0 ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if e ( 1 ) = done call fun % apply ( h ( 1 : itx - 1 , 1 : itx - 1 ), yk , e , info ) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if if ( allocated ( e )) deallocate ( e , stat = info ) if ( info /= 0 ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if end if ! Final Log call log_end ( methdname , iam , itx , itrace_ , errnum , errden , deps , err = derr , iter = iter ) if ( present ( err )) err = derr if ( present ( res )) then allocate ( res ( itx + 1 ), stat = info ) res ( 1 : itx ) = rs ( 1 : itx ) res ( itx + 1 ) = derr end if call psb_geaxpby ( yk ( 1 ), v ( 1 ), dzero , y , desc_a , info ) do i = 2 , itx - 1 , 1 call psb_geaxpby ( yk ( i ), v ( i ), done , y , desc_a , info ) end do call y % scal ( rs ( 1 )) ! Set back the scaling call fun % set ( \"SCALING\" , scaling , info ) ! Free the memory if ( info == psb_success_ ) call psb_gefree ( v , desc_a , info ) if ( info == psb_success_ ) call psb_gefree ( w , desc_a , info ) if ( info == psb_success_ ) call psb_gefree ( xt , desc_a , info ) if ( info == psb_success_ ) deallocate ( aux , h , rs , stat = info ) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if ! Close and return call psb_erractionrestore ( err_act ) return 9999 call psb_error_handler ( err_act ) return end subroutine psfun_d_arnoldi end submodule","tags":"","loc":"sourcefile/psfun_d_arnoldi.f90.html"},{"title":"psfun_d_sai.f90 – PSFUN","text":"This file depends on sourcefile~~psfun_d_sai.f90~~EfferentGraph sourcefile~psfun_d_sai.f90 psfun_d_sai.f90 sourcefile~psfun_d_serial_mod.f90 psfun_d_serial_mod.F90 sourcefile~psfun_d_sai.f90->sourcefile~psfun_d_serial_mod.f90 sourcefile~psfun_d_krylov_mod.f90 psfun_d_krylov_mod.F90 sourcefile~psfun_d_sai.f90->sourcefile~psfun_d_krylov_mod.f90 sourcefile~psfun_krylov_mod.f90 psfun_krylov_mod.f90 sourcefile~psfun_d_sai.f90->sourcefile~psfun_krylov_mod.f90 sourcefile~psfun_d_krylov_mod.f90->sourcefile~psfun_d_serial_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules psfun_d_sai_mod Source Code psfun_d_sai.f90 Source Code ! BSD 3-Clause License ! ! Copyright (c) 2020, Fabio Durastante ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this !    list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. submodule ( psfun_d_krylov_mod ) psfun_d_sai_mod !! This modules implements the variant of the Shitf-And-Invert method for the !! computation of f(A)b. contains module subroutine psfun_d_saiarnoldi ( fun , a , kryl , prec , tau , desc_a , & & initmax , initrace , inistop , y , x , eps , info , itmax , itrace , istop , iter , err , res ) !! Shift-and-invert method based on the Arnoldi orthogonalization procedure !! the method builds a basis  V_k  for the shifted Krylov subspace !! !! \\begin{equation*} !! \\mathcal{K}_( (A + \\tau I)&#94;{-1},x ) = \\{ x,(A + \\tau I)&#94;{-1}x,\\ldots,(A + \\tau I)&#94;{k-1}x\\}, !! \\end{equation*} !! !! and approximate  y = f(\\alpha A)x \\approx \\beta_1 f((H_k&#94;{-1} - \\tau I)&#94;{-1}) e_1,for !! \\beta_1 = \\|x\\|_2, e_1 the first vector of the canonical !! base of \\mathbb{R}&#94;k, and H_k the Hessemberg matrix given !! by the projection of A into the subspace \\mathcal{K}_( (A + \\tau I)&#94;{-1},x ). !! !! To  march the algorithm one needs to solve at each step a shifted linear !! system for which we employ the routines from [[psfun_krylov_mod]] and the !! preconditioners from AMG4PSBLAS. use psb_base_mod use psfun_d_serial_mod use psfun_krylov_mod use amg_prec_mod use psb_d_krylov_conv_mod , only : log_header , log_conv , log_end implicit none type ( psfun_d_serial ), intent ( inout ) :: fun !! Function object type ( psb_dspmat_type ), intent ( in ) :: a !! Distribute sparse matrix character ( len =* ), intent ( in ) :: kryl !! Krylov method for the solution of inner systems type ( amg_dprec_type ), intent ( inout ) :: prec !! Preconditioner for the inner method real ( psb_dpk_ ), intent ( in ) :: tau !! Shift parameter of the method type ( psb_desc_type ), intent ( in ) :: desc_a !! Descriptor for the sparse matrix type ( psb_d_vect_type ), intent ( inout ) :: y !! Output vector type ( psb_d_vect_type ), intent ( inout ) :: x !! Input vector integer ( psb_ipk_ ), intent ( in ) :: initmax !! Maximum number of iteration (inner method) integer ( psb_ipk_ ), intent ( in ) :: initrace !! Trace for logoutput (inner method) integer ( psb_ipk_ ), intent ( in ) :: inistop !! Stop criterion (inner method) real ( psb_dpk_ ), intent ( in ) :: eps !! Requested tolerance integer ( psb_ipk_ ), intent ( out ) :: info !! Output flag integer ( psb_ipk_ ), optional , intent ( in ) :: itmax !! Maximum number of iteration integer ( psb_ipk_ ), optional , intent ( in ) :: itrace !! Trace for logoutput integer ( psb_ipk_ ), optional , intent ( in ) :: istop !! Stop criterion integer ( psb_ipk_ ), optional , intent ( out ) :: iter !! Number of iteration real ( psb_dpk_ ), optional , intent ( out ) :: err !! Last estimate error real ( psb_dpk_ ), optional , allocatable , intent ( out ) :: res (:) !! Vector of the residuals !Local Variables integer ( psb_ipk_ ) :: litmax , itrace_ , istop_ integer ( psb_lpk_ ) :: mglob integer ( psb_ipk_ ) :: n_row , n_col , nl , naux , itx , i , k , j , lwork real ( psb_dpk_ ) :: scaling !Variables of possible large size: real ( psb_dpk_ ), allocatable :: aux (:) real ( psb_dpk_ ), allocatable :: h (:,:), rs (:), e (:), yk (:), hcomp (:,:) integer ( psb_ipk_ ), allocatable :: work (:), ipiv (:) type ( psb_d_vect_type ), allocatable :: v (:) type ( psb_d_vect_type ) :: w , xt ! Error log real ( psb_dpk_ ) :: deps , errden , errnum , derr integer ( psb_ipk_ ) :: err_act type ( psb_ctxt_type ) :: ctxt integer ( psb_ipk_ ) :: iam , np character ( len = 20 ) :: name character ( len = 60 ) :: methdname ! debug ! real(psb_dpk_), allocatable    :: va(:) ! Information on the distributed environment info = psb_success_ name = 'SAIARNOLDI' methdname = trim ( name ) // trim ( \"+\" ) // trim ( fun % fname ) // trim ( \"+\" ) // trim ( fun % variant ) call psb_erractionsave ( err_act ) ctxt = desc_a % get_context () call psb_info ( ctxt , iam , np ) mglob = desc_a % get_global_rows () n_row = desc_a % get_local_rows () n_col = desc_a % get_local_cols () ! Select the stop-criterion if ( present ( istop )) then istop_ = istop else istop_ = 1 endif if (( istop_ < 1 ). or .( istop_ > 2 ) ) then info = psb_err_invalid_istop_ err = info call psb_errpush ( info , name , i_err = ( / istop_ / )) goto 9999 endif ! Maximum number of iterations if ( present ( itmax )) then litmax = itmax else litmax = 200 endif nl = litmax naux = 4 * n_col ! What do i print? if ( present ( itrace )) then itrace_ = itrace else itrace_ = 0 end if ! Chek sanity of the inputs both on the local and the global if (. not . allocated ( x % v )) then info = psb_err_invalid_vect_state_ call psb_errpush ( info , name ) goto 9999 endif if (. not . allocated ( y % v )) then info = psb_err_invalid_vect_state_ call psb_errpush ( info , name ) goto 9999 endif call psb_chkvect ( mglob , lone , x % get_nrows (), lone , lone , desc_a , info ) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_ call psb_errpush ( info , name , a_err = 'psb_chkvect on X' ) goto 9999 end if call psb_chkvect ( mglob , lone , y % get_nrows (), lone , lone , desc_a , info ) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_ call psb_errpush ( info , name , a_err = 'psb_chkvect on Y' ) goto 9999 end if ! Allocate memory for the Krylov basis and the auxiliary quantities allocate ( aux ( naux ), h ( nl + 1 , nl + 1 ), rs ( nl + 1 ), stat = info ) if ( info == psb_success_ ) call psb_geall ( v , desc_a , info , n = nl + 1 ) if ( info == psb_success_ ) call psb_geall ( w , desc_a , info ) if ( info == psb_success_ ) call psb_geall ( xt , desc_a , info ) if ( info == psb_success_ ) call psb_geasb ( v , desc_a , info , mold = x % v ) if ( info == psb_success_ ) call psb_geasb ( w , desc_a , info , mold = x % v ) if ( info == psb_success_ ) call psb_geasb ( xt , desc_a , info , mold = x % v ) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if ! We use the scaling in the computation of the Krylov subspace scaling = fun % scaling call fun % set ( \"SCALING\" , done , info ) ! LogVariables errnum = dzero errden = done deps = eps ! Start the iteration if (( itrace_ > 0 ). and .( iam == 0 )) call log_header ( methdname ) call psb_geaxpby ( done , x , dzero , v ( 1 ), desc_a , info ) ! v(1) = x if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if rs ( 1 ) = psb_genrm2 ( v ( 1 ), desc_a , info ) ! rs(1) = ||v(1)||_2 rs ( 2 :) = dzero if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if call v ( 1 )% scal ( done / rs ( 1 )) !v(1) = v(1)/||v(1)||_2 itx = 0 arnoldicycle : do i = 2 , nl , 1 itx = itx + 1 ! write(*,'(\"Iteration \",i2)')i call psfun_dkrylov_vect ( kryl , a , prec , v ( i - 1 ), done , tau , w , eps , desc_a , info ,& & itmax = initmax , itrace = initrace , istop = inistop ) ! w = (A+ \\tau I)&#94;{-1} v(i-1) ! va = w%get_vect() ! write(*,'(\"w(1) =\",f8.2)')va(1) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if do k = 1 , i - 1 , 1 h ( k , i - 1 ) = psb_gedot ( v ( k ), w , desc_a , info ) !h_{k,i-1}=w&#94;T*v(k) ! write(*,'(\"h(\",i2,\",\"i2\") =\",f8.2)')k,i-1,h(k,i-1) call psb_geaxpby ( - h ( k , i - 1 ), v ( k ), done , w , desc_a , info ) !w = w - h_{k,i-1}v(k) end do h ( i , i - 1 ) = psb_genrm2 ( w , desc_a , info ) !h_{i,i-1} = ||w||_2 ! write(*,'(\"h(\",i2,\",\"i2\") =\",f8.2)')i,i-1,h(i,i-1) call psb_geaxpby ( done / h ( i , i - 1 ), w , dzero , v ( i ), desc_a , info ) !v(i) = w/h_{i,i-1} ! A posteriori error estimate: ! This is the default a posteriori-error estimate, it costs the computation ! of the matrix function at each iteration to use the computed values if ( istop_ == 1 ) then ! ! build y and then compute the residual as ! rs(j) = \\| x \\|_2 h_{i,i-1} | e_{i-1}&#94;T f((H_{i-1}&#94;-1 - tau I)&#94;-1) e_1 | ! allocate ( e ( i - 1 ), stat = info ) if ( info /= 0 ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if e (:) = dzero allocate ( yk ( i - 1 ), stat = info ) if ( info /= 0 ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if ! We need to use Lapack to compute the inverse of the matrix on which ! we compute the matrix function allocate ( hcomp ( i - 1 , i - 1 ), ipiv ( i - 1 ), work ( 1 ), stat = info ) if ( info /= 0 ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if hcomp = h ( 1 : i - 1 , 1 : i - 1 ) ! We compute the inverse of hcomp, this is done in three steps: ! 1) Compute the hcomp = P*L*U factorization call dgetrf ( i - 1 , i - 1 , hcomp ( 1 : i - 1 , 1 : i - 1 ), i - 1 , ipiv , info ) if ( info /= 0 ) then call psb_errpush ( info , name // \"dgetrf\" ) goto 9999 end if ! 2) Compute the workspace needed by the inversion routine call dgetri ( i - 1 , hcomp ( 1 : i - 1 , 1 : i - 1 ), i - 1 , ipiv , work , - 1 , info ) if ( info /= 0 ) then call psb_errpush ( info , name // \"dgetri1\" ) goto 9999 end if lwork = work ( 1 ) deallocate ( work ) allocate ( work ( lwork ), stat = info ) if ( info /= 0 ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if ! 3) Actually compute the inverse call dgetri ( i - 1 , hcomp ( 1 : i - 1 , 1 : i - 1 ), i - 1 , ipiv , work , lwork , info ) if ( info /= 0 ) then call psb_errpush ( info , name // \"dgetri2\" ) goto 9999 end if ! Now we apply the \"back\" Shift do j = 1 , i - 1 , i hcomp ( j , j ) = hcomp ( j , j ) - tau end do ! And we can now apply the matrix function: e ( 1 ) = done call fun % apply ( hcomp ( 1 : i - 1 , 1 : i - 1 ), yk , e , info ) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if errnum = rs ( 1 ) * h ( i , i - 1 ) * abs ( yk ( i - 1 ) ); errden = norm2 ( yk ) rs ( i ) = errnum / errden ! And deallocate auxiliary variables deallocate ( hcomp , ipiv , work , stat = info ) if ( info /= 0 ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if ! log of the error estimate if ( itrace_ > 0 ) & & call log_conv ( methdname , iam , itx , itrace_ , errnum , errden , deps ) if ( allocated ( e )) deallocate ( e , stat = info ) if ( info /= 0 ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if ! Check convergence if ( rs ( i ) < deps ) then exit arnoldicycle else if ( allocated ( yk )) deallocate ( yk , stat = info ) if ( info /= 0 ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if end if end if end do arnoldicycle ! ! Assemble the final solution ! if (. not . allocated ( yk )) then ! First we look if we have arrived here having not used an a posteriori ! error estimate, and thus not having computed the solution in the Krylov ! subspace. allocate ( e ( itx - 1 ), stat = info ) if ( info /= 0 ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if e (:) = dzero allocate ( yk ( itx - 1 ), stat = info ) if ( info /= 0 ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if e ( 1 ) = done call fun % apply ( h ( 1 : itx - 1 , 1 : itx - 1 ), yk , e , info ) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if if ( allocated ( e )) deallocate ( e , stat = info ) if ( info /= 0 ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if end if ! Final Log call log_end ( methdname , iam , itx , itrace_ , errnum , errden , deps , err = derr , iter = iter ) if ( present ( err )) err = derr if ( present ( res )) then allocate ( res ( itx + 1 ), stat = info ) res ( 1 : itx ) = rs ( 1 : itx ) res ( itx + 1 ) = derr end if call psb_geaxpby ( yk ( 1 ), v ( 1 ), dzero , y , desc_a , info ) do i = 2 , itx - 1 , 1 call psb_geaxpby ( yk ( i ), v ( i ), done , y , desc_a , info ) end do call y % scal ( rs ( 1 )) ! Set back the scaling call fun % set ( \"SCALING\" , scaling , info ) ! Free the memory if ( info == psb_success_ ) call psb_gefree ( v , desc_a , info ) if ( info == psb_success_ ) call psb_gefree ( w , desc_a , info ) if ( info == psb_success_ ) call psb_gefree ( xt , desc_a , info ) if ( info == psb_success_ ) deallocate ( aux , h , rs , stat = info ) if ( info /= psb_success_ ) then info = psb_err_from_subroutine_non_ call psb_errpush ( info , name ) goto 9999 end if ! Close and return call psb_erractionrestore ( err_act ) return 9999 call psb_error_handler ( err_act ) return end end submodule psfun_d_sai_mod","tags":"","loc":"sourcefile/psfun_d_sai.f90.html"},{"title":"psfun_d_utils_mod.f90 – PSFUN","text":"This file depends on sourcefile~~psfun_d_utils_mod.f90~~EfferentGraph sourcefile~psfun_d_utils_mod.f90 psfun_d_utils_mod.f90 sourcefile~psfun_utils_mod.f90 psfun_utils_mod.f90 sourcefile~psfun_d_utils_mod.f90->sourcefile~psfun_utils_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules psfun_d_utils_mod Source Code psfun_d_utils_mod.f90 Source Code ! BSD 3-Clause License ! ! Copyright (c) 2020, Fabio Durastante ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this !    list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. submodule ( psfun_utils_mod ) psfun_d_utils_mod !! Real variants of the utils functions use psb_base_mod implicit none contains module function ellipkkp ( L ) result ( K ) !! Complete elliptic integral of the first kind, with complement. !! Returns the value of the complete elliptic integral of the first kind, !! evaluated at M=\\exp(-2\\pi L), 0 < L < \\infty, and the !! complementarity parameter 1-M. use psb_base_mod implicit none real ( psb_dpk_ ), intent ( in ) :: L real ( psb_dpk_ ) :: K ( 2 ) ! Local variables real ( psb_dpk_ ) :: M , a0 , a1 , b0 , b1 , c1 , w1 , s0 , MM integer ( psb_ipk_ ) :: i1 ! When M=exp(-2 π L) ≈ 0, use an O(M) approximation if ( L > 10 ) then K ( 1 ) = DPI / 2_psb_dpk_ K ( 2 ) = DPI * L + log ( 4.0_psb_dpk_ ) return end if M = exp ( - 2.0_psb_dpk_ * DPI * L ) a0 = 1.0_psb_dpk_ b0 = sqrt ( 1 - M ) s0 = M i1 = 0 MM = 1.0_psb_dpk_ do while ( MM > EPSILON ( MM ) ) a1 = ( a0 + b0 ) / 2.0_psb_dpk_ b1 = sqrt ( a0 * b0 ) c1 = ( a0 - b0 ) / 2.0_psb_dpk_ i1 = i1 + 1 w1 = ( 2.0_psb_dpk_ ** i1 ) * ( c1 ** 2 ) MM = w1 s0 = s0 + w1 a0 = a1 b0 = b1 end do K ( 1 ) = DPI / ( 2.0_psb_dpk_ * a1 ) a0 = 1.0_psb_dpk_ b0 = sqrt ( M ) s0 = 1 - M i1 = 0 MM = 1.0_psb_dpk_ do while ( MM > EPSILON ( MM ) ) a1 = ( a0 + b0 ) / 2.0_psb_dpk_ b1 = sqrt ( a0 * b0 ) c1 = ( a0 - b0 ) / 2.0_psb_dpk_ i1 = i1 + 1 w1 = ( 2.0_psb_dpk_ ** i1 ) * ( c1 ** 2 ) MM = w1 s0 = s0 + w1 a0 = a1 b0 = b1 end do K ( 2 ) = DPI / ( 2.0_psb_dpk_ * a1 ) return end function ellipkkp module subroutine d_ellipj ( u , L , sn , cn , dn ) !! Returns the values of the Jacobi elliptic functions evaluated at double !! argument u and parameter M = \\exp(-2 \\pi L), 0 < L < \\infty. !! For M = K&#94;2, and K the elliptic modulus. ! real ( psb_dpk_ ), intent ( in ) :: u real ( psb_dpk_ ), intent ( in ) :: L real ( psb_dpk_ ), intent ( out ) :: sn , cn , dn real ( psb_dpk_ ) :: m m = exp ( - 2.0_psb_dpk_ * DPI * L ) call sncndn ( u , m , sn , cn , dn ) return end subroutine module function horner ( coeffs , x ) result ( res ) !! Apply Horner rule to evaluate a polynomial use psb_base_mod implicit none real ( psb_dpk_ ), dimension (:), intent ( in ) :: coeffs real ( psb_dpk_ ), intent ( in ) :: x real ( psb_dpk_ ) :: res ! Local Variable integer :: i res = 0.0_psb_dpk_ do i = size ( coeffs ), 1 , - 1 res = res * x + coeffs ( i ) end do return end function horner end submodule","tags":"","loc":"sourcefile/psfun_d_utils_mod.f90.html"},{"title":"psfun_utils_mod.f90 – PSFUN","text":"Files dependent on this one sourcefile~~psfun_utils_mod.f90~~AfferentGraph sourcefile~psfun_utils_mod.f90 psfun_utils_mod.f90 sourcefile~psfun_z_quadrature_mod.f90 psfun_z_quadrature_mod.F90 sourcefile~psfun_z_quadrature_mod.f90->sourcefile~psfun_utils_mod.f90 sourcefile~psfun_base_quadrature_mod.f90 psfun_base_quadrature_mod.f90 sourcefile~psfun_z_quadrature_mod.f90->sourcefile~psfun_base_quadrature_mod.f90 sourcefile~utiltest.f90 utiltest.f90 sourcefile~utiltest.f90->sourcefile~psfun_utils_mod.f90 sourcefile~psfun_d_quadrature_mod.f90 psfun_d_quadrature_mod.F90 sourcefile~psfun_d_quadrature_mod.f90->sourcefile~psfun_utils_mod.f90 sourcefile~psfun_d_quadrature_mod.f90->sourcefile~psfun_base_quadrature_mod.f90 sourcefile~psfun_z_quadrules_mod.f90 psfun_z_quadrules_mod.f90 sourcefile~psfun_z_quadrules_mod.f90->sourcefile~psfun_utils_mod.f90 sourcefile~psfun_z_quadrules_mod.f90->sourcefile~psfun_z_quadrature_mod.f90 sourcefile~psfun_d_utils_mod.f90 psfun_d_utils_mod.f90 sourcefile~psfun_d_utils_mod.f90->sourcefile~psfun_utils_mod.f90 sourcefile~psfun_z_utils_mod.f90 psfun_z_utils_mod.f90 sourcefile~psfun_z_utils_mod.f90->sourcefile~psfun_utils_mod.f90 sourcefile~psfun_base_quadrature_mod.f90->sourcefile~psfun_utils_mod.f90 sourcefile~quadraturetest.f90 quadraturetest.F90 sourcefile~quadraturetest.f90->sourcefile~psfun_utils_mod.f90 sourcefile~psfun_quadrature_mod.f90 psfun_quadrature_mod.f90 sourcefile~quadraturetest.f90->sourcefile~psfun_quadrature_mod.f90 sourcefile~psfun_quadrature_mod.f90->sourcefile~psfun_z_quadrature_mod.f90 sourcefile~psfun_quadrature_mod.f90->sourcefile~psfun_d_quadrature_mod.f90 sourcefile~psfun_quadrature_mod.f90->sourcefile~psfun_base_quadrature_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules psfun_utils_mod Source Code psfun_utils_mod.f90 Source Code ! BSD 3-Clause License ! ! Copyright (c) 2020, Fabio Durastante ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this !    list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. module psfun_utils_mod !! This modules contains some utility function that are used in the library. use psb_base_mod implicit none ! Fixed parameters real ( psb_dpk_ ), private , parameter :: DPI = 4.0_psb_dpk_ * ATAN ( 1.0_psb_dpk_ ) !! Double precision \\pi for internal usage interface ellipkkp !! Complete elliptic integral of the first kind, with complement. !! Returns the value of the complete elliptic integral of the first kind, !! evaluated at M=\\exp(-2\\pi L), 0 < L < \\infty, and the !! complementarity parameter 1-M. module function ellipkkp ( L ) result ( K ) real ( psb_dpk_ ), intent ( in ) :: L real ( psb_dpk_ ) :: K ( 2 ) end function end interface ellipkkp interface ellipj !! Returns the values of the Jacobi elliptic functions evaluated at `real` !! or `complex` argument u and parameter M = \\exp(-2 \\pi L), !! 0 < L < \\infty. For M = K&#94;2, and K the elliptic modulus. module subroutine d_ellipj ( u , L , sn , cn , dn ) real ( psb_dpk_ ), intent ( in ) :: u real ( psb_dpk_ ), intent ( in ) :: L real ( psb_dpk_ ), intent ( out ) :: sn , cn , dn end subroutine recursive module subroutine z_ellipj ( u , L , sn , cn , dn , flag ) complex ( psb_dpk_ ), intent ( in ) :: u real ( psb_dpk_ ), intent ( in ) :: L complex ( psb_dpk_ ), intent ( out ) :: sn , cn , dn logical , optional , intent ( in ) :: flag end subroutine end interface ellipj interface horner !! Apply Horner rule to evaluate a polynomial module function horner ( coeffs , x ) result ( res ) real ( psb_dpk_ ), dimension (:), intent ( in ) :: coeffs !! Coefficient of the polynomial real ( psb_dpk_ ), intent ( in ) :: x !! Where to evaluate real ( psb_dpk_ ) :: res !! Result end function end interface horner contains end module psfun_utils_mod","tags":"","loc":"sourcefile/psfun_utils_mod.f90.html"},{"title":"psfun_z_utils_mod.f90 – PSFUN","text":"This file depends on sourcefile~~psfun_z_utils_mod.f90~~EfferentGraph sourcefile~psfun_z_utils_mod.f90 psfun_z_utils_mod.f90 sourcefile~psfun_utils_mod.f90 psfun_utils_mod.f90 sourcefile~psfun_z_utils_mod.f90->sourcefile~psfun_utils_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules psfun_z_utils_mod Source Code psfun_z_utils_mod.f90 Source Code ! BSD 3-Clause License ! ! Copyright (c) 2020, Fabio Durastante ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this !    list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. submodule ( psfun_utils_mod ) psfun_z_utils_mod !! Complex variants of the utils functions use psb_base_mod implicit none complex , parameter :: iunit = cmplx ( 0.0_psb_dpk_ , 1.0_psb_dpk_ ) contains recursive module subroutine z_ellipj ( u , L , sn , cn , dn , flag ) !! Returns the values of the Jacobi elliptic functions evaluated at double !! argument u and parameter M = \\exp(-2 \\pi L), 0 < L < \\infty. !! For M = K&#94;2, and K the elliptic modulus. ! complex ( psb_dpk_ ), intent ( in ) :: u real ( psb_dpk_ ), intent ( in ) :: L complex ( psb_dpk_ ), intent ( out ) :: sn , cn , dn logical , optional , intent ( in ) :: flag real ( psb_dpk_ ) :: m , K ( 2 ), kappa , mu complex ( psb_dpk_ ) :: ucp , sinu , cosu , v , sn1 , cn1 , dn1 , denom , snh , cnh , dnh logical :: flag_ , high real ( psb_dpk_ ), parameter :: coeffs ( 7 ) = ( / 0.0 , 1.0 , 2.0 , 5.0 , 1 4.0 , 4 2.0 , 13 2.0 / ) ucp = u if ( present ( flag ) ) then flag_ = flag else flag_ = . true . end if if ( flag_ ) then K = ellipkkp ( L ) high = ( aimag ( ucp ) > K ( 2 ) / 2.0_psb_dpk_ ) if ( high ) then ucp = iunit * K ( 2 ) - ucp end if m = exp ( - 2.0_psb_dpk_ * DPI * L ) else ! In case of recursive call we have already transformed L into m high = . false . m = L endif if ( m < 4.0_psb_dpk_ * EPSILON ( m ) ) then sinu = sin ( u ); cosu = cos ( u ); sn = sinu + m / 4.0_psb_dpk_ * ( sinu * cosu - u ) * cosu ; cn = cosu + m / 4.0_psb_dpk_ * ( - sinu * cosu + u ) * sinu ; dn = 1 + m / 4.0_psb_dpk_ * ( cosu ** 2 - sinu ** 2 - 1.0_psb_dpk_ ); else if ( m > 1e-3 ) then kappa = ( 1.0_psb_dpk_ - sqrt ( 1.0_psb_dpk_ - m )) / ( 1.0_psb_dpk_ + sqrt ( 1.0_psb_dpk_ - m )) else kappa = horner ( coeffs , m / 4.0_psb_dpk_ ) end if mu = kappa ** 2 v = u / ( 1.0_psb_dpk_ + kappa ) call z_ellipj ( v , mu , sn1 , cn1 , dn1 ,. false .) denom = ( 1.0_psb_dpk_ + kappa * sn1 ** 2 ) sn = ( 1 + kappa ) * sn1 / denom cn = cn1 * dn1 / denom dn = ( 1 - kappa * sn1 ** 2 ) / denom end if if ( high ) then snh = sn cnh = cn dnh = dn sn = - 1.0_psb_dpk_ / ( sqrt ( m ) * snh ) cn = iunit * dnh / ( sqrt ( m ) * snh ) dn = iunit * cnh / snh endif return end subroutine end submodule","tags":"","loc":"sourcefile/psfun_z_utils_mod.f90.html"},{"title":"psfun_d_serial_mod.F90 – PSFUN","text":"Files dependent on this one sourcefile~~psfun_d_serial_mod.f90~~AfferentGraph sourcefile~psfun_d_serial_mod.f90 psfun_d_serial_mod.F90 sourcefile~psfun_d_arnoldi.f90 psfun_d_arnoldi.f90 sourcefile~psfun_d_arnoldi.f90->sourcefile~psfun_d_serial_mod.f90 sourcefile~psfun_d_krylov_mod.f90 psfun_d_krylov_mod.F90 sourcefile~psfun_d_arnoldi.f90->sourcefile~psfun_d_krylov_mod.f90 sourcefile~lanczostest.f90 lanczostest.F90 sourcefile~lanczostest.f90->sourcefile~psfun_d_serial_mod.f90 sourcefile~lanczostest.f90->sourcefile~psfun_d_krylov_mod.f90 sourcefile~arnolditest.f90 arnolditest.F90 sourcefile~arnolditest.f90->sourcefile~psfun_d_serial_mod.f90 sourcefile~arnolditest.f90->sourcefile~psfun_d_krylov_mod.f90 sourcefile~psfun_d_sai.f90 psfun_d_sai.f90 sourcefile~psfun_d_sai.f90->sourcefile~psfun_d_serial_mod.f90 sourcefile~psfun_d_sai.f90->sourcefile~psfun_d_krylov_mod.f90 sourcefile~serialtest.f90 serialtest.f90 sourcefile~serialtest.f90->sourcefile~psfun_d_serial_mod.f90 sourcefile~psfun_d_krylov_mod.f90->sourcefile~psfun_d_serial_mod.f90 sourcefile~psfun_d_lanczos.f90 psfun_d_lanczos.f90 sourcefile~psfun_d_lanczos.f90->sourcefile~psfun_d_serial_mod.f90 sourcefile~psfun_d_lanczos.f90->sourcefile~psfun_d_krylov_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules psfun_d_serial_mod Source Code psfun_d_serial_mod.F90 Source Code ! BSD 3-Clause License ! ! Copyright (c) 2020, Fabio Durastante ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this !    list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. module psfun_d_serial_mod !! This module contains the generic interfaces for the computation of the !! different matrix functions included in the library. The idea is that this !! modules computes, in a serial way, y = f(\\alpha A)x. use psb_base_mod #if defined(WITHPHILIBRARY) use scalesquare !| loaded only if compiled with PHI-FUNCTION library #endif implicit none type , public :: psfun_d_serial character ( len = 20 ) :: fname = 'EXP' !! Name of the function character ( len = 20 ) :: variant = 'EXPOKIT' !! Implementatio variant real ( psb_dpk_ ) :: scaling = 1.0_psb_dpk_ !! \\alpha of f(\\alpha A)v integer ( psb_ipk_ ) :: padedegree = 6_psb_ipk_ !! Degree of Padé expansion integer ( psb_ipk_ ) :: phiorder = 1_psb_ipk_ !! Order of the \\varphi-function procedure ( func ), pointer , nopass :: f_ptr => null () !! Pointer of a function f(x,k) = f&#94;{(k)}(x) contains ! Set the options procedure , pass ( fun ) :: setstring => psfun_d_setstring procedure , pass ( fun ) :: setreal => psfun_d_setreal procedure , pass ( fun ) :: setinteger => psfun_d_setinteger procedure , pass ( fun ) :: setfunction => psfun_d_setpointer generic , public :: set => setstring , setreal , setinteger , setfunction ! Computes the function procedure , pass ( fun ) :: applya => psfun_d_serial_apply_array procedure , pass ( fun ) :: applys => psfun_d_serial_apply_sparse generic , public :: apply => applya , applys end type psfun_d_serial !! !! For symmetric matrices we implement the Schur algorithm for the !! computation of y=f(\\alpha A)x. For this reason we need the `psfun_d_serial` !! type to have a member pointing to a function name for f. It is already !! defined to get also a second optional argument that tells the function !! to compute instead the kth derivative of f. This is done in light of !! the nonsymmetric case in which the Schur-Parlett algorithm should be used !! instead. abstract interface function func ( x , k ) use psb_base_mod implicit none real ( psb_dpk_ ) :: func real ( psb_dpk_ ), intent ( in ) :: x !! Value to be computed integer ( psb_ipk_ ), intent ( in ), optional :: k !! Computes kth derivative f&#94;{(k)}(x) end function func end interface private :: psfun_d_setstring , psfun_d_setreal , psfun_d_setinteger , psfun_d_setpointer contains subroutine psfun_d_setstring ( fun , what , val , info ) !! Set function for setting options defined by a string use psb_base_mod implicit none class ( psfun_d_serial ), intent ( inout ) :: fun !! Function object character ( len =* ), intent ( in ) :: what !! String of option to set character ( len =* ), intent ( in ) :: val !! Value of the string integer ( psb_ipk_ ), intent ( out ) :: info !! Output flag info = psb_success_ select case ( psb_toupper ( what )) case ( \"FNAME\" ) fun % fname = val case ( \"VARIANT\" ) fun % variant = val case default info = psb_err_invalid_args_combination_ end select end subroutine psfun_d_setstring subroutine psfun_d_setreal ( fun , what , val , info ) !! Set function for setting options defined by a real use psb_base_mod implicit none class ( psfun_d_serial ), intent ( inout ) :: fun !! Function object character ( len =* ), intent ( in ) :: what !! String of option to set real ( psb_dpk_ ), intent ( in ) :: val !! Real Value of the option integer ( psb_ipk_ ), intent ( out ) :: info !! Output flag info = psb_success_ select case ( psb_toupper ( what )) case ( \"SCALING\" ) fun % scaling = val case default info = psb_err_invalid_args_combination_ end select end subroutine psfun_d_setreal subroutine psfun_d_setinteger ( fun , what , val , info ) !! Set function for setting options defined by an integer use psb_base_mod implicit none class ( psfun_d_serial ), intent ( inout ) :: fun !! Function object character ( len =* ), intent ( in ) :: what !! String of option to set integer ( psb_ipk_ ), intent ( in ) :: val !! Integer Value of the option integer ( psb_ipk_ ), intent ( out ) :: info !! Output flag info = psb_success_ select case ( psb_toupper ( what )) case ( \"PADE_DEGREE\" ) fun % padedegree = val #if defined(WITHPHILIBRARY) case ( \"PHIORDER\" ) fun % phiorder = val #endif case default info = psb_err_invalid_args_combination_ end select end subroutine psfun_d_setinteger subroutine psfun_d_setpointer ( fun , what , val , info ) !! To set the function pointer inside the type use psb_base_mod implicit none class ( psfun_d_serial ), intent ( inout ) :: fun !! Function object character ( len =* ), intent ( in ) :: what !! String of option to set procedure ( func ) :: val !! Function to set integer ( psb_ipk_ ), intent ( out ) :: info !! Output flag info = psb_success_ select case ( psb_toupper ( what )) case ( 'FPOINTER' ) fun % f_ptr => val case default info = psb_err_invalid_args_combination_ end select end subroutine psfun_d_setpointer subroutine psfun_d_serial_apply_array ( fun , a , y , x , info ) !! This is the core of the function apply on a serial matrix to compute !! y = f(\\alpha A) x. It calls on the specific routines !! implementing the different functions. It is the function to modify if !! ones want to interface a new function that was not previously !! available or a new algorithm (variant) for an already existing !! function. use psb_base_mod #if defined(WITHPHILIBRARY) use scalesquare #endif implicit none class ( psfun_d_serial ), intent ( inout ) :: fun !! Function information real ( psb_dpk_ ), intent ( in ) :: a (:,:) !! Matrix real ( psb_dpk_ ), intent ( in ) :: x (:) !! Input vector real ( psb_dpk_ ), intent ( out ) :: y (:) !! Output vector integer ( psb_ipk_ ), intent ( out ) :: info !! Information on the output !! local variables integer ( psb_ipk_ ) :: n , m , lwsp , iexph , ns , shapes ( 2 ), lwork real ( psb_dpk_ ), allocatable :: fA (:,:), wsp (:), iwsp (:), phiA (:,:,:), work (:), ytmp (:) integer ( psb_ipk_ ), allocatable :: ipiv (:) !! local constants integer ( psb_ipk_ ) :: err_act , i , j character ( len = 20 ) :: name info = psb_success_ name = 'psb_krylov' call psb_erractionsave ( err_act ) n = size ( a , 1 ) m = size ( a , 2 ) if ( n /= m ) then info = psb_err_from_subroutine_ call psb_errpush ( info , name , a_err = trim ( fun % fname )) goto 9999 end if shapes ( 1 ) = n shapes ( 2 ) = m select case ( fun % fname ) case ( 'EXP' ) select case ( fun % variant ) case ( 'TAYLOR' ) !! !! **INTERFACE** for the John Burkardt Taylor code for !! the matrix exponential. allocate ( fA ( n , m ), stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if call r8mat_expm2 ( n , fun % scaling * a , fA ) y = matmul ( fA , x ) if ( allocated ( fA )) deallocate ( fA , stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if case ( 'SASQ' ) !! !! **INTERFACE** for the John Burkardt scaling and squaring code for !! the matrix exponential. allocate ( fA ( n , m ), stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if call r8mat_expm1 ( n , fun % scaling * a , fA ) y = matmul ( fA , x ) if ( allocated ( fA )) deallocate ( fA , stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if case ( 'GENPADE' ) !! !! **INTERFACE** for the EXPOKIT package computes the matrix !! exponential using the irreducible rational Pade approximation !! to the exponential function exp(x) = r(x) = (+/-)( I + 2*(q(x)/p(x)) ), !! combined with scaling-and-squaring. lwsp = 4 * n * m + fun % padedegree + 1 allocate ( wsp ( lwsp ), stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if allocate ( ipiv ( m ), stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if call DGPADM ( fun % padedegree , n , fun % scaling , a , m , wsp , lwsp , ipiv , iexph , ns , info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if allocate ( fA ( n , m ), stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if do i = 1 , n , 1 do j = 1 , m , 1 fA ( i , j ) = wsp ( iexph + ( j - 1 ) * m + i - 1 ) end do end do y = matmul ( fA , x ) if ( allocated ( wsp )) deallocate ( wsp , stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if if ( allocated ( ipiv )) deallocate ( ipiv , stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if if ( allocated ( fA )) deallocate ( fA , stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if case ( \"CHBHES\" ) !! !! **INTERFACE** for the EXPOKIT package computes the matrix !! exponential using the partial fraction expansion of the !! uniform rational Chebyshev approximation for an Hessenberg !! matrix. allocate ( wsp ( 2 * m * ( m + 2 )), stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if y = x call DNCHBV ( n , fun % scaling , a , m , y , wsp ) if ( allocated ( wsp )) deallocate ( wsp , stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if case ( \"CHBGEN\" ) !! !! **INTERFACE** for the EXPOKIT package computes the matrix !! exponential using the partial fraction expansion of the !! uniform rational Chebyshev approximation for a general !! matrix. allocate ( wsp ( 2 * m * ( m + 2 )), stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if allocate ( iwsp ( m ), stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if y = x call DGCHBV ( n , fun % scaling , a , m , y , wsp , iwsp , info ) if ( allocated ( wsp )) deallocate ( wsp , stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if if ( allocated ( iwsp )) deallocate ( iwsp , stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if case ( \"CHBSYM\" ) !! !! **INTERFACE** for the EXPOKIT package computes the matrix !! exponential using the partial fraction expansion of the !! uniform rational Chebyshev approximation for a symmetric !! matrix. allocate ( wsp ( 2 * m * ( m + 2 )), stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if allocate ( iwsp ( m ), stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if y = x call DSCHBV ( n , fun % scaling , a , m , y , wsp , iwsp , info ) if ( allocated ( wsp )) deallocate ( wsp , stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if if ( allocated ( iwsp )) deallocate ( iwsp , stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if case default info = psb_err_from_subroutine_ call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end select case ( 'PHI' ) #if defined(WITHPHILIBRARY) !! !! **INTERFACE** to the ϕ-function from Koikari, Souji. !!\"Algorithm 894: On a block Schur--Parlett algorithm !! for ϕ-functions based on the sep-inverse estimate.\" !!ACM Transactions on Mathematical Software (TOMS) 36.2 !! (2009): 1-20. allocate ( phiA ( n , m , fun % phiorder ), stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if phiA = sasmtrphif ( fun % phiorder , fun % scaling , a ) y = matmul ( phiA (:,:, fun % phiorder ), x ) if ( allocated ( phiA )) deallocate ( phiA , stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if #else write ( psb_err_unit , * ) 'Warning: no suitable PHIFUNCTION interface' info = psb_err_from_subroutine_ call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 #endif case ( 'USERF' ) select case ( fun % variant ) case ( 'SYM' ) !! !! For a symmetric matrix we need only to compute the function !! values, and not also its derivatives. We use LAPACK to compute !! the Schur decomposition of the input matrix, apply f on the !! eigenvalues and return the computation allocate ( fA ( n , m ), stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if allocate ( wsp ( n ), stat = info ) ! Will contain the eigenvalues if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if allocate ( ytmp ( n ), stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if fA = a ! We need to work on a copy of a since the Lapack routine ! will destroy it ! First we query the Lapack routine for the size of the ! auxiliary working vectors allocate ( work ( 1 ), stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if call DSYEV ( 'V' , 'U' , n , fA , n , wsp , work , - 1 , info ) lwork = work ( 1 ) ! Store the optimal work-size ! We free the dummy work vectors and the reallocate them to the ! corrected size if ( allocated ( work )) deallocate ( work , stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if allocate ( work ( lwork ), stat = info ) ! We can now do the proper computation call DSYEV ( 'V' , 'U' , n , fA , n , wsp , work , lwork , info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if ! a = fA diag(wsp) fA&#94;T in three steps call DGEMV ( 'T' , m , n , done , fA , n , x , 1 , dzero , ytmp , 1 ) ! ytmp = A&#94;t x do i = 1 , n , 1 ytmp ( i ) = fun % f_ptr ( fun % scaling * wsp ( i )) * ytmp ( i ) ! ytmp(i) = f(α λ_i) ytmp(i) end do call DGEMV ( 'N' , m , n , done , fA , n , ytmp , 1 , dzero , y , 1 ) ! y = A ytmp if ( allocated ( fA )) deallocate ( fA , stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if if ( allocated ( wsp )) deallocate ( wsp , stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if if ( allocated ( work )) deallocate ( work , stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if if ( allocated ( ytmp )) deallocate ( ytmp , stat = info ) if ( info /= 0 ) then call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end if case default info = psb_err_from_subroutine_ call psb_errpush ( info , name , a_err = trim ( fun % variant )) goto 9999 end select case default info = psb_err_from_subroutine_ call psb_errpush ( info , name , a_err = trim ( fun % fname )) goto 9999 end select if ( info /= psb_success_ ) then info = psb_err_from_subroutine_ call psb_errpush ( info , name , a_err = trim ( fun % fname )) goto 9999 end if call psb_erractionrestore ( err_act ) return 9999 continue return end subroutine psfun_d_serial_apply_array subroutine psfun_d_serial_apply_sparse ( fun , a , y , x , info ) !! This is the core of the function apply on a serial matrix to compute !! y = f(\\alpha*A) x when A is memorized in a sparse storage. !! In this case the routine converts it to a dense storage and then calls !! the array version of itself. That is the one implementing the !! different functions. It is the function to modify if ones want to !! interface a new function that was not previously available or a new !! algorithm (variant) for an already existing function. use psb_base_mod implicit none class ( psfun_d_serial ), intent ( inout ) :: fun !! Function information type ( psb_dspmat_type ), intent ( inout ) :: a !! Matrix real ( psb_dpk_ ), intent ( in ) :: x (:) !! Input vector real ( psb_dpk_ ), intent ( out ) :: y (:) !! Output vector integer ( psb_ipk_ ), intent ( out ) :: info !! Information on the output ! local variables real ( psb_dpk_ ), allocatable :: amat (:,:) integer ( psb_ipk_ ) :: n , nnz , i type ( psb_d_coo_sparse_mat ) :: acoo call a % a % cp_to_coo ( acoo , info ) if ( info /= psb_success_ ) write ( psb_err_unit , * ) \"Error in Copy to COO\" n = a % get_nrows () nnz = acoo % get_nzeros () allocate ( amat ( n , n ), stat = info ) if ( info /= 0 ) write ( psb_err_unit , * ) \"amat: Allocation request denied\" amat = 0_psb_dpk_ do i = 1 , nnz , 1 amat ( acoo % ia ( i ), acoo % ja ( i )) = acoo % val ( i ) end do call fun % apply ( amat , y , x , info ) if ( allocated ( amat )) deallocate ( amat , stat = info ) if ( info /= 0 ) write ( psb_err_unit , * ) \"amat: Deallocation request denied\" return end subroutine psfun_d_serial_apply_sparse end module psfun_d_serial_mod","tags":"","loc":"sourcefile/psfun_d_serial_mod.f90.html"},{"title":"psfun_z_quadrature – PSFUN ","text":"type, public, extends( psfun_quadrature ) :: psfun_z_quadrature Inherits type~~psfun_z_quadrature~~InheritsGraph type~psfun_z_quadrature psfun_z_quadrature type~psfun_quadrature psfun_quadrature type~psfun_z_quadrature->type~psfun_quadrature psb_dprec_type psb_dprec_type type~psfun_z_quadrature->psb_dprec_type prec psb_dspmat_type psb_dspmat_type type~psfun_z_quadrature->psb_dspmat_type a psb_desc_type psb_desc_type type~psfun_quadrature->psb_desc_type desc_a Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables a c desc_a eta prec sign xi Type-Bound Procedures computepoles plot set setmatrix setpreconditioner Components Type Visibility Attributes Name Initial type(psb_dspmat_type), public, pointer :: a Matrix on which we work complex(kind=psb_dpk_), public, allocatable, dimension(:) :: c Scaling of the formula type(psb_desc_type), public :: desc_a Descriptor for parallel environment real(kind=psb_dpk_), public :: eta Global Scaling type(psb_dprec_type), public, pointer :: prec Preconditioner for the solution of the associate linear systems real(kind=psb_dpk_), public :: sign Sign for complex(kind=psb_dpk_), public, allocatable, dimension(:) :: xi Poles of the formula Type-Bound Procedures procedure, public, pass(quad) :: computepoles => psfun_z_computepoles public subroutine psfun_z_computepoles (quad, quadformula, zfun, N, info, cparams, rparams) Compute the poles for a given combination of quadrature rule and\n quadrature formula Arguments Type Intent Optional Attributes Name class( psfun_z_quadrature ), intent(inout) :: quad Quadrature type procedure( zquadrule ), intent(in), pointer :: quadformula Quadrature formula procedure( zquadfun ), intent(in), pointer :: zfun Function to integrate integer(kind=psb_ipk_), intent(in) :: N Number of poles integer(kind=psb_ipk_), intent(out) :: info Flag on the results complex(kind=psb_dpk_), intent(in), optional dimension(:) :: cparams Optional complex parameters real(kind=psb_dpk_), intent(in), optional dimension(:) :: rparams Optional real parameters procedure, public, pass(quad) :: plot => psfun_z_quadratureplot public subroutine psfun_z_quadratureplot (quad, zfun, info, filename) Plots on the complex plane the quadrature poles, and plots the weights of\n the formula Arguments Type Intent Optional Attributes Name class( psfun_z_quadrature ), intent(in) :: quad Quadrature rule procedure( zquadfun ), intent(in), pointer :: zfun Function to integrate integer(kind=psb_ipk_), intent(out) :: info character(len=*), intent(in), optional :: filename generic, public :: set => setmatrix , setpreconditioner public subroutine psfun_z_setmatrix (quad, a) Set the matrix for Arguments Type Intent Optional Attributes Name class( psfun_z_quadrature ), intent(inout) :: quad Quadrature type type(psb_dspmat_type), target :: a Matrix on which we work public subroutine psfun_z_setpreconditioner (quad, prec) Set the preconditioner to use for the given quadrature formula Arguments Type Intent Optional Attributes Name class( psfun_z_quadrature ), intent(inout) :: quad Quadrature type type(psb_dprec_type), target :: prec Preconditioner for the solution of the associate linear systems procedure, public, pass(quad) :: setmatrix => psfun_z_setmatrix public subroutine psfun_z_setmatrix (quad, a) Set the matrix for Arguments Type Intent Optional Attributes Name class( psfun_z_quadrature ), intent(inout) :: quad Quadrature type type(psb_dspmat_type), target :: a Matrix on which we work procedure, public, pass(quad) :: setpreconditioner => psfun_z_setpreconditioner public subroutine psfun_z_setpreconditioner (quad, prec) Set the preconditioner to use for the given quadrature formula Arguments Type Intent Optional Attributes Name class( psfun_z_quadrature ), intent(inout) :: quad Quadrature type type(psb_dprec_type), target :: prec Preconditioner for the solution of the associate linear systems","tags":"","loc":"type/psfun_z_quadrature.html"},{"title":"psfun_quadrature – PSFUN ","text":"type, public :: psfun_quadrature Inherits type~~psfun_quadrature~~InheritsGraph type~psfun_quadrature psfun_quadrature psb_desc_type psb_desc_type type~psfun_quadrature->psb_desc_type desc_a Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~psfun_quadrature~~InheritedByGraph type~psfun_quadrature psfun_quadrature type~psfun_d_quadrature psfun_d_quadrature type~psfun_d_quadrature->type~psfun_quadrature type~psfun_z_quadrature psfun_z_quadrature type~psfun_z_quadrature->type~psfun_quadrature Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables desc_a Components Type Visibility Attributes Name Initial type(psb_desc_type), public :: desc_a Descriptor for parallel environment","tags":"","loc":"type/psfun_quadrature.html"},{"title":"psfun_d_quadrature – PSFUN ","text":"type, public, extends( psfun_quadrature ) :: psfun_d_quadrature Inherits type~~psfun_d_quadrature~~InheritsGraph type~psfun_d_quadrature psfun_d_quadrature type~psfun_quadrature psfun_quadrature type~psfun_d_quadrature->type~psfun_quadrature psb_dprec_type psb_dprec_type type~psfun_d_quadrature->psb_dprec_type prec psb_dspmat_type psb_dspmat_type type~psfun_d_quadrature->psb_dspmat_type a psb_desc_type psb_desc_type type~psfun_quadrature->psb_desc_type desc_a Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables a c desc_a eta prec sign xi Type-Bound Procedures plot Components Type Visibility Attributes Name Initial type(psb_dspmat_type), public, pointer :: a Matrix on which we work real(kind=psb_dpk_), public, allocatable, dimension(:) :: c Scaling of the formula type(psb_desc_type), public :: desc_a Descriptor for parallel environment real(kind=psb_dpk_), public :: eta Global Scaling type(psb_dprec_type), public :: prec Preconditioner for the solution of the associated linear systems real(kind=psb_dpk_), public :: sign Sign for A real(kind=psb_dpk_), public, allocatable, dimension(:) :: xi Poles of the formula Type-Bound Procedures procedure, public, pass(quad) :: plot => psfun_d_quadratureplot public subroutine psfun_d_quadratureplot (quad, dfun, filename, info) Plots on the complex plane the quadrature poles, and plots the weights of\n the formula Arguments Type Intent Optional Attributes Name class( psfun_d_quadrature ), intent(in) :: quad Quadrature rule procedure( dquadfun ), intent(in), pointer :: dfun Function to integrate character(len=*), intent(in), optional :: filename Filename for the figure integer(kind=psb_ipk_), intent(out) :: info Result of the plot","tags":"","loc":"type/psfun_d_quadrature.html"},{"title":"psfun_d_krylov – PSFUN ","text":"type, public :: psfun_d_krylov Inherits type~~psfun_d_krylov~~InheritsGraph type~psfun_d_krylov psfun_d_krylov amg_dprec_type amg_dprec_type type~psfun_d_krylov->amg_dprec_type prec Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables irst istopc itmax itrace kmethd kname prec tau Type-Bound Procedures apply plot precbuild precinit set setinteger setstring Components Type Visibility Attributes Name Initial integer(kind=psb_ipk_), public :: irst = 10 Size for subspace restarting (inner method) integer(kind=psb_ipk_), public :: istopc = 1 Stopping criterion (inner method) integer(kind=psb_ipk_), public :: itmax = 200 Maximum number of iterations (inner method) integer(kind=psb_ipk_), public :: itrace = 0 Trace for the solution (inner method) character(len=20), public :: kmethd = 'CG' Method for the solution of the linear system character(len=20), public :: kname = 'ARNOLDI' Name of the Krylov method type(amg_dprec_type), public :: prec Preconditioner for the inner solution method real(kind=psb_dpk_), public :: tau = dzero Shift for shift-and-invert methods Type-Bound Procedures procedure, public, pass(meth) :: apply => psfun_d_parallel_apply public subroutine psfun_d_parallel_apply (meth, fun, a, desc_a, y, x, eps, info, itmax, itrace, istop, iter, err, res) This is the generic function for applying every implemented Krylov\n method. The general iteration parameters (like the number of iteration,\n the stop criterion to be used, and the verbosity of the trace) can be\n passed directly to this routine. All the constitutive parameters of\n the actual method, and the information relative to the function are\n instead contained in the meth and fun objects. The Descriptor object\n `desc_a' contains the properties of the parallel environment. Arguments Type Intent Optional Attributes Name class( psfun_d_krylov ), intent(inout) :: meth Krylov method object type( psfun_d_serial ), intent(inout) :: fun Function object type(psb_dspmat_type), intent(in) :: a Distribute sparse matrix type(psb_desc_type), intent(in) :: desc_a Descriptor for the sparse matrix type(psb_d_vect_type), intent(inout) :: y Output vector type(psb_d_vect_type), intent(inout) :: x Input vector real(kind=psb_dpk_), intent(in) :: eps Requested tolerance integer(kind=psb_ipk_), intent(out) :: info Output flag integer(kind=psb_ipk_), intent(in), optional :: itmax Maximum number of iteration integer(kind=psb_ipk_), intent(in), optional :: itrace Trace for logoutput integer(kind=psb_ipk_), intent(in), optional :: istop Stop criterion integer(kind=psb_ipk_), intent(out), optional :: iter Number of iteration real(kind=psb_dpk_), intent(out), optional :: err Last estimate error real(kind=psb_dpk_), intent(out), optional allocatable :: res (:) Vector of the residuals procedure, public, pass(meth) :: plot => psfun_d_plot_info public subroutine psfun_d_plot_info (meth, fun, iter, res, info) This function plots the convergence history of the Krylov method Arguments Type Intent Optional Attributes Name class( psfun_d_krylov ), intent(inout) :: meth Krylov method type( psfun_d_serial ), intent(inout) :: fun Function object integer(kind=psb_ipk_), intent(in) :: iter Number of iteration real(kind=psb_dpk_), intent(in), dimension(:) :: res Residual vector integer(kind=psb_ipk_), intent(out) :: info Result of the Gnuplot call procedure, public, pass(meth) :: precbuild => psfun_d_prec_build public subroutine psfun_d_prec_build (meth, a, desc_a, info) This function builds the AMG4PSBLAS preconditioner for the inner solve\n in a Rational Krylov method Arguments Type Intent Optional Attributes Name class( psfun_d_krylov ), intent(inout) :: meth Krylov method type(psb_dspmat_type), intent(inout) :: a Sparse matrix type(psb_desc_type), intent(inout) :: desc_a Descriptor for the sparse matrix integer(kind=psb_ipk_) :: info Result of the init call procedure, public, pass(meth) :: precinit => psfun_d_prec_init public subroutine psfun_d_prec_init (meth, ctxt, ptype, info) This function performs the init of the preconditioner for the inner\n solve in the rational Krylov method Arguments Type Intent Optional Attributes Name class( psfun_d_krylov ), intent(inout) :: meth Krylov method type(psb_ctxt_type), intent(in) :: ctxt Parallel context character(len=20), intent(in) :: ptype PSBLAS/AMG4PSBLAS preconditioner integer(kind=psb_ipk_) :: info Result of the init call generic, public :: set => setstring , setinteger private subroutine psfun_d_setstring(meth, what, val, info) Set function for setting options defined by a string Arguments Type Intent Optional Attributes Name class( psfun_d_krylov ), intent(inout) :: meth character(len=*), intent(in) :: what character(len=*), intent(in) :: val integer(kind=psb_ipk_), intent(out) :: info private subroutine psfun_d_setinteger(meth, what, val, info) Set function for setting options defined by an integer Arguments Type Intent Optional Attributes Name class( psfun_d_krylov ), intent(inout) :: meth Krylov method object character(len=*), intent(in) :: what String of option to set integer(kind=psb_ipk_), intent(in) :: val Value of the integer integer(kind=psb_ipk_), intent(out) :: info Output flag procedure, public, pass(meth) :: setinteger => psfun_d_setinteger private subroutine psfun_d_setinteger(meth, what, val, info) Set function for setting options defined by an integer Arguments Type Intent Optional Attributes Name class( psfun_d_krylov ), intent(inout) :: meth Krylov method object character(len=*), intent(in) :: what String of option to set integer(kind=psb_ipk_), intent(in) :: val Value of the integer integer(kind=psb_ipk_), intent(out) :: info Output flag procedure, public, pass(meth) :: setstring => psfun_d_setstring private subroutine psfun_d_setstring(meth, what, val, info) Set function for setting options defined by a string Arguments Type Intent Optional Attributes Name class( psfun_d_krylov ), intent(inout) :: meth character(len=*), intent(in) :: what character(len=*), intent(in) :: val integer(kind=psb_ipk_), intent(out) :: info","tags":"","loc":"type/psfun_d_krylov.html"},{"title":"psfun_d_serial – PSFUN ","text":"type, public :: psfun_d_serial Contents Variables f_ptr fname padedegree phiorder scaling variant Type-Bound Procedures apply applya applys set setfunction setinteger setreal setstring Components Type Visibility Attributes Name Initial procedure( func ), public, pointer, nopass :: f_ptr => null() Pointer of a function character(len=20), public :: fname = 'EXP' Name of the function integer(kind=psb_ipk_), public :: padedegree = 6_psb_ipk_ Degree of Padé expansion integer(kind=psb_ipk_), public :: phiorder = 1_psb_ipk_ Order of the -function real(kind=psb_dpk_), public :: scaling = 1.0_psb_dpk_ of character(len=20), public :: variant = 'EXPOKIT' Implementatio variant Type-Bound Procedures generic, public :: apply => applya , applys public subroutine psfun_d_serial_apply_array (fun, a, y, x, info) This is the core of the function apply on a serial matrix to compute . It calls on the specific routines\n implementing the different functions. It is the function to modify if\n ones want to interface a new function that was not previously\n available or a new algorithm (variant) for an already existing\n function. Read more… Arguments Type Intent Optional Attributes Name class( psfun_d_serial ), intent(inout) :: fun Function information real(kind=psb_dpk_), intent(in) :: a (:,:) Matrix real(kind=psb_dpk_), intent(out) :: y (:) Output vector real(kind=psb_dpk_), intent(in) :: x (:) Input vector integer(kind=psb_ipk_), intent(out) :: info Information on the output Read more… public subroutine psfun_d_serial_apply_sparse (fun, a, y, x, info) This is the core of the function apply on a serial matrix to compute when A is memorized in a sparse storage.\n In this case the routine converts it to a dense storage and then calls\n the array version of itself. That is the one implementing the\n different functions. It is the function to modify if ones want to\n interface a new function that was not previously available or a new\n algorithm (variant) for an already existing function. Arguments Type Intent Optional Attributes Name class( psfun_d_serial ), intent(inout) :: fun Function information type(psb_dspmat_type), intent(inout) :: a Matrix real(kind=psb_dpk_), intent(out) :: y (:) Output vector real(kind=psb_dpk_), intent(in) :: x (:) Input vector integer(kind=psb_ipk_), intent(out) :: info Information on the output procedure, public, pass(fun) :: applya => psfun_d_serial_apply_array public subroutine psfun_d_serial_apply_array (fun, a, y, x, info) This is the core of the function apply on a serial matrix to compute . It calls on the specific routines\n implementing the different functions. It is the function to modify if\n ones want to interface a new function that was not previously\n available or a new algorithm (variant) for an already existing\n function. Read more… Arguments Type Intent Optional Attributes Name class( psfun_d_serial ), intent(inout) :: fun Function information real(kind=psb_dpk_), intent(in) :: a (:,:) Matrix real(kind=psb_dpk_), intent(out) :: y (:) Output vector real(kind=psb_dpk_), intent(in) :: x (:) Input vector integer(kind=psb_ipk_), intent(out) :: info Information on the output Read more… procedure, public, pass(fun) :: applys => psfun_d_serial_apply_sparse public subroutine psfun_d_serial_apply_sparse (fun, a, y, x, info) This is the core of the function apply on a serial matrix to compute when A is memorized in a sparse storage.\n In this case the routine converts it to a dense storage and then calls\n the array version of itself. That is the one implementing the\n different functions. It is the function to modify if ones want to\n interface a new function that was not previously available or a new\n algorithm (variant) for an already existing function. Arguments Type Intent Optional Attributes Name class( psfun_d_serial ), intent(inout) :: fun Function information type(psb_dspmat_type), intent(inout) :: a Matrix real(kind=psb_dpk_), intent(out) :: y (:) Output vector real(kind=psb_dpk_), intent(in) :: x (:) Input vector integer(kind=psb_ipk_), intent(out) :: info Information on the output generic, public :: set => setstring , setreal , setinteger , setfunction private subroutine psfun_d_setstring(fun, what, val, info) Set function for setting options defined by a string Arguments Type Intent Optional Attributes Name class( psfun_d_serial ), intent(inout) :: fun Function object character(len=*), intent(in) :: what String of option to set character(len=*), intent(in) :: val Value of the string integer(kind=psb_ipk_), intent(out) :: info Output flag private subroutine psfun_d_setreal(fun, what, val, info) Set function for setting options defined by a real Arguments Type Intent Optional Attributes Name class( psfun_d_serial ), intent(inout) :: fun Function object character(len=*), intent(in) :: what String of option to set real(kind=psb_dpk_), intent(in) :: val Real Value of the option integer(kind=psb_ipk_), intent(out) :: info Output flag private subroutine psfun_d_setinteger(fun, what, val, info) Set function for setting options defined by an integer Arguments Type Intent Optional Attributes Name class( psfun_d_serial ), intent(inout) :: fun Function object character(len=*), intent(in) :: what String of option to set integer(kind=psb_ipk_), intent(in) :: val Integer Value of the option integer(kind=psb_ipk_), intent(out) :: info Output flag private subroutine psfun_d_setpointer(fun, what, val, info) To set the function pointer inside the type Arguments Type Intent Optional Attributes Name class( psfun_d_serial ), intent(inout) :: fun Function object character(len=*), intent(in) :: what String of option to set procedure( func ) :: val Function to set integer(kind=psb_ipk_), intent(out) :: info Output flag procedure, public, pass(fun) :: setfunction => psfun_d_setpointer private subroutine psfun_d_setpointer(fun, what, val, info) To set the function pointer inside the type Arguments Type Intent Optional Attributes Name class( psfun_d_serial ), intent(inout) :: fun Function object character(len=*), intent(in) :: what String of option to set procedure( func ) :: val Function to set integer(kind=psb_ipk_), intent(out) :: info Output flag procedure, public, pass(fun) :: setinteger => psfun_d_setinteger private subroutine psfun_d_setinteger(fun, what, val, info) Set function for setting options defined by an integer Arguments Type Intent Optional Attributes Name class( psfun_d_serial ), intent(inout) :: fun Function object character(len=*), intent(in) :: what String of option to set integer(kind=psb_ipk_), intent(in) :: val Integer Value of the option integer(kind=psb_ipk_), intent(out) :: info Output flag procedure, public, pass(fun) :: setreal => psfun_d_setreal private subroutine psfun_d_setreal(fun, what, val, info) Set function for setting options defined by a real Arguments Type Intent Optional Attributes Name class( psfun_d_serial ), intent(inout) :: fun Function object character(len=*), intent(in) :: what String of option to set real(kind=psb_dpk_), intent(in) :: val Real Value of the option integer(kind=psb_ipk_), intent(out) :: info Output flag procedure, public, pass(fun) :: setstring => psfun_d_setstring private subroutine psfun_d_setstring(fun, what, val, info) Set function for setting options defined by a string Arguments Type Intent Optional Attributes Name class( psfun_d_serial ), intent(inout) :: fun Function object character(len=*), intent(in) :: what String of option to set character(len=*), intent(in) :: val Value of the string integer(kind=psb_ipk_), intent(out) :: info Output flag","tags":"","loc":"type/psfun_d_serial.html"},{"title":"zquadfun – PSFUN","text":"abstract interface public function zquadfun(z) result(res) Arguments Type Intent Optional Attributes Name complex(kind=psb_dpk_), intent(in) :: z Return Value complex(kind=psb_dpk_)","tags":"","loc":"interface/zquadfun.html"},{"title":"zquadrule – PSFUN","text":"abstract interface public subroutine zquadrule(zfun, xi, c, eta, sign, N, info, cparams, rparams) Arguments Type Intent Optional Attributes Name procedure( zquadfun ), intent(in), pointer :: zfun Function to integrate complex(kind=psb_dpk_), intent(out), allocatable, dimension(:) :: xi Poles of the formula complex(kind=psb_dpk_), intent(out), allocatable, dimension(:) :: c Scaling of the formula real(kind=psb_dpk_), intent(out) :: eta Global Scaling real(kind=psb_dpk_), intent(out) :: sign Sign for A integer(kind=psb_ipk_), intent(in) :: N Number of Poles integer(kind=psb_ipk_), intent(out) :: info Flag on the results complex(kind=psb_dpk_), intent(in), optional dimension(:) :: cparams Optional complex parameters real(kind=psb_dpk_), intent(in), optional dimension(:) :: rparams Optional real parameters Description To integrate a function that take as inputs complex number and gives as output\n complex numbers","tags":"","loc":"interface/zquadrule.html"},{"title":"dquadfun – PSFUN","text":"abstract interface public function dquadfun(z) result(res) Arguments Type Intent Optional Attributes Name real(kind=psb_dpk_), intent(in) :: z Return Value complex(kind=psb_dpk_)","tags":"","loc":"interface/dquadfun.html"},{"title":"dquadrule – PSFUN","text":"abstract interface public subroutine dquadrule(dfun, xi, c, eta, sign, N, info, cparams, rparams) Arguments Type Intent Optional Attributes Name procedure( dquadfun ), intent(in), pointer :: dfun Function to integrate complex(kind=psb_dpk_), intent(out), allocatable, dimension(:) :: xi Poles of the formula complex(kind=psb_dpk_), intent(out), allocatable, dimension(:) :: c Scaling of the formula complex(kind=psb_dpk_), intent(out) :: eta Global Scaling complex(kind=psb_dpk_), intent(out) :: sign Sign for A integer(kind=psb_ipk_), intent(in) :: N Number of Poles integer(kind=psb_ipk_), intent(out) :: info Flag on the results complex(kind=psb_dpk_), intent(in), optional dimension(:) :: cparams Optional complex parameters real(kind=psb_dpk_), intent(in), optional dimension(:) :: rparams Optional real parameters Description To integrate a function that take as inputs real numbers and gives as\n output complex numbers","tags":"","loc":"interface/dquadrule.html"},{"title":"func – PSFUN","text":"abstract interface public function func(x, k) Arguments Type Intent Optional Attributes Name real(kind=psb_dpk_), intent(in) :: x Value to be computed integer(kind=psb_ipk_), intent(in), optional :: k Computes kth derivative Return Value real(kind=psb_dpk_)","tags":"","loc":"interface/func.html"},{"title":"psfun_dcg_vect – PSFUN","text":"subroutine psfun_dcg_vect(a, prec, b, eta, zeta, x, eps, desc_a, info, itmax, iter, err, itrace, istop, cond) Uses psb_base_mod psb_prec_mod psb_d_krylov_conv_mod psb_krylov_mod proc~~psfun_dcg_vect~~UsesGraph proc~psfun_dcg_vect psfun_dcg_vect psb_prec_mod psb_prec_mod proc~psfun_dcg_vect->psb_prec_mod psb_base_mod psb_base_mod proc~psfun_dcg_vect->psb_base_mod psb_krylov_mod psb_krylov_mod proc~psfun_dcg_vect->psb_krylov_mod psb_d_krylov_conv_mod psb_d_krylov_conv_mod proc~psfun_dcg_vect->psb_d_krylov_conv_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Preconditioned Conjugate Gradient for shifted system Arguments Type Intent Optional Attributes Name type(psb_dspmat_type), intent(in) :: a Distributed sparse matrix class(psb_dprec_type), intent(inout) :: prec Preconditioner type(psb_d_vect_type), intent(inout) :: b Right-hand side real(kind=psb_dpk_), intent(in) :: eta of real(kind=psb_dpk_), intent(in) :: zeta of type(psb_d_vect_type), intent(inout) :: x Solution on exit, initial guess on entry real(kind=psb_dpk_), intent(in) :: eps Tolerance for the solution type(psb_desc_type), intent(in) :: desc_a Descriptor integer(kind=psb_ipk_), intent(out) :: info Flag integer(kind=psb_ipk_), intent(in), optional :: itmax Auxiliary parameters integer(kind=psb_ipk_), intent(out), optional :: iter Final number of iteration real(kind=psb_dpk_), intent(out), optional :: err Auxiliary parameters integer(kind=psb_ipk_), intent(in), optional :: itrace Auxiliary parameters integer(kind=psb_ipk_), intent(in), optional :: istop Auxiliary parameters real(kind=psb_dpk_), intent(out), optional :: cond Auxiliary parameters Calls proc~~psfun_dcg_vect~~CallsGraph proc~psfun_dcg_vect psfun_dcg_vect psb_erractionsave psb_erractionsave proc~psfun_dcg_vect->psb_erractionsave psb_get_debug_unit psb_get_debug_unit proc~psfun_dcg_vect->psb_get_debug_unit psb_errpush psb_errpush proc~psfun_dcg_vect->psb_errpush psb_bcast psb_bcast proc~psfun_dcg_vect->psb_bcast psb_get_debug_level psb_get_debug_level proc~psfun_dcg_vect->psb_get_debug_level psb_info psb_info proc~psfun_dcg_vect->psb_info psb_init_conv psb_init_conv proc~psfun_dcg_vect->psb_init_conv psb_geaxpby psb_geaxpby proc~psfun_dcg_vect->psb_geaxpby psb_spmm psb_spmm proc~psfun_dcg_vect->psb_spmm psb_gedot psb_gedot proc~psfun_dcg_vect->psb_gedot psb_check_conv psb_check_conv proc~psfun_dcg_vect->psb_check_conv psb_erractionrestore psb_erractionrestore proc~psfun_dcg_vect->psb_erractionrestore psb_chkvect psb_chkvect proc~psfun_dcg_vect->psb_chkvect psb_end_conv psb_end_conv proc~psfun_dcg_vect->psb_end_conv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/psfun_dcg_vect.html"},{"title":"fun – PSFUN","text":"function fun(z) result(res) Uses psb_base_mod proc~~fun~~UsesGraph proc~fun fun psb_base_mod psb_base_mod proc~fun->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Function to integrate Arguments Type Intent Optional Attributes Name complex(kind=psb_dpk_), intent(in) :: z Return Value complex(kind=psb_dpk_) Contents None","tags":"","loc":"proc/fun.html"},{"title":"get_dparms – PSFUN","text":"public subroutine get_dparms(ctxt, mtrx_file, rhs_file, eta, zeta, filefmt, kmethd, ptype, part, afmt, istopc, itmax, itrace, irst, eps) Uses psb_base_mod proc~~get_dparms~~UsesGraph proc~get_dparms get_dparms psb_base_mod psb_base_mod proc~get_dparms->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Get iteration parameters from the command line Arguments Type Intent Optional Attributes Name type(psb_ctxt_type) :: ctxt Parallel context character(len=40) :: mtrx_file character(len=40) :: rhs_file real(kind=psb_dpk_) :: eta real(kind=psb_dpk_) :: zeta character(len=2) :: filefmt Format of the file character(len=40) :: kmethd character(len=40) :: ptype character(len=20) :: part character :: afmt *5 integer(kind=psb_ipk_) :: istopc integer(kind=psb_ipk_) :: itmax integer(kind=psb_ipk_) :: itrace integer(kind=psb_ipk_) :: irst real(kind=psb_dpk_) :: eps Calls proc~~get_dparms~~CallsGraph proc~get_dparms get_dparms psb_bcast psb_bcast proc~get_dparms->psb_bcast psb_info psb_info proc~get_dparms->psb_info psb_abort psb_abort proc~get_dparms->psb_abort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~get_dparms~~CalledByGraph proc~get_dparms get_dparms interface~get_parms get_parms interface~get_parms->proc~get_dparms program~shiftedtest shiftedtest program~shiftedtest->interface~get_parms Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_dparms.html"},{"title":"get_parms – PSFUN","text":"public interface get_parms Get iteration parameters from the command line Calls interface~~get_parms~~CallsGraph interface~get_parms get_parms proc~get_dparms get_dparms interface~get_parms->proc~get_dparms psb_bcast psb_bcast proc~get_dparms->psb_bcast psb_info psb_info proc~get_dparms->psb_info psb_abort psb_abort proc~get_dparms->psb_abort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~get_parms~~CalledByGraph interface~get_parms get_parms program~shiftedtest shiftedtest program~shiftedtest->interface~get_parms Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures get_dparms Module Procedures public subroutine get_dparms (ctxt, mtrx_file, rhs_file, eta, zeta, filefmt, kmethd, ptype, part, afmt, istopc, itmax, itrace, irst, eps) Get iteration parameters from the command line Arguments Type Intent Optional Attributes Name type(psb_ctxt_type) :: ctxt Parallel context character(len=40) :: mtrx_file character(len=40) :: rhs_file real(kind=psb_dpk_) :: eta real(kind=psb_dpk_) :: zeta character(len=2) :: filefmt Format of the file character(len=40) :: kmethd character(len=40) :: ptype character(len=20) :: part character :: afmt *5 integer(kind=psb_ipk_) :: istopc integer(kind=psb_ipk_) :: itmax integer(kind=psb_ipk_) :: itrace integer(kind=psb_ipk_) :: irst real(kind=psb_dpk_) :: eps","tags":"","loc":"interface/get_parms.html"},{"title":"get_parms – PSFUN","text":"subroutine get_parms(ctxt, mname, rhs_file, filefmt, part, afmt, fname, variant, scaling, eps, itmax, itrace, istop) This subroutine reads the parameters needed to run the arnolditest\n program from standard input Arguments Type Intent Optional Attributes Name type(psb_ctxt_type), intent(in) :: ctxt character(len=*), intent(out) :: mname character(len=*), intent(out) :: rhs_file character(len=*), intent(out) :: filefmt character(len=*), intent(out) :: part character(len=*), intent(out) :: afmt character(len=*), intent(out) :: fname character(len=*), intent(out) :: variant real(kind=psb_dpk_), intent(out) :: scaling real(kind=psb_dpk_), intent(out) :: eps integer(kind=psb_ipk_), intent(out) :: itmax integer(kind=psb_ipk_), intent(out) :: itrace integer(kind=psb_ipk_), intent(out) :: istop Calls proc~~get_parms~~CallsGraph proc~get_parms get_parms psb_bcast psb_bcast proc~get_parms->psb_bcast psb_info psb_info proc~get_parms->psb_info proc~pr_usage pr_usage proc~get_parms->proc~pr_usage psb_abort psb_abort proc~get_parms->psb_abort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~get_parms~~CalledByGraph proc~get_parms get_parms program~arnolditest arnolditest program~arnolditest->proc~get_parms Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_parms.html"},{"title":"pr_usage – PSFUN","text":"subroutine pr_usage(iout) Prints out information on incorrected program usage Arguments Type Intent Optional Attributes Name integer(kind=psb_ipk_) :: iout Called by proc~~pr_usage~~CalledByGraph proc~pr_usage pr_usage proc~get_parms get_parms proc~get_parms->proc~pr_usage program~arnolditest arnolditest program~arnolditest->proc~get_parms Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/pr_usage.html"},{"title":"get_parms – PSFUN","text":"subroutine get_parms(ctxt, mname, rhs_file, filefmt, part, afmt, fname, variant, scaling, eps, itmax, itrace, istop) This subroutine reads the parameters needed to run the lanczostest\n program from standard input Arguments Type Intent Optional Attributes Name type(psb_ctxt_type), intent(in) :: ctxt character(len=*), intent(out) :: mname character(len=*), intent(out) :: rhs_file character(len=*), intent(out) :: filefmt character(len=*), intent(out) :: part character(len=*), intent(out) :: afmt character(len=*), intent(out) :: fname character(len=*), intent(out) :: variant real(kind=psb_dpk_), intent(out) :: scaling real(kind=psb_dpk_), intent(out) :: eps integer(kind=psb_ipk_), intent(out) :: itmax integer(kind=psb_ipk_), intent(out) :: itrace integer(kind=psb_ipk_), intent(out) :: istop Calls proc~~get_parms~2~~CallsGraph proc~get_parms~2 get_parms psb_bcast psb_bcast proc~get_parms~2->psb_bcast psb_info psb_info proc~get_parms~2->psb_info proc~pr_usage~2 pr_usage proc~get_parms~2->proc~pr_usage~2 psb_abort psb_abort proc~get_parms~2->psb_abort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~get_parms~2~~CalledByGraph proc~get_parms~2 get_parms program~lanczostest lanczostest program~lanczostest->proc~get_parms~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_parms~2.html"},{"title":"pr_usage – PSFUN","text":"subroutine pr_usage(iout) Prints out information on incorrected program usage Arguments Type Intent Optional Attributes Name integer(kind=psb_ipk_) :: iout Called by proc~~pr_usage~2~~CalledByGraph proc~pr_usage~2 pr_usage proc~get_parms~2 get_parms proc~get_parms~2->proc~pr_usage~2 program~lanczostest lanczostest program~lanczostest->proc~get_parms~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/pr_usage~2.html"},{"title":"get_parms – PSFUN","text":"subroutine get_parms(ctxt, mname, fname, variant, scaling, dump) This subroutine reads the parameters needed to run the serialtest\n program from standard input Arguments Type Intent Optional Attributes Name type(psb_ctxt_type), intent(in) :: ctxt character(len=*), intent(out) :: mname character(len=*), intent(out) :: fname character(len=*), intent(out) :: variant real(kind=psb_dpk_), intent(out) :: scaling logical, intent(out) :: dump Calls proc~~get_parms~3~~CallsGraph proc~get_parms~3 get_parms proc~pr_usage~3 pr_usage proc~get_parms~3->proc~pr_usage~3 psb_toupper psb_toupper proc~get_parms~3->psb_toupper psb_abort psb_abort proc~get_parms~3->psb_abort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~get_parms~3~~CalledByGraph proc~get_parms~3 get_parms program~serialtest serialtest program~serialtest->proc~get_parms~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/get_parms~3.html"},{"title":"pr_usage – PSFUN","text":"subroutine pr_usage(iout) Prints out information on incorrected program usage Arguments Type Intent Optional Attributes Name integer(kind=psb_ipk_) :: iout Called by proc~~pr_usage~3~~CalledByGraph proc~pr_usage~3 pr_usage proc~get_parms~3 get_parms proc~get_parms~3->proc~pr_usage~3 program~serialtest serialtest program~serialtest->proc~get_parms~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/pr_usage~3.html"},{"title":"psfun_z_computepoles – PSFUN","text":"public subroutine psfun_z_computepoles(quad, quadformula, zfun, N, info, cparams, rparams) Uses psb_base_mod proc~~psfun_z_computepoles~~UsesGraph proc~psfun_z_computepoles psfun_z_computepoles psb_base_mod psb_base_mod proc~psfun_z_computepoles->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Compute the poles for a given combination of quadrature rule and\n quadrature formula Arguments Type Intent Optional Attributes Name class( psfun_z_quadrature ), intent(inout) :: quad Quadrature type procedure( zquadrule ), intent(in), pointer :: quadformula Quadrature formula procedure( zquadfun ), intent(in), pointer :: zfun Function to integrate integer(kind=psb_ipk_), intent(in) :: N Number of poles integer(kind=psb_ipk_), intent(out) :: info Flag on the results complex(kind=psb_dpk_), intent(in), optional dimension(:) :: cparams Optional complex parameters real(kind=psb_dpk_), intent(in), optional dimension(:) :: rparams Optional real parameters Contents None","tags":"","loc":"proc/psfun_z_computepoles.html"},{"title":"psfun_z_quadratureplot – PSFUN","text":"public subroutine psfun_z_quadratureplot(quad, zfun, info, filename) Uses psb_base_mod ogpf proc~~psfun_z_quadratureplot~~UsesGraph proc~psfun_z_quadratureplot psfun_z_quadratureplot ogpf ogpf proc~psfun_z_quadratureplot->ogpf psb_base_mod psb_base_mod proc~psfun_z_quadratureplot->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Plots on the complex plane the quadrature poles, and plots the weights of\n the formula Arguments Type Intent Optional Attributes Name class( psfun_z_quadrature ), intent(in) :: quad Quadrature rule procedure( zquadfun ), intent(in), pointer :: zfun Function to integrate integer(kind=psb_ipk_), intent(out) :: info character(len=*), intent(in), optional :: filename Contents None","tags":"","loc":"proc/psfun_z_quadratureplot.html"},{"title":"psfun_z_setmatrix – PSFUN","text":"public subroutine psfun_z_setmatrix(quad, a) Uses psb_base_mod proc~~psfun_z_setmatrix~~UsesGraph proc~psfun_z_setmatrix psfun_z_setmatrix psb_base_mod psb_base_mod proc~psfun_z_setmatrix->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Set the matrix for Arguments Type Intent Optional Attributes Name class( psfun_z_quadrature ), intent(inout) :: quad Quadrature type type(psb_dspmat_type), target :: a Matrix on which we work Contents None","tags":"","loc":"proc/psfun_z_setmatrix.html"},{"title":"psfun_z_setpreconditioner – PSFUN","text":"public subroutine psfun_z_setpreconditioner(quad, prec) Uses psb_base_mod proc~~psfun_z_setpreconditioner~~UsesGraph proc~psfun_z_setpreconditioner psfun_z_setpreconditioner psb_base_mod psb_base_mod proc~psfun_z_setpreconditioner->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Set the preconditioner to use for the given quadrature formula Arguments Type Intent Optional Attributes Name class( psfun_z_quadrature ), intent(inout) :: quad Quadrature type type(psb_dprec_type), target :: prec Preconditioner for the solution of the associate linear systems Contents None","tags":"","loc":"proc/psfun_z_setpreconditioner.html"},{"title":"hhtmethod1 – PSFUN","text":"public interface hhtmethod1 Method 1 of Hale, Nicholas; Higham, Nicholas J.; Trefethen, Lloyd N.\n Computing , and related matrix functions\n by contour integrals. SIAM J. Numer. Anal. 46 (2008), no. 5, 2505--2523. Contents Subroutines hhtmethod1 Subroutines public subroutine hhtmethod1(zfun, xi, c, eta, sign, N, info, cparams, rparams) Arguments Type Intent Optional Attributes Name procedure( zquadfun ), intent(in), pointer :: zfun Function to integrate complex(kind=psb_dpk_), intent(out), allocatable, dimension(:) :: xi Poles of the formula complex(kind=psb_dpk_), intent(out), allocatable, dimension(:) :: c Scaling of the formula real(kind=psb_dpk_), intent(out) :: eta Global Scaling real(kind=psb_dpk_), intent(out) :: sign Sign for A integer(kind=psb_ipk_), intent(in) :: N Number of Poles integer(kind=psb_ipk_), intent(out) :: info Flag on the results complex(kind=psb_dpk_), intent(in), optional dimension(:) :: cparams Optional complex parameters real(kind=psb_dpk_), intent(in), optional dimension(:) :: rparams Optional real parameters","tags":"","loc":"interface/hhtmethod1.html"},{"title":"psfun_d_quadratureplot – PSFUN","text":"public subroutine psfun_d_quadratureplot(quad, dfun, filename, info) Uses psb_base_mod ogpf proc~~psfun_d_quadratureplot~~UsesGraph proc~psfun_d_quadratureplot psfun_d_quadratureplot ogpf ogpf proc~psfun_d_quadratureplot->ogpf psb_base_mod psb_base_mod proc~psfun_d_quadratureplot->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Plots on the complex plane the quadrature poles, and plots the weights of\n the formula Arguments Type Intent Optional Attributes Name class( psfun_d_quadrature ), intent(in) :: quad Quadrature rule procedure( dquadfun ), intent(in), pointer :: dfun Function to integrate character(len=*), intent(in), optional :: filename Filename for the figure integer(kind=psb_ipk_), intent(out) :: info Result of the plot Contents None","tags":"","loc":"proc/psfun_d_quadratureplot.html"},{"title":"psfun_dkrylov_vect – PSFUN","text":"public subroutine psfun_dkrylov_vect(method, a, prec, b, eta, zeta, x, eps, desc_a, info, itmax, iter, err, itrace, irst, istop, cond) Uses psb_base_mod psb_prec_mod proc~~psfun_dkrylov_vect~~UsesGraph proc~psfun_dkrylov_vect psfun_dkrylov_vect psb_base_mod psb_base_mod proc~psfun_dkrylov_vect->psb_base_mod psb_prec_mod psb_prec_mod proc~psfun_dkrylov_vect->psb_prec_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Apply Krylov method to on distributed vectors Arguments Type Intent Optional Attributes Name character(len=*) :: method type(psb_dspmat_type), intent(in) :: a class(psb_dprec_type), intent(inout) :: prec type(psb_d_vect_type), intent(inout) :: b real(kind=psb_dpk_), intent(in) :: eta real(kind=psb_dpk_), intent(in) :: zeta type(psb_d_vect_type), intent(inout) :: x real(kind=psb_dpk_), intent(in) :: eps type(psb_desc_type), intent(in) :: desc_a integer(kind=psb_ipk_), intent(out) :: info integer(kind=psb_ipk_), intent(in), optional :: itmax integer(kind=psb_ipk_), intent(out), optional :: iter real(kind=psb_dpk_), intent(out), optional :: err integer(kind=psb_ipk_), intent(in), optional :: itrace integer(kind=psb_ipk_), intent(in), optional :: irst integer(kind=psb_ipk_), intent(in), optional :: istop real(kind=psb_dpk_), intent(out), optional :: cond Calls proc~~psfun_dkrylov_vect~~CallsGraph proc~psfun_dkrylov_vect psfun_dkrylov_vect psb_erractionsave psb_erractionsave proc~psfun_dkrylov_vect->psb_erractionsave psb_toupper psb_toupper proc~psfun_dkrylov_vect->psb_toupper psb_info psb_info proc~psfun_dkrylov_vect->psb_info psb_erractionrestore psb_erractionrestore proc~psfun_dkrylov_vect->psb_erractionrestore Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~psfun_dkrylov_vect~~CalledByGraph proc~psfun_dkrylov_vect psfun_dkrylov_vect interface~psb_krylov psb_krylov interface~psb_krylov->proc~psfun_dkrylov_vect program~shiftedtest shiftedtest program~shiftedtest->interface~psb_krylov Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/psfun_dkrylov_vect.html"},{"title":"psb_krylov – PSFUN","text":"public interface psb_krylov We add the methods for the shifted system to the same interfaces in PSBLAS\n it is a lazy way to avoid modifying all the Krylov methods in PSBLAS to\n allow for the solution of shifted linear systems Calls interface~~psb_krylov~~CallsGraph interface~psb_krylov psb_krylov proc~psfun_dkrylov_vect psfun_dkrylov_vect interface~psb_krylov->proc~psfun_dkrylov_vect psb_erractionsave psb_erractionsave proc~psfun_dkrylov_vect->psb_erractionsave psb_toupper psb_toupper proc~psfun_dkrylov_vect->psb_toupper psb_info psb_info proc~psfun_dkrylov_vect->psb_info psb_erractionrestore psb_erractionrestore proc~psfun_dkrylov_vect->psb_erractionrestore Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~psb_krylov~~CalledByGraph interface~psb_krylov psb_krylov program~shiftedtest shiftedtest program~shiftedtest->interface~psb_krylov Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures psfun_dkrylov_vect Module Procedures public subroutine psfun_dkrylov_vect (method, a, prec, b, eta, zeta, x, eps, desc_a, info, itmax, iter, err, itrace, irst, istop, cond) Apply Krylov method to on distributed vectors Arguments Type Intent Optional Attributes Name character(len=*) :: method type(psb_dspmat_type), intent(in) :: a class(psb_dprec_type), intent(inout) :: prec type(psb_d_vect_type), intent(inout) :: b real(kind=psb_dpk_), intent(in) :: eta real(kind=psb_dpk_), intent(in) :: zeta type(psb_d_vect_type), intent(inout) :: x real(kind=psb_dpk_), intent(in) :: eps type(psb_desc_type), intent(in) :: desc_a integer(kind=psb_ipk_), intent(out) :: info integer(kind=psb_ipk_), intent(in), optional :: itmax integer(kind=psb_ipk_), intent(out), optional :: iter real(kind=psb_dpk_), intent(out), optional :: err integer(kind=psb_ipk_), intent(in), optional :: itrace integer(kind=psb_ipk_), intent(in), optional :: irst integer(kind=psb_ipk_), intent(in), optional :: istop real(kind=psb_dpk_), intent(out), optional :: cond","tags":"","loc":"interface/psb_krylov.html"},{"title":"psfun_d_parallel_apply – PSFUN","text":"public subroutine psfun_d_parallel_apply(meth, fun, a, desc_a, y, x, eps, info, itmax, itrace, istop, iter, err, res) Uses psb_base_mod psb_prec_mod amg_prec_mod psfun_d_serial_mod proc~~psfun_d_parallel_apply~~UsesGraph proc~psfun_d_parallel_apply psfun_d_parallel_apply amg_prec_mod amg_prec_mod proc~psfun_d_parallel_apply->amg_prec_mod psb_base_mod psb_base_mod proc~psfun_d_parallel_apply->psb_base_mod module~psfun_d_serial_mod psfun_d_serial_mod proc~psfun_d_parallel_apply->module~psfun_d_serial_mod psb_prec_mod psb_prec_mod proc~psfun_d_parallel_apply->psb_prec_mod module~psfun_d_serial_mod->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This is the generic function for applying every implemented Krylov\n method. The general iteration parameters (like the number of iteration,\n the stop criterion to be used, and the verbosity of the trace) can be\n passed directly to this routine. All the constitutive parameters of\n the actual method, and the information relative to the function are\n instead contained in the meth and fun objects. The Descriptor object\n `desc_a' contains the properties of the parallel environment. Arguments Type Intent Optional Attributes Name class( psfun_d_krylov ), intent(inout) :: meth Krylov method object type( psfun_d_serial ), intent(inout) :: fun Function object type(psb_dspmat_type), intent(in) :: a Distribute sparse matrix type(psb_desc_type), intent(in) :: desc_a Descriptor for the sparse matrix type(psb_d_vect_type), intent(inout) :: y Output vector type(psb_d_vect_type), intent(inout) :: x Input vector real(kind=psb_dpk_), intent(in) :: eps Requested tolerance integer(kind=psb_ipk_), intent(out) :: info Output flag integer(kind=psb_ipk_), intent(in), optional :: itmax Maximum number of iteration integer(kind=psb_ipk_), intent(in), optional :: itrace Trace for logoutput integer(kind=psb_ipk_), intent(in), optional :: istop Stop criterion integer(kind=psb_ipk_), intent(out), optional :: iter Number of iteration real(kind=psb_dpk_), intent(out), optional :: err Last estimate error real(kind=psb_dpk_), intent(out), optional allocatable :: res (:) Vector of the residuals Calls proc~~psfun_d_parallel_apply~~CallsGraph proc~psfun_d_parallel_apply psfun_d_parallel_apply interface~psfun_d_lanczos psfun_d_lanczos proc~psfun_d_parallel_apply->interface~psfun_d_lanczos interface~psfun_d_arnoldi psfun_d_arnoldi proc~psfun_d_parallel_apply->interface~psfun_d_arnoldi psb_toupper psb_toupper proc~psfun_d_parallel_apply->psb_toupper interface~psfun_d_saiarnoldi psfun_d_saiarnoldi proc~psfun_d_parallel_apply->interface~psfun_d_saiarnoldi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/psfun_d_parallel_apply.html"},{"title":"psfun_d_plot_info – PSFUN","text":"public subroutine psfun_d_plot_info(meth, fun, iter, res, info) Uses psb_base_mod ogpf proc~~psfun_d_plot_info~~UsesGraph proc~psfun_d_plot_info psfun_d_plot_info ogpf ogpf proc~psfun_d_plot_info->ogpf psb_base_mod psb_base_mod proc~psfun_d_plot_info->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This function plots the convergence history of the Krylov method Arguments Type Intent Optional Attributes Name class( psfun_d_krylov ), intent(inout) :: meth Krylov method type( psfun_d_serial ), intent(inout) :: fun Function object integer(kind=psb_ipk_), intent(in) :: iter Number of iteration real(kind=psb_dpk_), intent(in), dimension(:) :: res Residual vector integer(kind=psb_ipk_), intent(out) :: info Result of the Gnuplot call Contents None","tags":"","loc":"proc/psfun_d_plot_info.html"},{"title":"psfun_d_prec_build – PSFUN","text":"public subroutine psfun_d_prec_build(meth, a, desc_a, info) Uses psb_base_mod amg_prec_mod proc~~psfun_d_prec_build~~UsesGraph proc~psfun_d_prec_build psfun_d_prec_build amg_prec_mod amg_prec_mod proc~psfun_d_prec_build->amg_prec_mod psb_base_mod psb_base_mod proc~psfun_d_prec_build->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This function builds the AMG4PSBLAS preconditioner for the inner solve\n in a Rational Krylov method Arguments Type Intent Optional Attributes Name class( psfun_d_krylov ), intent(inout) :: meth Krylov method type(psb_dspmat_type), intent(inout) :: a Sparse matrix type(psb_desc_type), intent(inout) :: desc_a Descriptor for the sparse matrix integer(kind=psb_ipk_) :: info Result of the init call Calls proc~~psfun_d_prec_build~~CallsGraph proc~psfun_d_prec_build psfun_d_prec_build psb_erractionsave psb_erractionsave proc~psfun_d_prec_build->psb_erractionsave psb_errpush psb_errpush proc~psfun_d_prec_build->psb_errpush psb_erractionrestore psb_erractionrestore proc~psfun_d_prec_build->psb_erractionrestore Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/psfun_d_prec_build.html"},{"title":"psfun_d_prec_init – PSFUN","text":"public subroutine psfun_d_prec_init(meth, ctxt, ptype, info) Uses psb_base_mod amg_prec_mod proc~~psfun_d_prec_init~~UsesGraph proc~psfun_d_prec_init psfun_d_prec_init amg_prec_mod amg_prec_mod proc~psfun_d_prec_init->amg_prec_mod psb_base_mod psb_base_mod proc~psfun_d_prec_init->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This function performs the init of the preconditioner for the inner\n solve in the rational Krylov method Arguments Type Intent Optional Attributes Name class( psfun_d_krylov ), intent(inout) :: meth Krylov method type(psb_ctxt_type), intent(in) :: ctxt Parallel context character(len=20), intent(in) :: ptype PSBLAS/AMG4PSBLAS preconditioner integer(kind=psb_ipk_) :: info Result of the init call Calls proc~~psfun_d_prec_init~~CallsGraph proc~psfun_d_prec_init psfun_d_prec_init psb_erractionsave psb_erractionsave proc~psfun_d_prec_init->psb_erractionsave psb_errpush psb_errpush proc~psfun_d_prec_init->psb_errpush psb_erractionrestore psb_erractionrestore proc~psfun_d_prec_init->psb_erractionrestore Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/psfun_d_prec_init.html"},{"title":"psfun_d_arnoldi – PSFUN","text":"interface Simple polynomial method based on the Arnoldi orthogonalization procedure,\n the method builds a basis for the Krylov subspace Called by interface~~psfun_d_arnoldi~~CalledByGraph interface~psfun_d_arnoldi psfun_d_arnoldi proc~psfun_d_parallel_apply psfun_d_parallel_apply proc~psfun_d_parallel_apply->interface~psfun_d_arnoldi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public module subroutine psfun_d_arnoldi(fun, a, desc_a, y, x, eps, info, itmax, itrace, istop, iter, err, res) Arguments Type Intent Optional Attributes Name type( psfun_d_serial ), intent(inout) :: fun Function object type(psb_dspmat_type), intent(in) :: a Distribute sparse matrix type(psb_desc_type), intent(in) :: desc_a Descriptor for the sparse matrix type(psb_d_vect_type), intent(inout) :: y Output vector type(psb_d_vect_type), intent(inout) :: x Input vector real(kind=psb_dpk_), intent(in) :: eps Requested tolerance integer(kind=psb_ipk_), intent(out) :: info Output flag integer(kind=psb_ipk_), intent(in), optional :: itmax Maximum number of iteration integer(kind=psb_ipk_), intent(in), optional :: itrace Trace for logoutput integer(kind=psb_ipk_), intent(in), optional :: istop Stop criterion integer(kind=psb_ipk_), intent(out), optional :: iter Number of iteration real(kind=psb_dpk_), intent(out), optional :: err Last estimate error real(kind=psb_dpk_), intent(out), optional allocatable :: res (:) Vector of the residuals Description Simple polynomial method based on the Arnoldi orthogonalization procedure,\n the method builds a basis for the Krylov subspace and approximates ,for , the first vector of the canonical\n base of , and the Hessemberg matrix given\n by .","tags":"","loc":"interface/psfun_d_arnoldi.html"},{"title":"psfun_d_lanczos – PSFUN","text":"interface Simple polynomial method based on the Lanczos orthogonalization procedure,\n the method builds a basis for the Krylov subspace Called by interface~~psfun_d_lanczos~~CalledByGraph interface~psfun_d_lanczos psfun_d_lanczos proc~psfun_d_parallel_apply psfun_d_parallel_apply proc~psfun_d_parallel_apply->interface~psfun_d_lanczos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public module subroutine psfun_d_lanczos(fun, a, desc_a, y, x, eps, info, itmax, itrace, istop, iter, err, res) Arguments Type Intent Optional Attributes Name type( psfun_d_serial ), intent(inout) :: fun Function object type(psb_dspmat_type), intent(in) :: a Distribute sparse matrix type(psb_desc_type), intent(in) :: desc_a Descriptor for the sparse matrix type(psb_d_vect_type), intent(inout) :: y Output vector type(psb_d_vect_type), intent(inout) :: x Input vector real(kind=psb_dpk_), intent(in) :: eps Requested tolerance integer(kind=psb_ipk_), intent(out) :: info Output flag integer(kind=psb_ipk_), intent(in), optional :: itmax Maximum number of iteration integer(kind=psb_ipk_), intent(in), optional :: itrace Trace for logoutput integer(kind=psb_ipk_), intent(in), optional :: istop Stop criterion integer(kind=psb_ipk_), intent(out), optional :: iter Number of iteration real(kind=psb_dpk_), intent(out), optional :: err Last estimate error real(kind=psb_dpk_), intent(out), optional allocatable :: res (:) Vector of the residuals Description Simple polynomial method based on the Lanczos orthogonalization procedure,\n the method builds a basis for the Krylov subspace and approximates ,for , the first vector of the canonical\n base of , and the Symmetric tridiagonal\n matrix given by .","tags":"","loc":"interface/psfun_d_lanczos.html"},{"title":"psfun_d_saiarnoldi – PSFUN","text":"interface This interface contains the Shift-and-Invert method based on Arnoldi\n orthogonalization. Called by interface~~psfun_d_saiarnoldi~~CalledByGraph interface~psfun_d_saiarnoldi psfun_d_saiarnoldi proc~psfun_d_parallel_apply psfun_d_parallel_apply proc~psfun_d_parallel_apply->interface~psfun_d_saiarnoldi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public module subroutine psfun_d_saiarnoldi(fun, a, kryl, prec, tau, desc_a, initmax, initrace, inistop, y, x, eps, info, itmax, itrace, istop, iter, err, res) Arguments Type Intent Optional Attributes Name type( psfun_d_serial ), intent(inout) :: fun Function object type(psb_dspmat_type), intent(in) :: a Distribute sparse matrix character(len=*), intent(in) :: kryl Krylov method for the solution of inner systems type(amg_dprec_type), intent(inout) :: prec Preconditioner for the inner method real(kind=psb_dpk_), intent(in) :: tau Shift parameter of the method type(psb_desc_type), intent(in) :: desc_a Descriptor for the sparse matrix integer(kind=psb_ipk_), intent(in) :: initmax Maximum number of iteration (inner method) integer(kind=psb_ipk_), intent(in) :: initrace Trace for logoutput (inner method) integer(kind=psb_ipk_), intent(in) :: inistop Stop criterion (inner method) type(psb_d_vect_type), intent(inout) :: y Output vector type(psb_d_vect_type), intent(inout) :: x Input vector real(kind=psb_dpk_), intent(in) :: eps Requested tolerance integer(kind=psb_ipk_), intent(out) :: info Output flag integer(kind=psb_ipk_), intent(in), optional :: itmax Maximum number of iteration integer(kind=psb_ipk_), intent(in), optional :: itrace Trace for logoutput integer(kind=psb_ipk_), intent(in), optional :: istop Stop criterion integer(kind=psb_ipk_), intent(out), optional :: iter Number of iteration real(kind=psb_dpk_), intent(out), optional :: err Last estimate error real(kind=psb_dpk_), intent(out), optional allocatable :: res (:) Vector of the residuals Description Shift-and-invert method based on the Arnoldi orthogonalization procedure\n the method builds a basis for the shifted Krylov subspace and approximate ,for , the first vector of the canonical\n base of , and the Hessemberg matrix given\n by the projection of into the subspace . To  march the algorithm one needs to solve at each step a shifted linear\n system for which we employ the routines from psfun_krylov_mod and the\n preconditioners from AMG4PSBLAS.","tags":"","loc":"interface/psfun_d_saiarnoldi.html"},{"title":"ellipj – PSFUN","text":"public interface ellipj Returns the values of the Jacobi elliptic functions evaluated at real or complex argument u and parameter , . For , and the elliptic modulus. Called by interface~~ellipj~~CalledByGraph interface~ellipj ellipj program~utiltest utiltest program~utiltest->interface~ellipj Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines d_ellipj z_ellipj Subroutines public subroutine d_ellipj(u, L, sn, cn, dn) Arguments Type Intent Optional Attributes Name real(kind=psb_dpk_), intent(in) :: u real(kind=psb_dpk_), intent(in) :: L real(kind=psb_dpk_), intent(out) :: sn real(kind=psb_dpk_), intent(out) :: cn real(kind=psb_dpk_), intent(out) :: dn public recursive subroutine z_ellipj(u, L, sn, cn, dn, flag) Arguments Type Intent Optional Attributes Name complex(kind=psb_dpk_), intent(in) :: u real(kind=psb_dpk_), intent(in) :: L complex(kind=psb_dpk_), intent(out) :: sn complex(kind=psb_dpk_), intent(out) :: cn complex(kind=psb_dpk_), intent(out) :: dn logical, intent(in), optional :: flag","tags":"","loc":"interface/ellipj.html"},{"title":"ellipkkp – PSFUN","text":"public interface ellipkkp Complete elliptic integral of the first kind, with complement.\n Returns the value of the complete elliptic integral of the first kind,\n evaluated at , , and the\n complementarity parameter . Contents Functions ellipkkp Functions public function ellipkkp(L) result(K) Arguments Type Intent Optional Attributes Name real(kind=psb_dpk_), intent(in) :: L Return Value real(kind=psb_dpk_)\n  (2)","tags":"","loc":"interface/ellipkkp.html"},{"title":"horner – PSFUN","text":"public interface horner Apply Horner rule to evaluate a polynomial Contents Functions horner Functions public function horner(coeffs, x) result(res) Arguments Type Intent Optional Attributes Name real(kind=psb_dpk_), intent(in), dimension (:) :: coeffs Coefficient of the polynomial real(kind=psb_dpk_), intent(in) :: x Where to evaluate Return Value real(kind=psb_dpk_) Result","tags":"","loc":"interface/horner.html"},{"title":"psfun_d_serial_apply_array – PSFUN","text":"public subroutine psfun_d_serial_apply_array(fun, a, y, x, info) Uses psb_base_mod proc~~psfun_d_serial_apply_array~~UsesGraph proc~psfun_d_serial_apply_array psfun_d_serial_apply_array psb_base_mod psb_base_mod proc~psfun_d_serial_apply_array->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This is the core of the function apply on a serial matrix to compute . It calls on the specific routines\n implementing the different functions. It is the function to modify if\n ones want to interface a new function that was not previously\n available or a new algorithm (variant) for an already existing\n function. INTERFACE for the John Burkardt Taylor code for\n the matrix exponential. INTERFACE for the John Burkardt scaling and squaring code for\n the matrix exponential. INTERFACE for the EXPOKIT package computes the matrix\n exponential using the irreducible rational Pade approximation\n to the exponential function exp(x) = r(x) = (+/-)( I + 2*(q(x)/p(x)) ),\n combined with scaling-and-squaring. INTERFACE for the EXPOKIT package computes the matrix\n exponential using the partial fraction expansion of the\n uniform rational Chebyshev approximation for an Hessenberg\n matrix. INTERFACE for the EXPOKIT package computes the matrix\n exponential using the partial fraction expansion of the\n uniform rational Chebyshev approximation for a general\n matrix. INTERFACE for the EXPOKIT package computes the matrix\n exponential using the partial fraction expansion of the\n uniform rational Chebyshev approximation for a symmetric\n matrix. For a symmetric matrix we need only to compute the function\n values, and not also its derivatives. We use LAPACK to compute\n the Schur decomposition of the input matrix, apply f on the\n eigenvalues and return the computation Arguments Type Intent Optional Attributes Name class( psfun_d_serial ), intent(inout) :: fun Function information real(kind=psb_dpk_), intent(in) :: a (:,:) Matrix real(kind=psb_dpk_), intent(out) :: y (:) Output vector real(kind=psb_dpk_), intent(in) :: x (:) Input vector integer(kind=psb_ipk_), intent(out) :: info Information on the output local variables Calls proc~~psfun_d_serial_apply_array~~CallsGraph proc~psfun_d_serial_apply_array psfun_d_serial_apply_array psb_erractionsave psb_erractionsave proc~psfun_d_serial_apply_array->psb_erractionsave r8mat_expm1 r8mat_expm1 proc~psfun_d_serial_apply_array->r8mat_expm1 r8mat_expm2 r8mat_expm2 proc~psfun_d_serial_apply_array->r8mat_expm2 dnchbv dnchbv proc~psfun_d_serial_apply_array->dnchbv dschbv dschbv proc~psfun_d_serial_apply_array->dschbv dgpadm dgpadm proc~psfun_d_serial_apply_array->dgpadm dgchbv dgchbv proc~psfun_d_serial_apply_array->dgchbv psb_erractionrestore psb_erractionrestore proc~psfun_d_serial_apply_array->psb_erractionrestore dsyev dsyev proc~psfun_d_serial_apply_array->dsyev dgemv dgemv proc~psfun_d_serial_apply_array->dgemv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/psfun_d_serial_apply_array.html"},{"title":"psfun_d_serial_apply_sparse – PSFUN","text":"public subroutine psfun_d_serial_apply_sparse(fun, a, y, x, info) Uses psb_base_mod proc~~psfun_d_serial_apply_sparse~~UsesGraph proc~psfun_d_serial_apply_sparse psfun_d_serial_apply_sparse psb_base_mod psb_base_mod proc~psfun_d_serial_apply_sparse->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This is the core of the function apply on a serial matrix to compute when A is memorized in a sparse storage.\n In this case the routine converts it to a dense storage and then calls\n the array version of itself. That is the one implementing the\n different functions. It is the function to modify if ones want to\n interface a new function that was not previously available or a new\n algorithm (variant) for an already existing function. Arguments Type Intent Optional Attributes Name class( psfun_d_serial ), intent(inout) :: fun Function information type(psb_dspmat_type), intent(inout) :: a Matrix real(kind=psb_dpk_), intent(out) :: y (:) Output vector real(kind=psb_dpk_), intent(in) :: x (:) Input vector integer(kind=psb_ipk_), intent(out) :: info Information on the output Contents None","tags":"","loc":"proc/psfun_d_serial_apply_sparse.html"},{"title":"getp – PSFUN","text":"This moodule contaings the subroutine to read parameters needed to run the\n shiftedkrylov program from standard input Used by module~~getp~~UsedByGraph module~getp getp program~shiftedtest shiftedtest program~shiftedtest->module~getp Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces get_parms Subroutines get_dparms Interfaces public interface get_parms Get iteration parameters from the command line public subroutine get_dparms (ctxt, mtrx_file, rhs_file, eta, zeta, filefmt, kmethd, ptype, part, afmt, istopc, itmax, itrace, irst, eps) Get iteration parameters from the command line Arguments Type Intent Optional Attributes Name type(psb_ctxt_type) :: ctxt Parallel context character(len=40) :: mtrx_file character(len=40) :: rhs_file real(kind=psb_dpk_) :: eta real(kind=psb_dpk_) :: zeta character(len=2) :: filefmt Format of the file character(len=40) :: kmethd character(len=40) :: ptype character(len=20) :: part character :: afmt *5 integer(kind=psb_ipk_) :: istopc integer(kind=psb_ipk_) :: itmax integer(kind=psb_ipk_) :: itrace integer(kind=psb_ipk_) :: irst real(kind=psb_dpk_) :: eps Subroutines public subroutine get_dparms (ctxt, mtrx_file, rhs_file, eta, zeta, filefmt, kmethd, ptype, part, afmt, istopc, itmax, itrace, irst, eps) Get iteration parameters from the command line Arguments Type Intent Optional Attributes Name type(psb_ctxt_type) :: ctxt Parallel context character(len=40) :: mtrx_file character(len=40) :: rhs_file real(kind=psb_dpk_) :: eta real(kind=psb_dpk_) :: zeta character(len=2) :: filefmt Format of the file character(len=40) :: kmethd character(len=40) :: ptype character(len=20) :: part character :: afmt *5 integer(kind=psb_ipk_) :: istopc integer(kind=psb_ipk_) :: itmax integer(kind=psb_ipk_) :: itrace integer(kind=psb_ipk_) :: irst real(kind=psb_dpk_) :: eps","tags":"","loc":"module/getp.html"},{"title":"psfun_z_quadrature_mod – PSFUN","text":"This module computes the matrix-function vector product by means of the\n approximation of based on quadrature formula, i.e.,\n having computed the poles and the scalings of the formula solves linear\n systems to approximate the product. Uses psfun_base_quadrature_mod psb_base_mod psfun_utils_mod ogpf module~~psfun_z_quadrature_mod~~UsesGraph module~psfun_z_quadrature_mod psfun_z_quadrature_mod ogpf ogpf module~psfun_z_quadrature_mod->ogpf psb_base_mod psb_base_mod module~psfun_z_quadrature_mod->psb_base_mod module~psfun_base_quadrature_mod psfun_base_quadrature_mod module~psfun_z_quadrature_mod->module~psfun_base_quadrature_mod module~psfun_utils_mod psfun_utils_mod module~psfun_z_quadrature_mod->module~psfun_utils_mod module~psfun_base_quadrature_mod->psb_base_mod module~psfun_base_quadrature_mod->module~psfun_utils_mod psb_krylov_mod psb_krylov_mod module~psfun_base_quadrature_mod->psb_krylov_mod psb_prec_mod psb_prec_mod module~psfun_base_quadrature_mod->psb_prec_mod module~psfun_utils_mod->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: psfun_z_quadrules_mod module~~psfun_z_quadrature_mod~~UsedByGraph module~psfun_z_quadrature_mod psfun_z_quadrature_mod module~psfun_z_quadrules_mod psfun_z_quadrules_mod module~psfun_z_quadrules_mod->module~psfun_z_quadrature_mod module~psfun_quadrature_mod psfun_quadrature_mod module~psfun_quadrature_mod->module~psfun_z_quadrature_mod program~quadraturetest quadraturetest program~quadraturetest->module~psfun_quadrature_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces hhtmethod1 Abstract Interfaces zquadfun zquadrule Derived Types psfun_z_quadrature Subroutines psfun_z_computepoles psfun_z_quadratureplot psfun_z_setmatrix psfun_z_setpreconditioner Interfaces public interface hhtmethod1 Method 1 of Hale, Nicholas; Higham, Nicholas J.; Trefethen, Lloyd N.\n Computing , and related matrix functions\n by contour integrals. SIAM J. Numer. Anal. 46 (2008), no. 5, 2505--2523. public subroutine hhtmethod1(zfun, xi, c, eta, sign, N, info, cparams, rparams) Arguments Type Intent Optional Attributes Name procedure( zquadfun ), intent(in), pointer :: zfun Function to integrate complex(kind=psb_dpk_), intent(out), allocatable, dimension(:) :: xi Poles of the formula complex(kind=psb_dpk_), intent(out), allocatable, dimension(:) :: c Scaling of the formula real(kind=psb_dpk_), intent(out) :: eta Global Scaling real(kind=psb_dpk_), intent(out) :: sign Sign for A integer(kind=psb_ipk_), intent(in) :: N Number of Poles integer(kind=psb_ipk_), intent(out) :: info Flag on the results complex(kind=psb_dpk_), intent(in), optional dimension(:) :: cparams Optional complex parameters real(kind=psb_dpk_), intent(in), optional dimension(:) :: rparams Optional real parameters Abstract Interfaces abstract interface public function zquadfun(z) result(res) Arguments Type Intent Optional Attributes Name complex(kind=psb_dpk_), intent(in) :: z Return Value complex(kind=psb_dpk_) abstract interface public subroutine zquadrule(zfun, xi, c, eta, sign, N, info, cparams, rparams) To integrate a function that take as inputs complex number and gives as output\n complex numbers Arguments Type Intent Optional Attributes Name procedure( zquadfun ), intent(in), pointer :: zfun Function to integrate complex(kind=psb_dpk_), intent(out), allocatable, dimension(:) :: xi Poles of the formula complex(kind=psb_dpk_), intent(out), allocatable, dimension(:) :: c Scaling of the formula real(kind=psb_dpk_), intent(out) :: eta Global Scaling real(kind=psb_dpk_), intent(out) :: sign Sign for A integer(kind=psb_ipk_), intent(in) :: N Number of Poles integer(kind=psb_ipk_), intent(out) :: info Flag on the results complex(kind=psb_dpk_), intent(in), optional dimension(:) :: cparams Optional complex parameters real(kind=psb_dpk_), intent(in), optional dimension(:) :: rparams Optional real parameters Derived Types type, public, extends( psfun_quadrature ) :: psfun_z_quadrature Components Type Visibility Attributes Name Initial type(psb_dspmat_type), public, pointer :: a Matrix on which we work complex(kind=psb_dpk_), public, allocatable, dimension(:) :: c Scaling of the formula type(psb_desc_type), public :: desc_a Descriptor for parallel environment real(kind=psb_dpk_), public :: eta Global Scaling type(psb_dprec_type), public, pointer :: prec Preconditioner for the solution of the associate linear systems real(kind=psb_dpk_), public :: sign Sign for complex(kind=psb_dpk_), public, allocatable, dimension(:) :: xi Poles of the formula Type-Bound Procedures procedure, public, pass(quad) :: computepoles => psfun_z_computepoles procedure, public, pass(quad) :: plot => psfun_z_quadratureplot generic, public :: set => setmatrix, setpreconditioner procedure, public, pass(quad) :: setmatrix => psfun_z_setmatrix procedure, public, pass(quad) :: setpreconditioner => psfun_z_setpreconditioner Subroutines public subroutine psfun_z_computepoles (quad, quadformula, zfun, N, info, cparams, rparams) Compute the poles for a given combination of quadrature rule and\n quadrature formula Arguments Type Intent Optional Attributes Name class( psfun_z_quadrature ), intent(inout) :: quad Quadrature type procedure( zquadrule ), intent(in), pointer :: quadformula Quadrature formula procedure( zquadfun ), intent(in), pointer :: zfun Function to integrate integer(kind=psb_ipk_), intent(in) :: N Number of poles integer(kind=psb_ipk_), intent(out) :: info Flag on the results complex(kind=psb_dpk_), intent(in), optional dimension(:) :: cparams Optional complex parameters real(kind=psb_dpk_), intent(in), optional dimension(:) :: rparams Optional real parameters public subroutine psfun_z_quadratureplot (quad, zfun, info, filename) Plots on the complex plane the quadrature poles, and plots the weights of\n the formula Arguments Type Intent Optional Attributes Name class( psfun_z_quadrature ), intent(in) :: quad Quadrature rule procedure( zquadfun ), intent(in), pointer :: zfun Function to integrate integer(kind=psb_ipk_), intent(out) :: info character(len=*), intent(in), optional :: filename public subroutine psfun_z_setmatrix (quad, a) Set the matrix for Arguments Type Intent Optional Attributes Name class( psfun_z_quadrature ), intent(inout) :: quad Quadrature type type(psb_dspmat_type), target :: a Matrix on which we work public subroutine psfun_z_setpreconditioner (quad, prec) Set the preconditioner to use for the given quadrature formula Arguments Type Intent Optional Attributes Name class( psfun_z_quadrature ), intent(inout) :: quad Quadrature type type(psb_dprec_type), target :: prec Preconditioner for the solution of the associate linear systems","tags":"","loc":"module/psfun_z_quadrature_mod.html"},{"title":"psfun_base_quadrature_mod – PSFUN","text":"Module containing the implementation of the base method for the computation\n of by means of distributed quadrature formulas. Uses psb_base_mod psb_prec_mod psb_krylov_mod psfun_utils_mod module~~psfun_base_quadrature_mod~~UsesGraph module~psfun_base_quadrature_mod psfun_base_quadrature_mod psb_krylov_mod psb_krylov_mod module~psfun_base_quadrature_mod->psb_krylov_mod psb_base_mod psb_base_mod module~psfun_base_quadrature_mod->psb_base_mod module~psfun_utils_mod psfun_utils_mod module~psfun_base_quadrature_mod->module~psfun_utils_mod psb_prec_mod psb_prec_mod module~psfun_base_quadrature_mod->psb_prec_mod module~psfun_utils_mod->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~psfun_base_quadrature_mod~~UsedByGraph module~psfun_base_quadrature_mod psfun_base_quadrature_mod module~psfun_d_quadrature_mod psfun_d_quadrature_mod module~psfun_d_quadrature_mod->module~psfun_base_quadrature_mod module~psfun_z_quadrature_mod psfun_z_quadrature_mod module~psfun_z_quadrature_mod->module~psfun_base_quadrature_mod module~psfun_quadrature_mod psfun_quadrature_mod module~psfun_quadrature_mod->module~psfun_base_quadrature_mod module~psfun_quadrature_mod->module~psfun_d_quadrature_mod module~psfun_quadrature_mod->module~psfun_z_quadrature_mod module~psfun_z_quadrules_mod psfun_z_quadrules_mod module~psfun_z_quadrules_mod->module~psfun_z_quadrature_mod program~quadraturetest quadraturetest program~quadraturetest->module~psfun_quadrature_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Derived Types psfun_quadrature Derived Types type, public :: psfun_quadrature Components Type Visibility Attributes Name Initial type(psb_desc_type), public :: desc_a Descriptor for parallel environment","tags":"","loc":"module/psfun_base_quadrature_mod.html"},{"title":"psfun_quadrature_mod – PSFUN","text":"This module computes the matrix-function vector product by means of the\n approximation of based on quadrature formula, i.e.,\n having computed the poles and the scalings of the formula solves linear\n systems to approximate the product. Uses psfun_base_quadrature_mod psfun_d_quadrature_mod psfun_z_quadrature_mod module~~psfun_quadrature_mod~~UsesGraph module~psfun_quadrature_mod psfun_quadrature_mod module~psfun_d_quadrature_mod psfun_d_quadrature_mod module~psfun_quadrature_mod->module~psfun_d_quadrature_mod module~psfun_base_quadrature_mod psfun_base_quadrature_mod module~psfun_quadrature_mod->module~psfun_base_quadrature_mod module~psfun_z_quadrature_mod psfun_z_quadrature_mod module~psfun_quadrature_mod->module~psfun_z_quadrature_mod module~psfun_d_quadrature_mod->module~psfun_base_quadrature_mod ogpf ogpf module~psfun_d_quadrature_mod->ogpf psb_base_mod psb_base_mod module~psfun_d_quadrature_mod->psb_base_mod module~psfun_utils_mod psfun_utils_mod module~psfun_d_quadrature_mod->module~psfun_utils_mod psb_krylov_mod psb_krylov_mod module~psfun_base_quadrature_mod->psb_krylov_mod module~psfun_base_quadrature_mod->psb_base_mod module~psfun_base_quadrature_mod->module~psfun_utils_mod psb_prec_mod psb_prec_mod module~psfun_base_quadrature_mod->psb_prec_mod module~psfun_z_quadrature_mod->module~psfun_base_quadrature_mod module~psfun_z_quadrature_mod->ogpf module~psfun_z_quadrature_mod->psb_base_mod module~psfun_z_quadrature_mod->module~psfun_utils_mod module~psfun_utils_mod->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~psfun_quadrature_mod~~UsedByGraph module~psfun_quadrature_mod psfun_quadrature_mod program~quadraturetest quadraturetest program~quadraturetest->module~psfun_quadrature_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/psfun_quadrature_mod.html"},{"title":"psfun_d_quadrature_mod – PSFUN","text":"This module computes the matrix-function vector product by means of the\n approximation of based on quadrature formula, i.e.,\n having computed the poles and the scalings of the formula solves linear\n systems to approximate the product. Uses psfun_base_quadrature_mod psb_base_mod psfun_utils_mod ogpf module~~psfun_d_quadrature_mod~~UsesGraph module~psfun_d_quadrature_mod psfun_d_quadrature_mod ogpf ogpf module~psfun_d_quadrature_mod->ogpf psb_base_mod psb_base_mod module~psfun_d_quadrature_mod->psb_base_mod module~psfun_base_quadrature_mod psfun_base_quadrature_mod module~psfun_d_quadrature_mod->module~psfun_base_quadrature_mod module~psfun_utils_mod psfun_utils_mod module~psfun_d_quadrature_mod->module~psfun_utils_mod module~psfun_base_quadrature_mod->psb_base_mod module~psfun_base_quadrature_mod->module~psfun_utils_mod psb_krylov_mod psb_krylov_mod module~psfun_base_quadrature_mod->psb_krylov_mod psb_prec_mod psb_prec_mod module~psfun_base_quadrature_mod->psb_prec_mod module~psfun_utils_mod->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~psfun_d_quadrature_mod~~UsedByGraph module~psfun_d_quadrature_mod psfun_d_quadrature_mod module~psfun_quadrature_mod psfun_quadrature_mod module~psfun_quadrature_mod->module~psfun_d_quadrature_mod program~quadraturetest quadraturetest program~quadraturetest->module~psfun_quadrature_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Abstract Interfaces dquadfun dquadrule Derived Types psfun_d_quadrature Subroutines psfun_d_quadratureplot Abstract Interfaces abstract interface public function dquadfun(z) result(res) Arguments Type Intent Optional Attributes Name real(kind=psb_dpk_), intent(in) :: z Return Value complex(kind=psb_dpk_) abstract interface public subroutine dquadrule(dfun, xi, c, eta, sign, N, info, cparams, rparams) To integrate a function that take as inputs real numbers and gives as\n output complex numbers Arguments Type Intent Optional Attributes Name procedure( dquadfun ), intent(in), pointer :: dfun Function to integrate complex(kind=psb_dpk_), intent(out), allocatable, dimension(:) :: xi Poles of the formula complex(kind=psb_dpk_), intent(out), allocatable, dimension(:) :: c Scaling of the formula complex(kind=psb_dpk_), intent(out) :: eta Global Scaling complex(kind=psb_dpk_), intent(out) :: sign Sign for A integer(kind=psb_ipk_), intent(in) :: N Number of Poles integer(kind=psb_ipk_), intent(out) :: info Flag on the results complex(kind=psb_dpk_), intent(in), optional dimension(:) :: cparams Optional complex parameters real(kind=psb_dpk_), intent(in), optional dimension(:) :: rparams Optional real parameters Derived Types type, public, extends( psfun_quadrature ) :: psfun_d_quadrature Components Type Visibility Attributes Name Initial type(psb_dspmat_type), public, pointer :: a Matrix on which we work real(kind=psb_dpk_), public, allocatable, dimension(:) :: c Scaling of the formula type(psb_desc_type), public :: desc_a Descriptor for parallel environment real(kind=psb_dpk_), public :: eta Global Scaling type(psb_dprec_type), public :: prec Preconditioner for the solution of the associated linear systems real(kind=psb_dpk_), public :: sign Sign for A real(kind=psb_dpk_), public, allocatable, dimension(:) :: xi Poles of the formula Type-Bound Procedures procedure, public, pass(quad) :: plot => psfun_d_quadratureplot Subroutines public subroutine psfun_d_quadratureplot (quad, dfun, filename, info) Plots on the complex plane the quadrature poles, and plots the weights of\n the formula Arguments Type Intent Optional Attributes Name class( psfun_d_quadrature ), intent(in) :: quad Quadrature rule procedure( dquadfun ), intent(in), pointer :: dfun Function to integrate character(len=*), intent(in), optional :: filename Filename for the figure integer(kind=psb_ipk_), intent(out) :: info Result of the plot","tags":"","loc":"module/psfun_d_quadrature_mod.html"},{"title":"psfun_krylov_mod – PSFUN","text":"This module implements the Krylov methods for the solution of shifted linear\n systems: . It is built as an extension of the Krylov module\n for PSBLAS ( psb_krylov_mod ) Uses psb_base_mod psb_prec_mod amg_prec_mod module~~psfun_krylov_mod~~UsesGraph module~psfun_krylov_mod psfun_krylov_mod amg_prec_mod amg_prec_mod module~psfun_krylov_mod->amg_prec_mod psb_base_mod psb_base_mod module~psfun_krylov_mod->psb_base_mod psb_prec_mod psb_prec_mod module~psfun_krylov_mod->psb_prec_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~psfun_krylov_mod~~UsedByGraph module~psfun_krylov_mod psfun_krylov_mod program~shiftedtest shiftedtest program~shiftedtest->module~psfun_krylov_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces psb_krylov Subroutines psfun_dkrylov_vect Interfaces public interface psb_krylov We add the methods for the shifted system to the same interfaces in PSBLAS\n it is a lazy way to avoid modifying all the Krylov methods in PSBLAS to\n allow for the solution of shifted linear systems public subroutine psfun_dkrylov_vect (method, a, prec, b, eta, zeta, x, eps, desc_a, info, itmax, iter, err, itrace, irst, istop, cond) Apply Krylov method to on distributed vectors Arguments Type Intent Optional Attributes Name character(len=*) :: method type(psb_dspmat_type), intent(in) :: a class(psb_dprec_type), intent(inout) :: prec type(psb_d_vect_type), intent(inout) :: b real(kind=psb_dpk_), intent(in) :: eta real(kind=psb_dpk_), intent(in) :: zeta type(psb_d_vect_type), intent(inout) :: x real(kind=psb_dpk_), intent(in) :: eps type(psb_desc_type), intent(in) :: desc_a integer(kind=psb_ipk_), intent(out) :: info integer(kind=psb_ipk_), intent(in), optional :: itmax integer(kind=psb_ipk_), intent(out), optional :: iter real(kind=psb_dpk_), intent(out), optional :: err integer(kind=psb_ipk_), intent(in), optional :: itrace integer(kind=psb_ipk_), intent(in), optional :: irst integer(kind=psb_ipk_), intent(in), optional :: istop real(kind=psb_dpk_), intent(out), optional :: cond Subroutines public subroutine psfun_dkrylov_vect (method, a, prec, b, eta, zeta, x, eps, desc_a, info, itmax, iter, err, itrace, irst, istop, cond) Apply Krylov method to on distributed vectors Arguments Type Intent Optional Attributes Name character(len=*) :: method type(psb_dspmat_type), intent(in) :: a class(psb_dprec_type), intent(inout) :: prec type(psb_d_vect_type), intent(inout) :: b real(kind=psb_dpk_), intent(in) :: eta real(kind=psb_dpk_), intent(in) :: zeta type(psb_d_vect_type), intent(inout) :: x real(kind=psb_dpk_), intent(in) :: eps type(psb_desc_type), intent(in) :: desc_a integer(kind=psb_ipk_), intent(out) :: info integer(kind=psb_ipk_), intent(in), optional :: itmax integer(kind=psb_ipk_), intent(out), optional :: iter real(kind=psb_dpk_), intent(out), optional :: err integer(kind=psb_ipk_), intent(in), optional :: itrace integer(kind=psb_ipk_), intent(in), optional :: irst integer(kind=psb_ipk_), intent(in), optional :: istop real(kind=psb_dpk_), intent(out), optional :: cond","tags":"","loc":"module/psfun_krylov_mod.html"},{"title":"psfun_d_krylov_mod – PSFUN","text":"The psfun_d_krylov_mod contains the generic call to a Krylov subspace\n method for the computation of , for large and\n sparse. The various Krylov methods are contained in associated submodules, the\n idea is to have different methods, associated to the same\n orthogonalization method in the same submodule Uses psb_base_mod psb_krylov_mod amg_prec_mod psfun_d_serial_mod ogpf module~~psfun_d_krylov_mod~~UsesGraph module~psfun_d_krylov_mod psfun_d_krylov_mod psb_krylov_mod psb_krylov_mod module~psfun_d_krylov_mod->psb_krylov_mod module~psfun_d_serial_mod psfun_d_serial_mod module~psfun_d_krylov_mod->module~psfun_d_serial_mod ogpf ogpf module~psfun_d_krylov_mod->ogpf amg_prec_mod amg_prec_mod module~psfun_d_krylov_mod->amg_prec_mod psb_base_mod psb_base_mod module~psfun_d_krylov_mod->psb_base_mod module~psfun_d_serial_mod->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: psfun_d_arnoldi_mod psfun_d_lanczos_mod psfun_d_sai_mod module~~psfun_d_krylov_mod~~UsedByGraph module~psfun_d_krylov_mod psfun_d_krylov_mod module~psfun_d_sai_mod psfun_d_sai_mod module~psfun_d_sai_mod->module~psfun_d_krylov_mod module~psfun_d_arnoldi_mod psfun_d_arnoldi_mod module~psfun_d_arnoldi_mod->module~psfun_d_krylov_mod program~arnolditest arnolditest program~arnolditest->module~psfun_d_krylov_mod module~psfun_d_lanczos_mod psfun_d_lanczos_mod module~psfun_d_lanczos_mod->module~psfun_d_krylov_mod program~lanczostest lanczostest program~lanczostest->module~psfun_d_krylov_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces psfun_d_arnoldi psfun_d_lanczos psfun_d_saiarnoldi Derived Types psfun_d_krylov Subroutines psfun_d_parallel_apply psfun_d_plot_info psfun_d_prec_build psfun_d_prec_init Interfaces interface Simple polynomial method based on the Arnoldi orthogonalization procedure,\n the method builds a basis for the Krylov subspace public module subroutine psfun_d_arnoldi(fun, a, desc_a, y, x, eps, info, itmax, itrace, istop, iter, err, res) Simple polynomial method based on the Arnoldi orthogonalization procedure,\n the method builds a basis for the Krylov subspace Read more… Arguments Type Intent Optional Attributes Name type( psfun_d_serial ), intent(inout) :: fun Function object type(psb_dspmat_type), intent(in) :: a Distribute sparse matrix type(psb_desc_type), intent(in) :: desc_a Descriptor for the sparse matrix type(psb_d_vect_type), intent(inout) :: y Output vector type(psb_d_vect_type), intent(inout) :: x Input vector real(kind=psb_dpk_), intent(in) :: eps Requested tolerance integer(kind=psb_ipk_), intent(out) :: info Output flag integer(kind=psb_ipk_), intent(in), optional :: itmax Maximum number of iteration integer(kind=psb_ipk_), intent(in), optional :: itrace Trace for logoutput integer(kind=psb_ipk_), intent(in), optional :: istop Stop criterion integer(kind=psb_ipk_), intent(out), optional :: iter Number of iteration real(kind=psb_dpk_), intent(out), optional :: err Last estimate error real(kind=psb_dpk_), intent(out), optional allocatable :: res (:) Vector of the residuals interface Simple polynomial method based on the Lanczos orthogonalization procedure,\n the method builds a basis for the Krylov subspace public module subroutine psfun_d_lanczos(fun, a, desc_a, y, x, eps, info, itmax, itrace, istop, iter, err, res) Simple polynomial method based on the Lanczos orthogonalization procedure,\n the method builds a basis for the Krylov subspace Read more… Arguments Type Intent Optional Attributes Name type( psfun_d_serial ), intent(inout) :: fun Function object type(psb_dspmat_type), intent(in) :: a Distribute sparse matrix type(psb_desc_type), intent(in) :: desc_a Descriptor for the sparse matrix type(psb_d_vect_type), intent(inout) :: y Output vector type(psb_d_vect_type), intent(inout) :: x Input vector real(kind=psb_dpk_), intent(in) :: eps Requested tolerance integer(kind=psb_ipk_), intent(out) :: info Output flag integer(kind=psb_ipk_), intent(in), optional :: itmax Maximum number of iteration integer(kind=psb_ipk_), intent(in), optional :: itrace Trace for logoutput integer(kind=psb_ipk_), intent(in), optional :: istop Stop criterion integer(kind=psb_ipk_), intent(out), optional :: iter Number of iteration real(kind=psb_dpk_), intent(out), optional :: err Last estimate error real(kind=psb_dpk_), intent(out), optional allocatable :: res (:) Vector of the residuals interface This interface contains the Shift-and-Invert method based on Arnoldi\n orthogonalization. public module subroutine psfun_d_saiarnoldi(fun, a, kryl, prec, tau, desc_a, initmax, initrace, inistop, y, x, eps, info, itmax, itrace, istop, iter, err, res) Shift-and-invert method based on the Arnoldi orthogonalization procedure\n the method builds a basis for the shifted Krylov subspace Read more… Arguments Type Intent Optional Attributes Name type( psfun_d_serial ), intent(inout) :: fun Function object type(psb_dspmat_type), intent(in) :: a Distribute sparse matrix character(len=*), intent(in) :: kryl Krylov method for the solution of inner systems type(amg_dprec_type), intent(inout) :: prec Preconditioner for the inner method real(kind=psb_dpk_), intent(in) :: tau Shift parameter of the method type(psb_desc_type), intent(in) :: desc_a Descriptor for the sparse matrix integer(kind=psb_ipk_), intent(in) :: initmax Maximum number of iteration (inner method) integer(kind=psb_ipk_), intent(in) :: initrace Trace for logoutput (inner method) integer(kind=psb_ipk_), intent(in) :: inistop Stop criterion (inner method) type(psb_d_vect_type), intent(inout) :: y Output vector type(psb_d_vect_type), intent(inout) :: x Input vector real(kind=psb_dpk_), intent(in) :: eps Requested tolerance integer(kind=psb_ipk_), intent(out) :: info Output flag integer(kind=psb_ipk_), intent(in), optional :: itmax Maximum number of iteration integer(kind=psb_ipk_), intent(in), optional :: itrace Trace for logoutput integer(kind=psb_ipk_), intent(in), optional :: istop Stop criterion integer(kind=psb_ipk_), intent(out), optional :: iter Number of iteration real(kind=psb_dpk_), intent(out), optional :: err Last estimate error real(kind=psb_dpk_), intent(out), optional allocatable :: res (:) Vector of the residuals Derived Types type, public :: psfun_d_krylov Components Type Visibility Attributes Name Initial integer(kind=psb_ipk_), public :: irst = 10 Size for subspace restarting (inner method) integer(kind=psb_ipk_), public :: istopc = 1 Stopping criterion (inner method) integer(kind=psb_ipk_), public :: itmax = 200 Maximum number of iterations (inner method) integer(kind=psb_ipk_), public :: itrace = 0 Trace for the solution (inner method) character(len=20), public :: kmethd = 'CG' Method for the solution of the linear system character(len=20), public :: kname = 'ARNOLDI' Name of the Krylov method type(amg_dprec_type), public :: prec Preconditioner for the inner solution method real(kind=psb_dpk_), public :: tau = dzero Shift for shift-and-invert methods Type-Bound Procedures procedure, public, pass(meth) :: apply => psfun_d_parallel_apply procedure, public, pass(meth) :: plot => psfun_d_plot_info procedure, public, pass(meth) :: precbuild => psfun_d_prec_build procedure, public, pass(meth) :: precinit => psfun_d_prec_init generic, public :: set => setstring, setinteger procedure, public, pass(meth) :: setinteger => psfun_d_setinteger procedure, public, pass(meth) :: setstring => psfun_d_setstring Subroutines public subroutine psfun_d_parallel_apply (meth, fun, a, desc_a, y, x, eps, info, itmax, itrace, istop, iter, err, res) This is the generic function for applying every implemented Krylov\n method. The general iteration parameters (like the number of iteration,\n the stop criterion to be used, and the verbosity of the trace) can be\n passed directly to this routine. All the constitutive parameters of\n the actual method, and the information relative to the function are\n instead contained in the meth and fun objects. The Descriptor object\n `desc_a' contains the properties of the parallel environment. Arguments Type Intent Optional Attributes Name class( psfun_d_krylov ), intent(inout) :: meth Krylov method object type( psfun_d_serial ), intent(inout) :: fun Function object type(psb_dspmat_type), intent(in) :: a Distribute sparse matrix type(psb_desc_type), intent(in) :: desc_a Descriptor for the sparse matrix type(psb_d_vect_type), intent(inout) :: y Output vector type(psb_d_vect_type), intent(inout) :: x Input vector real(kind=psb_dpk_), intent(in) :: eps Requested tolerance integer(kind=psb_ipk_), intent(out) :: info Output flag integer(kind=psb_ipk_), intent(in), optional :: itmax Maximum number of iteration integer(kind=psb_ipk_), intent(in), optional :: itrace Trace for logoutput integer(kind=psb_ipk_), intent(in), optional :: istop Stop criterion integer(kind=psb_ipk_), intent(out), optional :: iter Number of iteration real(kind=psb_dpk_), intent(out), optional :: err Last estimate error real(kind=psb_dpk_), intent(out), optional allocatable :: res (:) Vector of the residuals public subroutine psfun_d_plot_info (meth, fun, iter, res, info) This function plots the convergence history of the Krylov method Arguments Type Intent Optional Attributes Name class( psfun_d_krylov ), intent(inout) :: meth Krylov method type( psfun_d_serial ), intent(inout) :: fun Function object integer(kind=psb_ipk_), intent(in) :: iter Number of iteration real(kind=psb_dpk_), intent(in), dimension(:) :: res Residual vector integer(kind=psb_ipk_), intent(out) :: info Result of the Gnuplot call public subroutine psfun_d_prec_build (meth, a, desc_a, info) This function builds the AMG4PSBLAS preconditioner for the inner solve\n in a Rational Krylov method Arguments Type Intent Optional Attributes Name class( psfun_d_krylov ), intent(inout) :: meth Krylov method type(psb_dspmat_type), intent(inout) :: a Sparse matrix type(psb_desc_type), intent(inout) :: desc_a Descriptor for the sparse matrix integer(kind=psb_ipk_) :: info Result of the init call public subroutine psfun_d_prec_init (meth, ctxt, ptype, info) This function performs the init of the preconditioner for the inner\n solve in the rational Krylov method Arguments Type Intent Optional Attributes Name class( psfun_d_krylov ), intent(inout) :: meth Krylov method type(psb_ctxt_type), intent(in) :: ctxt Parallel context character(len=20), intent(in) :: ptype PSBLAS/AMG4PSBLAS preconditioner integer(kind=psb_ipk_) :: info Result of the init call","tags":"","loc":"module/psfun_d_krylov_mod.html"},{"title":"psfun_utils_mod – PSFUN","text":"This modules contains some utility function that are used in the library. Uses psb_base_mod module~~psfun_utils_mod~~UsesGraph module~psfun_utils_mod psfun_utils_mod psb_base_mod psb_base_mod module~psfun_utils_mod->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: psfun_d_utils_mod psfun_z_utils_mod module~~psfun_utils_mod~~UsedByGraph module~psfun_utils_mod psfun_utils_mod module~psfun_base_quadrature_mod psfun_base_quadrature_mod module~psfun_base_quadrature_mod->module~psfun_utils_mod module~psfun_z_utils_mod psfun_z_utils_mod module~psfun_z_utils_mod->module~psfun_utils_mod program~quadraturetest quadraturetest program~quadraturetest->module~psfun_utils_mod module~psfun_quadrature_mod psfun_quadrature_mod program~quadraturetest->module~psfun_quadrature_mod module~psfun_d_quadrature_mod psfun_d_quadrature_mod module~psfun_d_quadrature_mod->module~psfun_utils_mod module~psfun_d_quadrature_mod->module~psfun_base_quadrature_mod module~psfun_d_utils_mod psfun_d_utils_mod module~psfun_d_utils_mod->module~psfun_utils_mod program~utiltest utiltest program~utiltest->module~psfun_utils_mod module~psfun_z_quadrature_mod psfun_z_quadrature_mod module~psfun_z_quadrature_mod->module~psfun_utils_mod module~psfun_z_quadrature_mod->module~psfun_base_quadrature_mod module~psfun_z_quadrules_mod psfun_z_quadrules_mod module~psfun_z_quadrules_mod->module~psfun_z_quadrature_mod module~psfun_quadrature_mod->module~psfun_base_quadrature_mod module~psfun_quadrature_mod->module~psfun_d_quadrature_mod module~psfun_quadrature_mod->module~psfun_z_quadrature_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces ellipj ellipkkp horner Interfaces public interface ellipj Returns the values of the Jacobi elliptic functions evaluated at real or complex argument u and parameter , . For , and the elliptic modulus. public subroutine d_ellipj(u, L, sn, cn, dn) Arguments Type Intent Optional Attributes Name real(kind=psb_dpk_), intent(in) :: u real(kind=psb_dpk_), intent(in) :: L real(kind=psb_dpk_), intent(out) :: sn real(kind=psb_dpk_), intent(out) :: cn real(kind=psb_dpk_), intent(out) :: dn public recursive subroutine z_ellipj(u, L, sn, cn, dn, flag) Arguments Type Intent Optional Attributes Name complex(kind=psb_dpk_), intent(in) :: u real(kind=psb_dpk_), intent(in) :: L complex(kind=psb_dpk_), intent(out) :: sn complex(kind=psb_dpk_), intent(out) :: cn complex(kind=psb_dpk_), intent(out) :: dn logical, intent(in), optional :: flag public interface ellipkkp Complete elliptic integral of the first kind, with complement.\n Returns the value of the complete elliptic integral of the first kind,\n evaluated at , , and the\n complementarity parameter . public function ellipkkp(L) result(K) Arguments Type Intent Optional Attributes Name real(kind=psb_dpk_), intent(in) :: L Return Value real(kind=psb_dpk_)\n  (2) public interface horner Apply Horner rule to evaluate a polynomial public function horner(coeffs, x) result(res) Arguments Type Intent Optional Attributes Name real(kind=psb_dpk_), intent(in), dimension (:) :: coeffs Coefficient of the polynomial real(kind=psb_dpk_), intent(in) :: x Where to evaluate Return Value real(kind=psb_dpk_) Result","tags":"","loc":"module/psfun_utils_mod.html"},{"title":"psfun_d_serial_mod – PSFUN","text":"This module contains the generic interfaces for the computation of the\n different matrix functions included in the library. The idea is that this\n modules computes, in a serial way, . For symmetric matrices we implement the Schur algorithm for the\n computation of . For this reason we need the psfun_d_serial type to have a member pointing to a function name for f. It is already\n defined to get also a second optional argument that tells the function\n to compute instead the kth derivative of f. This is done in light of\n the nonsymmetric case in which the Schur-Parlett algorithm should be used\n instead. Uses psb_base_mod module~~psfun_d_serial_mod~~UsesGraph module~psfun_d_serial_mod psfun_d_serial_mod psb_base_mod psb_base_mod module~psfun_d_serial_mod->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~psfun_d_serial_mod~~UsedByGraph module~psfun_d_serial_mod psfun_d_serial_mod module~psfun_d_krylov_mod psfun_d_krylov_mod module~psfun_d_krylov_mod->module~psfun_d_serial_mod proc~psfun_d_parallel_apply psfun_d_parallel_apply proc~psfun_d_parallel_apply->module~psfun_d_serial_mod program~arnolditest arnolditest program~arnolditest->module~psfun_d_serial_mod program~arnolditest->module~psfun_d_krylov_mod program~serialtest serialtest program~serialtest->module~psfun_d_serial_mod program~lanczostest lanczostest program~lanczostest->module~psfun_d_serial_mod program~lanczostest->module~psfun_d_krylov_mod module~psfun_d_lanczos_mod psfun_d_lanczos_mod module~psfun_d_lanczos_mod->module~psfun_d_krylov_mod module~psfun_d_sai_mod psfun_d_sai_mod module~psfun_d_sai_mod->module~psfun_d_krylov_mod module~psfun_d_arnoldi_mod psfun_d_arnoldi_mod module~psfun_d_arnoldi_mod->module~psfun_d_krylov_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Abstract Interfaces func Derived Types psfun_d_serial Subroutines psfun_d_serial_apply_array psfun_d_serial_apply_sparse Abstract Interfaces abstract interface public function func(x, k) Arguments Type Intent Optional Attributes Name real(kind=psb_dpk_), intent(in) :: x Value to be computed integer(kind=psb_ipk_), intent(in), optional :: k Computes kth derivative Return Value real(kind=psb_dpk_) Derived Types type, public :: psfun_d_serial Components Type Visibility Attributes Name Initial procedure( func ), public, pointer, nopass :: f_ptr => null() Pointer of a function character(len=20), public :: fname = 'EXP' Name of the function integer(kind=psb_ipk_), public :: padedegree = 6_psb_ipk_ Degree of Padé expansion integer(kind=psb_ipk_), public :: phiorder = 1_psb_ipk_ Order of the -function real(kind=psb_dpk_), public :: scaling = 1.0_psb_dpk_ of character(len=20), public :: variant = 'EXPOKIT' Implementatio variant Type-Bound Procedures generic, public :: apply => applya, applys procedure, public, pass(fun) :: applya => psfun_d_serial_apply_array procedure, public, pass(fun) :: applys => psfun_d_serial_apply_sparse generic, public :: set => setstring, setreal, setinteger, setfunction procedure, public, pass(fun) :: setfunction => psfun_d_setpointer procedure, public, pass(fun) :: setinteger => psfun_d_setinteger procedure, public, pass(fun) :: setreal => psfun_d_setreal procedure, public, pass(fun) :: setstring => psfun_d_setstring Subroutines public subroutine psfun_d_serial_apply_array (fun, a, y, x, info) This is the core of the function apply on a serial matrix to compute . It calls on the specific routines\n implementing the different functions. It is the function to modify if\n ones want to interface a new function that was not previously\n available or a new algorithm (variant) for an already existing\n function. Read more… Arguments Type Intent Optional Attributes Name class( psfun_d_serial ), intent(inout) :: fun Function information real(kind=psb_dpk_), intent(in) :: a (:,:) Matrix real(kind=psb_dpk_), intent(out) :: y (:) Output vector real(kind=psb_dpk_), intent(in) :: x (:) Input vector integer(kind=psb_ipk_), intent(out) :: info Information on the output Read more… public subroutine psfun_d_serial_apply_sparse (fun, a, y, x, info) This is the core of the function apply on a serial matrix to compute when A is memorized in a sparse storage.\n In this case the routine converts it to a dense storage and then calls\n the array version of itself. That is the one implementing the\n different functions. It is the function to modify if ones want to\n interface a new function that was not previously available or a new\n algorithm (variant) for an already existing function. Arguments Type Intent Optional Attributes Name class( psfun_d_serial ), intent(inout) :: fun Function information type(psb_dspmat_type), intent(inout) :: a Matrix real(kind=psb_dpk_), intent(out) :: y (:) Output vector real(kind=psb_dpk_), intent(in) :: x (:) Input vector integer(kind=psb_ipk_), intent(out) :: info Information on the output","tags":"","loc":"module/psfun_d_serial_mod.html"},{"title":"psfun_z_quadrules_mod – PSFUN","text":"This submodule contains the impliementation of the legacy quadrature rules\n distributed with the library. Uses Ancestors: psfun_z_quadrature_mod module~~psfun_z_quadrules_mod~~UsesGraph module~psfun_z_quadrules_mod psfun_z_quadrules_mod module~psfun_z_quadrature_mod psfun_z_quadrature_mod module~psfun_z_quadrules_mod->module~psfun_z_quadrature_mod ogpf ogpf module~psfun_z_quadrature_mod->ogpf psb_base_mod psb_base_mod module~psfun_z_quadrature_mod->psb_base_mod module~psfun_base_quadrature_mod psfun_base_quadrature_mod module~psfun_z_quadrature_mod->module~psfun_base_quadrature_mod module~psfun_utils_mod psfun_utils_mod module~psfun_z_quadrature_mod->module~psfun_utils_mod module~psfun_base_quadrature_mod->psb_base_mod module~psfun_base_quadrature_mod->module~psfun_utils_mod psb_krylov_mod psb_krylov_mod module~psfun_base_quadrature_mod->psb_krylov_mod psb_prec_mod psb_prec_mod module~psfun_base_quadrature_mod->psb_prec_mod module~psfun_utils_mod->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/psfun_z_quadrules_mod.html"},{"title":"psfun_d_lanczos_mod – PSFUN","text":"This modules implements the variant of the Lanczos method for the\n computation of . Uses Ancestors: psfun_d_krylov_mod module~~psfun_d_lanczos_mod~~UsesGraph module~psfun_d_lanczos_mod psfun_d_lanczos_mod module~psfun_d_krylov_mod psfun_d_krylov_mod module~psfun_d_lanczos_mod->module~psfun_d_krylov_mod psb_krylov_mod psb_krylov_mod module~psfun_d_krylov_mod->psb_krylov_mod module~psfun_d_serial_mod psfun_d_serial_mod module~psfun_d_krylov_mod->module~psfun_d_serial_mod ogpf ogpf module~psfun_d_krylov_mod->ogpf amg_prec_mod amg_prec_mod module~psfun_d_krylov_mod->amg_prec_mod psb_base_mod psb_base_mod module~psfun_d_krylov_mod->psb_base_mod module~psfun_d_serial_mod->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/psfun_d_lanczos_mod.html"},{"title":"psfun_d_arnoldi_mod – PSFUN","text":"This modules implements the variant of the Arnoldi method for the\n computation of . Uses Ancestors: psfun_d_krylov_mod module~~psfun_d_arnoldi_mod~~UsesGraph module~psfun_d_arnoldi_mod psfun_d_arnoldi_mod module~psfun_d_krylov_mod psfun_d_krylov_mod module~psfun_d_arnoldi_mod->module~psfun_d_krylov_mod psb_krylov_mod psb_krylov_mod module~psfun_d_krylov_mod->psb_krylov_mod module~psfun_d_serial_mod psfun_d_serial_mod module~psfun_d_krylov_mod->module~psfun_d_serial_mod ogpf ogpf module~psfun_d_krylov_mod->ogpf amg_prec_mod amg_prec_mod module~psfun_d_krylov_mod->amg_prec_mod psb_base_mod psb_base_mod module~psfun_d_krylov_mod->psb_base_mod module~psfun_d_serial_mod->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/psfun_d_arnoldi_mod.html"},{"title":"psfun_d_sai_mod – PSFUN","text":"This modules implements the variant of the Shitf-And-Invert method for the\n computation of . Uses Ancestors: psfun_d_krylov_mod module~~psfun_d_sai_mod~~UsesGraph module~psfun_d_sai_mod psfun_d_sai_mod module~psfun_d_krylov_mod psfun_d_krylov_mod module~psfun_d_sai_mod->module~psfun_d_krylov_mod psb_krylov_mod psb_krylov_mod module~psfun_d_krylov_mod->psb_krylov_mod module~psfun_d_serial_mod psfun_d_serial_mod module~psfun_d_krylov_mod->module~psfun_d_serial_mod ogpf ogpf module~psfun_d_krylov_mod->ogpf amg_prec_mod amg_prec_mod module~psfun_d_krylov_mod->amg_prec_mod psb_base_mod psb_base_mod module~psfun_d_krylov_mod->psb_base_mod module~psfun_d_serial_mod->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/psfun_d_sai_mod.html"},{"title":"psfun_d_utils_mod – PSFUN","text":"Real variants of the utils functions Uses psb_base_mod Ancestors: psfun_utils_mod module~~psfun_d_utils_mod~~UsesGraph module~psfun_d_utils_mod psfun_d_utils_mod psb_base_mod psb_base_mod module~psfun_d_utils_mod->psb_base_mod module~psfun_utils_mod psfun_utils_mod module~psfun_d_utils_mod->module~psfun_utils_mod module~psfun_utils_mod->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/psfun_d_utils_mod.html"},{"title":"psfun_z_utils_mod – PSFUN","text":"Complex variants of the utils functions Uses psb_base_mod Ancestors: psfun_utils_mod module~~psfun_z_utils_mod~~UsesGraph module~psfun_z_utils_mod psfun_z_utils_mod psb_base_mod psb_base_mod module~psfun_z_utils_mod->psb_base_mod module~psfun_utils_mod psfun_utils_mod module~psfun_z_utils_mod->module~psfun_utils_mod module~psfun_utils_mod->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/psfun_z_utils_mod.html"},{"title":"quadraturetest – PSFUN","text":"Uses psb_base_mod psfun_utils_mod psfun_quadrature_mod program~~quadraturetest~~UsesGraph program~quadraturetest quadraturetest psb_base_mod psb_base_mod program~quadraturetest->psb_base_mod module~psfun_utils_mod psfun_utils_mod program~quadraturetest->module~psfun_utils_mod module~psfun_quadrature_mod psfun_quadrature_mod program~quadraturetest->module~psfun_quadrature_mod module~psfun_utils_mod->psb_base_mod module~psfun_d_quadrature_mod psfun_d_quadrature_mod module~psfun_quadrature_mod->module~psfun_d_quadrature_mod module~psfun_base_quadrature_mod psfun_base_quadrature_mod module~psfun_quadrature_mod->module~psfun_base_quadrature_mod module~psfun_z_quadrature_mod psfun_z_quadrature_mod module~psfun_quadrature_mod->module~psfun_z_quadrature_mod module~psfun_d_quadrature_mod->psb_base_mod module~psfun_d_quadrature_mod->module~psfun_utils_mod module~psfun_d_quadrature_mod->module~psfun_base_quadrature_mod ogpf ogpf module~psfun_d_quadrature_mod->ogpf module~psfun_base_quadrature_mod->psb_base_mod module~psfun_base_quadrature_mod->module~psfun_utils_mod psb_krylov_mod psb_krylov_mod module~psfun_base_quadrature_mod->psb_krylov_mod psb_prec_mod psb_prec_mod module~psfun_base_quadrature_mod->psb_prec_mod module~psfun_z_quadrature_mod->psb_base_mod module~psfun_z_quadrature_mod->module~psfun_utils_mod module~psfun_z_quadrature_mod->module~psfun_base_quadrature_mod module~psfun_z_quadrature_mod->ogpf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Basic test for the quadrature routines from psfun_quadrature_mod Calls program~~quadraturetest~~CallsGraph program~quadraturetest quadraturetest psb_init psb_init program~quadraturetest->psb_init psb_exit psb_exit program~quadraturetest->psb_exit psb_get_errstatus psb_get_errstatus program~quadraturetest->psb_get_errstatus psb_info psb_info program~quadraturetest->psb_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables N c ctxt eta i info name quad quadformula rparams sign xi zfun Functions fun Variables Type Attributes Name Initial integer(kind=psb_ipk_) :: N complex(kind=psb_dpk_), allocatable, dimension(:) :: c type(psb_ctxt_type) :: ctxt real(kind=psb_dpk_) :: eta integer(kind=psb_ipk_) :: i integer(kind=psb_ipk_) :: info character(len=20) :: name type(psfun_z_quadrature) :: quad procedure(zquadrule), pointer :: quadformula real(kind=psb_dpk_) :: rparams (2) real(kind=psb_dpk_) :: sign complex(kind=psb_dpk_), allocatable, dimension(:) :: xi procedure(zquadfun), pointer :: zfun Functions function fun (z) result(res) Function to integrate Arguments Type Intent Optional Attributes Name complex(kind=psb_dpk_), intent(in) :: z Return Value complex(kind=psb_dpk_)","tags":"","loc":"program/quadraturetest.html"},{"title":"utiltest – PSFUN","text":"Uses psb_base_mod psfun_utils_mod program~~utiltest~~UsesGraph program~utiltest utiltest psb_base_mod psb_base_mod program~utiltest->psb_base_mod module~psfun_utils_mod psfun_utils_mod program~utiltest->module~psfun_utils_mod module~psfun_utils_mod->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Test of the utilities distributed with the PSFUN library in psfun_utils_mod Calls program~~utiltest~~CallsGraph program~utiltest utiltest psb_exit psb_exit program~utiltest->psb_exit psb_info psb_info program~utiltest->psb_info interface~ellipj ellipj program~utiltest->interface~ellipj psb_init psb_init program~utiltest->psb_init psb_get_errstatus psb_get_errstatus program~utiltest->psb_get_errstatus Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables K L ccn cdn cn coeffs csn ctxt cu dn iam info np result sn u Variables Type Attributes Name Initial real(kind=psb_dpk_) :: K (2) real(kind=psb_dpk_) :: L complex(kind=psb_dpk_) :: ccn complex(kind=psb_dpk_) :: cdn real(kind=psb_dpk_) :: cn real(kind=psb_dpk_), parameter :: coeffs (7) = (/132.0, 42.0, 14.0, 5.0, 2.0, 1.0, 0.0/) complex(kind=psb_dpk_) :: csn type(psb_ctxt_type) :: ctxt complex(kind=psb_dpk_) :: cu real(kind=psb_dpk_) :: dn integer(kind=psb_ipk_) :: iam integer(kind=psb_ipk_) :: info integer(kind=psb_ipk_) :: np real(kind=psb_dpk_) :: result real(kind=psb_dpk_) :: sn real(kind=psb_dpk_) :: u","tags":"","loc":"program/utiltest.html"},{"title":"shiftedtest – PSFUN","text":"Uses psb_base_mod psb_prec_mod psb_krylov_mod psb_util_mod psfun_krylov_mod getp program~~shiftedtest~~UsesGraph program~shiftedtest shiftedtest psb_krylov_mod psb_krylov_mod program~shiftedtest->psb_krylov_mod psb_base_mod psb_base_mod program~shiftedtest->psb_base_mod psb_prec_mod psb_prec_mod program~shiftedtest->psb_prec_mod module~psfun_krylov_mod psfun_krylov_mod program~shiftedtest->module~psfun_krylov_mod psb_util_mod psb_util_mod program~shiftedtest->psb_util_mod module~getp getp program~shiftedtest->module~getp module~psfun_krylov_mod->psb_base_mod module~psfun_krylov_mod->psb_prec_mod amg_prec_mod amg_prec_mod module~psfun_krylov_mod->amg_prec_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Test program for the shifted Krylov methods from psfun_krylov_mod Calls program~~shiftedtest~~CallsGraph program~shiftedtest shiftedtest psb_cdfree psb_cdfree program~shiftedtest->psb_cdfree psb_geasb psb_geasb program~shiftedtest->psb_geasb interface~get_parms get_parms program~shiftedtest->interface~get_parms psb_bcast psb_bcast program~shiftedtest->psb_bcast 4 4 program~shiftedtest->4 psb_geaxpby psb_geaxpby program~shiftedtest->psb_geaxpby psb_amx psb_amx program~shiftedtest->psb_amx psb_geall psb_geall program~shiftedtest->psb_geall psb_exit psb_exit program~shiftedtest->psb_exit psb_spfree psb_spfree program~shiftedtest->psb_spfree psb_genrm2 psb_genrm2 program~shiftedtest->psb_genrm2 psb_gefree psb_gefree program~shiftedtest->psb_gefree psb_wtime psb_wtime program~shiftedtest->psb_wtime psb_spmm psb_spmm program~shiftedtest->psb_spmm psb_sum psb_sum program~shiftedtest->psb_sum psb_abort psb_abort program~shiftedtest->psb_abort hb_read hb_read program~shiftedtest->hb_read psb_info psb_info program~shiftedtest->psb_info psb_barrier psb_barrier program~shiftedtest->psb_barrier distr_mtpart distr_mtpart program~shiftedtest->distr_mtpart getv_mtpart getv_mtpart program~shiftedtest->getv_mtpart mm_mat_read mm_mat_read program~shiftedtest->mm_mat_read psb_gather psb_gather program~shiftedtest->psb_gather psb_init psb_init program~shiftedtest->psb_init psb_matdist psb_matdist program~shiftedtest->psb_matdist build_mtpart build_mtpart program~shiftedtest->build_mtpart interface~psb_krylov psb_krylov program~shiftedtest->interface~psb_krylov psb_errstatus_fatal psb_errstatus_fatal program~shiftedtest->psb_errstatus_fatal psb_errpush psb_errpush program~shiftedtest->psb_errpush mm_array_read mm_array_read program~shiftedtest->mm_array_read psb_set_errverbosity psb_set_errverbosity program~shiftedtest->psb_set_errverbosity psb_scatter psb_scatter program~shiftedtest->psb_scatter psb_toupper psb_toupper program~shiftedtest->psb_toupper psb_realloc psb_realloc program~shiftedtest->psb_realloc psb_geamax psb_geamax program~shiftedtest->psb_geamax proc~get_dparms get_dparms interface~get_parms->proc~get_dparms proc~psfun_dkrylov_vect psfun_dkrylov_vect interface~psb_krylov->proc~psfun_dkrylov_vect proc~get_dparms->psb_bcast proc~get_dparms->psb_abort proc~get_dparms->psb_info proc~psfun_dkrylov_vect->psb_info proc~psfun_dkrylov_vect->psb_toupper psb_erractionsave psb_erractionsave proc~psfun_dkrylov_vect->psb_erractionsave psb_erractionrestore psb_erractionrestore proc~psfun_dkrylov_vect->psb_erractionrestore Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables a afmt amatsize aux_a aux_b b_amax b_col b_col_glob cond ctxt d desc_a descsize dim eps err err_act eta filefmt fname fnout i iam ierr ii info internal iparm ipv ircode irst istopc iter itmax itrace iunit ivg j kmethd lnp m m_problem methd mtrx_file n_row name ne nnzero np nrhs nrow nv part prec precsize ptype r_amax r_col r_col_glob resmx resmxp rhs_file scale t1 t2 tprec x_col x_col_glob zeta Variables Type Attributes Name Initial type(psb_dspmat_type) :: a character(len=5) :: afmt integer(kind=psb_epk_) :: amatsize type(psb_ldspmat_type) :: aux_a real(kind=psb_dpk_), allocatable, target :: aux_b (:,:) real(kind=psb_dpk_) :: b_amax type(psb_d_vect_type) :: b_col real(kind=psb_dpk_), pointer :: b_col_glob (:) real(kind=psb_dpk_) :: cond type(psb_ctxt_type) :: ctxt real(kind=psb_dpk_), allocatable, target :: d (:) type(psb_desc_type) :: desc_a integer(kind=psb_epk_) :: descsize integer(kind=psb_ipk_) :: dim real(kind=psb_dpk_) :: eps real(kind=psb_dpk_) :: err integer(kind=psb_ipk_) :: err_act real(kind=psb_dpk_) :: eta character(len=2) :: filefmt character(len=40) :: fname character(len=40) :: fnout integer(kind=psb_ipk_) :: i integer(kind=psb_ipk_) :: iam integer(kind=psb_ipk_) :: ierr integer(kind=psb_ipk_) :: ii integer(kind=psb_ipk_) :: info integer(kind=psb_ipk_) :: internal integer(kind=psb_ipk_) :: iparm (20) integer(kind=psb_ipk_), allocatable :: ipv (:) integer(kind=psb_ipk_) :: ircode integer(kind=psb_ipk_) :: irst integer(kind=psb_ipk_) :: istopc integer(kind=psb_ipk_) :: iter integer(kind=psb_ipk_) :: itmax integer(kind=psb_ipk_) :: itrace integer(kind=psb_ipk_), parameter :: iunit = 12 integer(kind=psb_ipk_), allocatable :: ivg (:) integer(kind=psb_ipk_) :: j character(len=40) :: kmethd integer(kind=psb_lpk_) :: lnp integer(kind=psb_ipk_) :: m integer(kind=psb_ipk_) :: m_problem integer(kind=psb_ipk_) :: methd character(len=40) :: mtrx_file integer(kind=psb_ipk_) :: n_row character(len=20) :: name integer(kind=psb_ipk_) :: ne integer(kind=psb_ipk_) :: nnzero integer(kind=psb_ipk_) :: np integer(kind=psb_ipk_) :: nrhs integer(kind=psb_ipk_) :: nrow integer(kind=psb_ipk_) :: nv character(len=20) :: part type(psb_dprec_type) :: prec integer(kind=psb_epk_) :: precsize character(len=40) :: ptype real(kind=psb_dpk_) :: r_amax type(psb_d_vect_type) :: r_col real(kind=psb_dpk_), allocatable, save :: r_col_glob (:) real(kind=psb_dpk_) :: resmx real(kind=psb_dpk_) :: resmxp character(len=40) :: rhs_file real(kind=psb_dpk_) :: scale real(kind=psb_dpk_) :: t1 real(kind=psb_dpk_) :: t2 real(kind=psb_dpk_) :: tprec type(psb_d_vect_type) :: x_col real(kind=psb_dpk_), allocatable, save :: x_col_glob (:) real(kind=psb_dpk_) :: zeta","tags":"","loc":"program/shiftedtest.html"},{"title":"arnolditest – PSFUN","text":"Uses psb_base_mod psb_util_mod psfun_d_serial_mod psfun_d_krylov_mod program~~arnolditest~~UsesGraph program~arnolditest arnolditest psb_util_mod psb_util_mod program~arnolditest->psb_util_mod psb_base_mod psb_base_mod program~arnolditest->psb_base_mod module~psfun_d_serial_mod psfun_d_serial_mod program~arnolditest->module~psfun_d_serial_mod module~psfun_d_krylov_mod psfun_d_krylov_mod program~arnolditest->module~psfun_d_krylov_mod module~psfun_d_serial_mod->psb_base_mod module~psfun_d_krylov_mod->psb_base_mod module~psfun_d_krylov_mod->module~psfun_d_serial_mod ogpf ogpf module~psfun_d_krylov_mod->ogpf amg_prec_mod amg_prec_mod module~psfun_d_krylov_mod->amg_prec_mod psb_krylov_mod psb_krylov_mod module~psfun_d_krylov_mod->psb_krylov_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Test for the parallel computation of matrix function by means of the psfun_d_arnoldi function. It applies the classical Arnoldi orthogonalization\n algorithm on a distributed matrix. Calls program~~arnolditest~~CallsGraph program~arnolditest arnolditest proc~get_parms get_parms program~arnolditest->proc~get_parms psb_cdfree psb_cdfree program~arnolditest->psb_cdfree psb_geasb psb_geasb program~arnolditest->psb_geasb psb_bcast psb_bcast program~arnolditest->psb_bcast psb_amx psb_amx program~arnolditest->psb_amx psb_geall psb_geall program~arnolditest->psb_geall psb_get_errstatus psb_get_errstatus program~arnolditest->psb_get_errstatus psb_exit psb_exit program~arnolditest->psb_exit psb_spfree psb_spfree program~arnolditest->psb_spfree psb_gefree psb_gefree program~arnolditest->psb_gefree psb_wtime psb_wtime program~arnolditest->psb_wtime psb_sum psb_sum program~arnolditest->psb_sum psb_abort psb_abort program~arnolditest->psb_abort hb_read hb_read program~arnolditest->hb_read psb_info psb_info program~arnolditest->psb_info psb_barrier psb_barrier program~arnolditest->psb_barrier distr_mtpart distr_mtpart program~arnolditest->distr_mtpart getv_mtpart getv_mtpart program~arnolditest->getv_mtpart mm_mat_read mm_mat_read program~arnolditest->mm_mat_read psb_init psb_init program~arnolditest->psb_init psb_matdist psb_matdist program~arnolditest->psb_matdist build_mtpart build_mtpart program~arnolditest->build_mtpart psb_errpush psb_errpush program~arnolditest->psb_errpush mm_array_read mm_array_read program~arnolditest->mm_array_read psb_scatter psb_scatter program~arnolditest->psb_scatter psb_toupper psb_toupper program~arnolditest->psb_toupper psb_realloc psb_realloc program~arnolditest->psb_realloc proc~get_parms->psb_bcast proc~get_parms->psb_abort proc~get_parms->psb_info proc~pr_usage pr_usage proc~get_parms->proc~pr_usage Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables a afmt amatsize aux_a aux_x ctxt desc_a descsize eps err filefmt fname fun i iam info ipv ircode istop iter itmax itrace iunit ivg kmethd lnp m_problem mname name np part perm res rhs_file scaling system_size t1 t2 variant x_col x_col_glob y_col Subroutines get_parms pr_usage Variables Type Attributes Name Initial type(psb_dspmat_type) :: a character(len=20) :: afmt integer(kind=psb_epk_) :: amatsize type(psb_ldspmat_type) :: aux_a real(kind=psb_dpk_), allocatable, target :: aux_x (:,:) type(psb_ctxt_type) :: ctxt type(psb_desc_type) :: desc_a integer(kind=psb_epk_) :: descsize real(kind=psb_dpk_) :: eps real(kind=psb_dpk_) :: err character(len=20) :: filefmt character(len=20) :: fname type( psfun_d_serial ) :: fun integer(kind=psb_ipk_) :: i integer(kind=psb_ipk_) :: iam integer(kind=psb_ipk_) :: info integer(kind=psb_ipk_), allocatable :: ipv (:) integer(kind=psb_ipk_) :: ircode integer(kind=psb_ipk_) :: istop integer(kind=psb_ipk_) :: iter integer(kind=psb_ipk_) :: itmax integer(kind=psb_ipk_) :: itrace integer(kind=psb_ipk_), parameter :: iunit = 12 integer(kind=psb_ipk_), allocatable :: ivg (:) type( psfun_d_krylov ) :: kmethd integer(kind=psb_lpk_) :: lnp integer(kind=psb_ipk_) :: m_problem character(len=20) :: mname character(len=20) :: name integer(kind=psb_ipk_) :: np character(len=20) :: part integer(kind=psb_ipk_), allocatable :: perm (:) real(kind=psb_dpk_), allocatable :: res (:) character(len=20) :: rhs_file real(kind=psb_dpk_) :: scaling integer(kind=psb_epk_) :: system_size real(kind=psb_dpk_) :: t1 real(kind=psb_dpk_) :: t2 character(len=20) :: variant type(psb_d_vect_type) :: x_col real(kind=psb_dpk_), pointer :: x_col_glob (:) type(psb_d_vect_type) :: y_col Subroutines subroutine get_parms (ctxt, mname, rhs_file, filefmt, part, afmt, fname, variant, scaling, eps, itmax, itrace, istop) This subroutine reads the parameters needed to run the arnolditest\n program from standard input Arguments Type Intent Optional Attributes Name type(psb_ctxt_type), intent(in) :: ctxt character(len=*), intent(out) :: mname character(len=*), intent(out) :: rhs_file character(len=*), intent(out) :: filefmt character(len=*), intent(out) :: part character(len=*), intent(out) :: afmt character(len=*), intent(out) :: fname character(len=*), intent(out) :: variant real(kind=psb_dpk_), intent(out) :: scaling real(kind=psb_dpk_), intent(out) :: eps integer(kind=psb_ipk_), intent(out) :: itmax integer(kind=psb_ipk_), intent(out) :: itrace integer(kind=psb_ipk_), intent(out) :: istop subroutine pr_usage (iout) Prints out information on incorrected program usage Arguments Type Intent Optional Attributes Name integer(kind=psb_ipk_) :: iout","tags":"","loc":"program/arnolditest.html"},{"title":"lanczostest – PSFUN","text":"Uses psb_base_mod psfun_d_serial_mod psfun_d_krylov_mod psb_util_mod program~~lanczostest~~UsesGraph program~lanczostest lanczostest psb_base_mod psb_base_mod program~lanczostest->psb_base_mod module~psfun_d_krylov_mod psfun_d_krylov_mod program~lanczostest->module~psfun_d_krylov_mod module~psfun_d_serial_mod psfun_d_serial_mod program~lanczostest->module~psfun_d_serial_mod psb_util_mod psb_util_mod program~lanczostest->psb_util_mod module~psfun_d_krylov_mod->psb_base_mod module~psfun_d_krylov_mod->module~psfun_d_serial_mod ogpf ogpf module~psfun_d_krylov_mod->ogpf amg_prec_mod amg_prec_mod module~psfun_d_krylov_mod->amg_prec_mod psb_krylov_mod psb_krylov_mod module~psfun_d_krylov_mod->psb_krylov_mod module~psfun_d_serial_mod->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Test for the parallel computation of matrix function by means of the psfun_d_lanczos function. It applies the classical Lanczos orthogonalization\n algorithm on a distributed matrix. Calls program~~lanczostest~~CallsGraph program~lanczostest lanczostest psb_cdfree psb_cdfree program~lanczostest->psb_cdfree psb_geasb psb_geasb program~lanczostest->psb_geasb psb_bcast psb_bcast program~lanczostest->psb_bcast psb_amx psb_amx program~lanczostest->psb_amx psb_geall psb_geall program~lanczostest->psb_geall psb_get_errstatus psb_get_errstatus program~lanczostest->psb_get_errstatus proc~get_parms~2 get_parms program~lanczostest->proc~get_parms~2 psb_exit psb_exit program~lanczostest->psb_exit psb_spfree psb_spfree program~lanczostest->psb_spfree psb_gefree psb_gefree program~lanczostest->psb_gefree psb_wtime psb_wtime program~lanczostest->psb_wtime psb_sum psb_sum program~lanczostest->psb_sum psb_abort psb_abort program~lanczostest->psb_abort hb_read hb_read program~lanczostest->hb_read psb_info psb_info program~lanczostest->psb_info psb_barrier psb_barrier program~lanczostest->psb_barrier distr_mtpart distr_mtpart program~lanczostest->distr_mtpart getv_mtpart getv_mtpart program~lanczostest->getv_mtpart mm_mat_read mm_mat_read program~lanczostest->mm_mat_read psb_init psb_init program~lanczostest->psb_init psb_matdist psb_matdist program~lanczostest->psb_matdist build_mtpart build_mtpart program~lanczostest->build_mtpart psb_errpush psb_errpush program~lanczostest->psb_errpush mm_array_read mm_array_read program~lanczostest->mm_array_read psb_scatter psb_scatter program~lanczostest->psb_scatter psb_toupper psb_toupper program~lanczostest->psb_toupper psb_realloc psb_realloc program~lanczostest->psb_realloc proc~get_parms~2->psb_bcast proc~get_parms~2->psb_abort proc~get_parms~2->psb_info proc~pr_usage~2 pr_usage proc~get_parms~2->proc~pr_usage~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables a afmt amatsize aux_a aux_x ctxt desc_a descsize eps err filefmt fname fun i iam info ipv ircode istop iter itmax itrace iunit ivg kmethd lnp m_problem mname name np part perm res rhs_file scaling system_size t1 t2 variant x_col x_col_glob y_col Subroutines get_parms pr_usage Variables Type Attributes Name Initial type(psb_dspmat_type) :: a character(len=20) :: afmt integer(kind=psb_epk_) :: amatsize type(psb_ldspmat_type) :: aux_a real(kind=psb_dpk_), allocatable, target :: aux_x (:,:) type(psb_ctxt_type) :: ctxt type(psb_desc_type) :: desc_a integer(kind=psb_epk_) :: descsize real(kind=psb_dpk_) :: eps real(kind=psb_dpk_) :: err character(len=20) :: filefmt character(len=20) :: fname type( psfun_d_serial ) :: fun integer(kind=psb_ipk_) :: i integer(kind=psb_ipk_) :: iam integer(kind=psb_ipk_) :: info integer(kind=psb_ipk_), allocatable :: ipv (:) integer(kind=psb_ipk_) :: ircode integer(kind=psb_ipk_) :: istop integer(kind=psb_ipk_) :: iter integer(kind=psb_ipk_) :: itmax integer(kind=psb_ipk_) :: itrace integer(kind=psb_ipk_), parameter :: iunit = 12 integer(kind=psb_ipk_), allocatable :: ivg (:) type( psfun_d_krylov ) :: kmethd integer(kind=psb_lpk_) :: lnp integer(kind=psb_ipk_) :: m_problem character(len=20) :: mname character(len=20) :: name integer(kind=psb_ipk_) :: np character(len=20) :: part integer(kind=psb_ipk_), allocatable :: perm (:) real(kind=psb_dpk_), allocatable :: res (:) character(len=20) :: rhs_file real(kind=psb_dpk_) :: scaling integer(kind=psb_epk_) :: system_size real(kind=psb_dpk_) :: t1 real(kind=psb_dpk_) :: t2 character(len=20) :: variant type(psb_d_vect_type) :: x_col real(kind=psb_dpk_), pointer :: x_col_glob (:) type(psb_d_vect_type) :: y_col Subroutines subroutine get_parms (ctxt, mname, rhs_file, filefmt, part, afmt, fname, variant, scaling, eps, itmax, itrace, istop) This subroutine reads the parameters needed to run the lanczostest\n program from standard input Arguments Type Intent Optional Attributes Name type(psb_ctxt_type), intent(in) :: ctxt character(len=*), intent(out) :: mname character(len=*), intent(out) :: rhs_file character(len=*), intent(out) :: filefmt character(len=*), intent(out) :: part character(len=*), intent(out) :: afmt character(len=*), intent(out) :: fname character(len=*), intent(out) :: variant real(kind=psb_dpk_), intent(out) :: scaling real(kind=psb_dpk_), intent(out) :: eps integer(kind=psb_ipk_), intent(out) :: itmax integer(kind=psb_ipk_), intent(out) :: itrace integer(kind=psb_ipk_), intent(out) :: istop subroutine pr_usage (iout) Prints out information on incorrected program usage Arguments Type Intent Optional Attributes Name integer(kind=psb_ipk_) :: iout","tags":"","loc":"program/lanczostest.html"},{"title":"serialtest – PSFUN","text":"Uses psb_base_mod psfun_d_serial_mod psb_util_mod program~~serialtest~~UsesGraph program~serialtest serialtest psb_base_mod psb_base_mod program~serialtest->psb_base_mod module~psfun_d_serial_mod psfun_d_serial_mod program~serialtest->module~psfun_d_serial_mod psb_util_mod psb_util_mod program~serialtest->psb_util_mod module~psfun_d_serial_mod->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Test program for the serial part of the library. This test program loads a\n matrix from file together with some options to test the serial computation\n of the matrix functions. Substantially, it test the interfacing with the\n library doing the serial part. Calls program~~serialtest~~CallsGraph program~serialtest serialtest psb_exit psb_exit program~serialtest->psb_exit psb_wtime psb_wtime program~serialtest->psb_wtime mm_array_write mm_array_write program~serialtest->mm_array_write psb_info psb_info program~serialtest->psb_info mm_mat_read mm_mat_read program~serialtest->mm_mat_read psb_init psb_init program~serialtest->psb_init psb_get_errstatus psb_get_errstatus program~serialtest->psb_get_errstatus proc~get_parms~3 get_parms program~serialtest->proc~get_parms~3 proc~pr_usage~3 pr_usage proc~get_parms~3->proc~pr_usage~3 psb_toupper psb_toupper proc~get_parms~3->psb_toupper psb_abort psb_abort proc~get_parms~3->psb_abort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables a ctxt dump fname fun iam info iunit mname n nnz np scaling t1 t2 variant x y Subroutines get_parms pr_usage Variables Type Attributes Name Initial type(psb_dspmat_type) :: a type(psb_ctxt_type) :: ctxt logical :: dump character(len=20) :: fname type( psfun_d_serial ) :: fun integer(kind=psb_ipk_) :: iam integer(kind=psb_ipk_) :: info integer(kind=psb_ipk_), parameter :: iunit = 12 character(len=20) :: mname integer(kind=psb_ipk_) :: n integer(kind=psb_ipk_) :: nnz integer(kind=psb_ipk_) :: np real(kind=psb_dpk_) :: scaling real(kind=psb_dpk_) :: t1 real(kind=psb_dpk_) :: t2 character(len=20) :: variant real(kind=psb_dpk_), allocatable :: x (:) real(kind=psb_dpk_), allocatable :: y (:) Subroutines subroutine get_parms (ctxt, mname, fname, variant, scaling, dump) This subroutine reads the parameters needed to run the serialtest\n program from standard input Arguments Type Intent Optional Attributes Name type(psb_ctxt_type), intent(in) :: ctxt character(len=*), intent(out) :: mname character(len=*), intent(out) :: fname character(len=*), intent(out) :: variant real(kind=psb_dpk_), intent(out) :: scaling logical, intent(out) :: dump subroutine pr_usage (iout) Prints out information on incorrected program usage Arguments Type Intent Optional Attributes Name integer(kind=psb_ipk_) :: iout","tags":"","loc":"program/serialtest.html"},{"title":"psblastest – PSFUN","text":"Uses psb_base_mod program~~psblastest~~UsesGraph program~psblastest psblastest psb_base_mod psb_base_mod program~psblastest->psb_base_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. This is a simple test for the base functionalities of the PSBLAS library.\n It can be used to see if everything links and is in order. Calls program~~psblastest~~CallsGraph program~psblastest psblastest psb_exit psb_exit program~psblastest->psb_exit psb_snd psb_snd program~psblastest->psb_snd psb_info psb_info program~psblastest->psb_info psb_init psb_init program~psblastest->psb_init psb_rcv psb_rcv program~psblastest->psb_rcv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ctxt iam idummy ip jp np Variables Type Attributes Name Initial type(psb_ctxt_type) :: ctxt integer(kind=psb_ipk_) :: iam integer(kind=psb_ipk_) :: idummy integer(kind=psb_ipk_) :: ip integer(kind=psb_ipk_) :: jp integer(kind=psb_ipk_) :: np","tags":"","loc":"program/psblastest.html"},{"title":"Matrix Functions – PSFUN","text":"Matrix function vector products This library is focused on the computation of matrix-function [1] vector products for large and sparse matrices in a distributed setting. Matrix functions are\nubiquitous in models for applied sciences. They are involved in the solution of\nordinary, partial, and fractional differential equations, systems of coupled\ndifferential equations, hybrid differential-algebraic problems,\nequilibrium problems, measures of complex networks, and many others. To perform the computation in \\eqref{eq:eq_problem_to_solve}, we consider here two\nmain approaches, the first one makes use of a definition based on the Cauchy integral for a matrix function: given a closed contour lying in the region of\nanalyticity of the function and containing the spectrum of , can be defined as By applying a quadrature formula on points to \\eqref{eq:eq_ContourInt},\nwith weights and nodes ,\nit is possible to approximate \\eqref{eq:eq_problem_to_solve} as that is then computationally equivalent to the solution of linear\nsystems with the same right-hand side. The second approach to problem \\eqref{eq:eq_problem_to_solve} resides instead on the\nuse of projection algorithm. Specifically, we suppose having two $k$-th\ndimensional subspaces and spanned by the\ncolumn of the matrices . Then, problem\n\\eqref{eq:eq_problem_to_solve} can be projected and approximated on the two subspaces\nby doing where now is a small matrix of size ,\nto which we can apply many specific algorithms for the particular choice of , [1] , or again a quadrature formula. The PSFUN Library The recent developments on softwares for sparse linear algebra have been made\nessential for a wide variety of scientific applications. Specifically, they have\nbeen dedicated to the construction of of massively parallel sparse solvers for\na particular matrix function , i.e., for the solution of\nlarge and sparse linear system. A computational framework that lies at the core\nof pretty much all multi-physics and multi-scale simulations. With this library, we try to face the analogous challenge of computing\nmatrix-function vector products for more general functions than the inverse. The library described here is substantially based on the parallel BLAS feature\nfor sparse matrices made available by the PSBLAS library ,\nand is geared towards the possibility of running on machines with thousands\nof high-performance cores, and is divided in three main modules, Serial module:\n   this module implements (or interfaces) the computation of , for matrices of small-size that can be\n   handled in a sequential way, Krylov module:\n   this module implements distributed Krylov based methods for the\n   reduction of problem \\eqref{eq:eq_problem_to_solve} to the solution of problems of\n   small dimensions, Quadrature module:\n   this module implements the approach in \\eqref{eq:eq_ContourInt} by implementing\n   different quadrature formulas. How To Install The first step to install the PSFUN is to obtain and install the PSBLAS library\nfrom PSCTOOLKIT . All the relevant information\ncan be found there. The actual version of the library works with the development version of PSBLAS,\nthis can be done obtained via GitHub by doing git clone https://github.com/sfilippone/psblas3.git cd psblas3\n./configure -with-<stuff> = ... -prefix = /path/to/psblas\nmake -j\nmake install in which the various -with-<stuff>=... options can be read from the\noutput of the ./configure -h , again please refer to the original\ndocumentation of PSBLAS for all the relevant information. Auxiliary packages that can be used with the library are: the package for the computation of -functions from , that can be\n   obtained from the ACM website . To build the documentation you need to use the FORD Python package, it can be installed simply by doing: pip install ford Building the documentation is optional , and can\nbe skipped during the configuration phase. In every case a copy of the docs\nis included with the code. After having installed all the dependencies, and the auxiliary packages the PSFUN\nlibrary can be installed via ccmake (Version 3.15), by setting\nthe position of PSBLAS, and all the auxiliary packages. git clone https://github.com/Cirdans-Home/psfun.git\nmkdir build cd build\nccmake ../psfun/\nmake\nmake install References [1] Higham, Nicholas J. Functions of matrices. Theory and computation. Society for Industrial and Applied Mathematics (SIAM), Philadelphia, PA, 2008. xx+425 pp. ISBN: 978-0-89871-646-7","tags":"","loc":"page//index.html"},{"title":"Algorithms – PSFUN","text":"We describe here the main algorithms implemented for the solution of and point to the relevant modules and subroutines in the library. Krylov Methods Let be an orthogonal matrix whose columns span an arbitrary Krylov subspace of\ndimension . We obtain an approximation of by Different methods for the approximation of matrix functions are obtained for\ndifferent choices of the projection spaces . Given a set of scalars in the the extended complex plane , that are not\neigenvalues of , let The rational Krylov subspace of order associated with , and is defined by where is the standard polynomial Krylov space. By defining the matrices where are such that , it is known that the\nrational Krylov space can also be written as follows [1] This general formulation allows to recast most of the classical Krylov\nmethods in terms of a rational Krylov method with a specific choice of and . In particular, the polynomial Krylov method in which can be recovered by defining and for each . The extended Krylov method [2] [3] , in which is obtained by setting The shift-and-invert rational Krylov [4] [5] , where is defined by taking and for each . The PSFUN library contains the implementation of several flavour of these methods\nthat can be used for the computation of \\eqref{eq:krylov_fA_approx}, the field\nin the psfun_d_krylov type represent the options neeeded to for setting\nup and applying the different implemented method for a given matrix function fun (represented by an object of type psfun_d_serial ). The following table has the info on the available methods. Method Class Matrix type \"kname\" Source Arnoldi Polynomial General \"ARNOLDI\" [6] Lanczos Polynomial Symmetric \"LANCZOS\" [6] Quadrature Methods This module makes use of the matrix function definition based on the Cauchy integral :\ngiven a closed contour lying in the region of\nanalyticity of the function and containing the spectrum of , can be defined as By applying a quadrature formula on points to \\eqref{eq:eq_ContourInt_quadrature},\nwith weights and nodes ,\nit is possible to approximate \\eqref{eq:eq_problem_to_solve} as that is then computationally equivalent to the solution of linear\nsystems with the same right-hand side. The construction of the quadrature module is made of several interconnected modules.\nThe base module is the psfun_base_quadrature_mod , it contains the\nbase module of which the different quadratures are extensions. Then the functions for working with the quadrature formula having either\nreal ( psb_dpk_ ) or complex quadrature nodes and weights for\n\\eqref{eq:eq_QuadratureFormula} are contained in the relative modules psfun_d_quadrature_mod psfun_z_quadrature_mod These two modules make use of abstract interface for both the dquadrule / zquadrule and the generic\nfunction for which we compute the . This is implemented this way\nto permit the user to implement its own quadrature rule and functions. An example\nof how this can be achieved is contained in the functions included in the\nsubmodules of psfun_z_quadrature_mod that implements the three routines\nfrom 7 . References [1] Güttel, Stefan.\nRational Krylov approximation of matrix functions: numerical methods and optimal\npole selection. GAMM-Mitt. 36 (2013), no. 1, 8--31. [2] Druskin, Vladimir; Knizhnerman, Leonid. Extended Krylov subspaces: approximation of the matrix square root and related functions. SIAM J. Matrix Anal. Appl. 19 (1998), no. 3, 755--771. [3] Knizhnerman, L.; Simoncini, V. A new investigation of the extended Krylov subspace method for matrix function evaluations. Numer. Linear Algebra Appl. 17 (2010), no. 4, 615--638. [4] Moret, I.; Novati, P. RD-rational approximations of the matrix exponential. BIT 44 (2004), no. 3, 595--615. [5] van den Eshof, Jasper; Hochbruck, Marlis. Preconditioning Lanczos approximations to the matrix exponential. SIAM J. Sci. Comput. 27 (2006), no. 4, 1438--1457. [6] Saad, Y. Analysis of some Krylov subspace approximations to the matrix exponential operator. SIAM J. Numer. Anal. 29 (1992), no. 1, 209--228. [7] Hale, Nicholas; Higham, Nicholas J.; Trefethen, Lloyd N. Computing , and related matrix functions by contour integrals. SIAM J. Numer. Anal. 46 (2008), no. 5, 2505--2523.","tags":"","loc":"page/./algorithms.html"},{"title":"Examples – PSFUN","text":"","tags":"","loc":"page/./examples.html"},{"title":"Utils – PSFUN","text":"The utils module contains some functions and subroutines which are used in\nvarious places in the library and which do not specifically belong to any of the\nother modules. Routines for the computation of some special functions, e.g.,\nelliptic integrals, Jacobi polynomials, etc., together with some internal service\nroutines. External libraries To make some plots with the Gnuplot software\ndirectly from the Fortran code, we distribute a modified version of the ogpf library.","tags":"","loc":"page/./utils.html"}]}